<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Roya&#39;s Blog</title>
  
  <subtitle>現代化 Web 開發技術學習分享</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://awdr74100.github.io/"/>
  <updated>2020-08-16T14:30:19.000Z</updated>
  <id>https://awdr74100.github.io/</id>
  
  <author>
    <name>Roya</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript - Promise 非同步物件使用方式及變體方法</title>
    <link href="https://awdr74100.github.io/2020-08-14-javascript-promise/"/>
    <id>https://awdr74100.github.io/2020-08-14-javascript-promise/</id>
    <published>2020-08-14T05:26:34.000Z</published>
    <updated>2020-08-16T14:30:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>非同步處理一直以來都是 JavaScript 開發者很常遇到的情境，在之前，我們很常使用 callback 去完成任務，當結構變得複雜時，容易形成所謂的 callback hell，造成程式碼難以維護；在 ES6 版本中，新增了 Promise 物件，它能夠將非同步流程包裝成簡潔的結構，並提供統一的錯誤處理機制，解決了傳統 callback hell 的問題。此篇將會解析 Promise 的處理流程與相關方法。</p><h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul><li>何謂 Callback 與 Callback hell ？</li><li>Promise 物件建立與基本使用</li><li>Promise 執行流程與錯誤處理</li><li>Promise 靜態方法</li><li>Promise 變體方法</li><li>改寫 Callback 函式</li></ul><h2 id="何謂-Callback-與-Callback-hell-？"><a href="#何謂-Callback-與-Callback-hell-？" class="headerlink" title="何謂 Callback 與 Callback hell ？"></a>何謂 Callback 與 Callback hell ？</h2><p>Callback 是 JavaScript 很常使用的一種處理方式，以下是一個簡單的 callback 範例：</p><div class="note warning">Callback：以參數型態傳入另一個函式的函式</div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'alertMsg trigger'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'main start'</span>);</span><br><span class="line">  callback();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'main end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(alertMsg);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  main start</span></span><br><span class="line"><span class="comment">  alertMsg trigger</span></span><br><span class="line"><span class="comment">  main end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在一般開發中，我們很常需要使用非同步處理去完成任務，像是 <code>XMLHttpRequest</code>、<code>setTimeout</code> …之類的，以下使用 <code>setTimeout</code> 來模擬非同步事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 setTimeout 模擬非同步事件，0s 無法改變它本質還是非同步事件</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'alertMsg trigger'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'main start'</span>);</span><br><span class="line">  callback();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'main end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(alertMsg);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  main start</span></span><br><span class="line"><span class="comment">  main end</span></span><br><span class="line"><span class="comment">  alertMsg trigger</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在 JavaScript 中，有 <code>event queue</code> 的特性，<strong>所有非同步事件都不會立即執行當下行為</strong>，而是將這些行為放到 <code>event queue</code> 中，等待事件觸發後再回來執行；從上面範例可得知，結果的順序改變了，如果我們要確保 <code>main end</code> 在最後觸發，只需將 <code>main end</code> 包裝成 function 並且當成 callback 傳進去就好了，如下範例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertMsg</span>(<span class="params">callback2</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'alertMsg trigger'</span>);</span><br><span class="line">    callback2();</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'main start'</span>);</span><br><span class="line">  callback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'main end'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(alertMsg);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  main start</span></span><br><span class="line"><span class="comment">  alertMsg trigger</span></span><br><span class="line"><span class="comment">  main end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>使用 callback 解決了非同步事件引發的問題，但當結構變得複雜時，使用 callback 容易產生 callback hell，使得後期維護非常痛苦，閱讀性也變得非常差，如下範例：</p><div class="note warning">Callback hell：簡稱回調地獄，通常發生在程式間需按照順序執行</div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> async_api1 = <span class="function">(<span class="params">callback2</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async_api1 end'</span>);</span><br><span class="line">    callback2();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> async_api2 = <span class="function">(<span class="params">callback3</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async_api2 end'</span>);</span><br><span class="line">    callback3();</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">  async_api1(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    async_api2(callback);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">main(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'main end'</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  --- delay 1s ---</span></span><br><span class="line"><span class="comment">  async_api1 end</span></span><br><span class="line"><span class="comment">  --- delay 2s ---</span></span><br><span class="line"><span class="comment">  async_api2 end</span></span><br><span class="line"><span class="comment">  --- delay 3s ---</span></span><br><span class="line"><span class="comment">  main end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>當你有許多的行為需要按照順序執行下去，此時你的程式碼就會變得非常混亂，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async_api1(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  async_api2(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    async_api3(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      async_api4(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>讓我們來看看 ES6 新推出的 Promise 物件是如何改善 callback hell 問題的。</p><h2 id="Promise-物件建立與基本使用"><a href="#Promise-物件建立與基本使用" class="headerlink" title="Promise 物件建立與基本使用"></a>Promise 物件建立與基本使用</h2><h3 id="Promise-物件的建立"><a href="#Promise-物件的建立" class="headerlink" title="Promise 物件的建立"></a>Promise 物件的建立</h3><div class="note warning">ES6 Promise 的實作中，會確保 Promise 物件一實體化後就會固定住狀態，要不就是"以實現"，要不就是"已拒絕"</div><p>一個簡單的 Promise 語法結構如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> async_api = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 成功時</span></span><br><span class="line">    resolve(<span class="string">'success'</span>);</span><br><span class="line">    <span class="comment">// 失敗時</span></span><br><span class="line">    reject(<span class="string">'error'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">async_api()</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// on fulfillment (以實現時)</span></span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// on rejection (已拒絕時)</span></span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>我們先來看 Promise 的建構函式，它的語法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123; ... &#125;);</span><br></pre></td></tr></table></figure><p>用箭頭函式簡化一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; ... &#125;);</span><br></pre></td></tr></table></figure><p>建構函式的傳入參數需要一個函式，參數名稱可自由定義，但建議要符合使用上的命名，如果沒有其他需求，使用 reslove 與 reject 更能夠提高其閱讀性。</p><h3 id="Promise-基本的使用"><a href="#Promise-基本的使用" class="headerlink" title="Promise 基本的使用"></a>Promise 基本的使用</h3><div class="note warning">then 方法是 Promise 的最核心方法，也是控制非同步事件最關鍵的因素</div><p>在 Promise 中，我們可以使用 <code>then()</code> 與 <code>catch()</code> 來接收回傳的內容，接續 Promise 物件的建立中的範例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async_api()</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// on fulfillment (以實現時)</span></span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// on rejection (已拒絕時)</span></span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>可能會有人看到的是下面這種寫法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async_api().then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// on fulfillment (以實現時)</span></span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// on rejection (已拒絕時)</span></span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>事實上，兩者的結果是一樣的，<code>then</code> 方法接受兩個函式當作傳入參數，第一個函式為 Promise 物件狀態轉變成 <code>fulfillment</code> 所呼叫，有一個傳入參數值可用；第二個函式為 Promise 物件狀態改變成 <code>rejected</code> 所呼叫，也有一個傳入參數值可用。</p><p>為什麼說它是一樣的結果呢？對於 <code>catch</code> 方法來說，相當於 <code>then(undefined, rejection)</code>，也就是 <code>then</code> 方法的第一個函式傳入參數沒有給定值的情況下，它算是個 <code>then</code> 方法的語法糖，這也代表著兩者在名稱的定義上有點不同，但意義其實是相近的。<strong>如果有 Promise Chain 的需求，盡量還是使用 <code>catch</code> 取代 <code>then</code> 的第二個函式</strong>，不然說實在的，對於結構性來講，會顯得非常混亂，下面是 <code>Promise Chain</code> 的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async_api()</span><br><span class="line">  .then(<span class="function">(<span class="params">response1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response1);</span><br><span class="line">    <span class="keyword">return</span> response1;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">response2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response2);</span><br><span class="line">    <span class="keyword">return</span> response2;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">response3</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response3);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>在 <code>then</code> 方法中的 <code>fulfillment</code> 函式，它是一個連鎖的結構，這也就代表著我們可以使用 <code>return</code> 語句來回傳值，這個值可以繼續往下面的 <code>then</code> 方法傳送，傳送過去的是一個<strong>新的</strong> Promise 物件；而 <code>rejected</code> 這一個函式，也有連鎖結構的特性，但由於它是使用在錯誤處理情況，除非你要用來修正錯誤之類的操作，不然這樣子的回傳操作，可能會造成結構異常混亂，這也是我上面提到的問題。</p><div class="note warning">為了方便進行多個不同程式碼的連鎖，通常在只使用 then 方法時，都只寫第 1 個函式傳入參數。而錯誤處理通常交給另一個 catch 方法來做</div><h2 id="Promise-執行流程與錯誤處理"><a href="#Promise-執行流程與錯誤處理" class="headerlink" title="Promise 執行流程與錯誤處理"></a>Promise 執行流程與錯誤處理</h2><h3 id="throw-與-reject"><a href="#throw-與-reject" class="headerlink" title="throw 與 reject"></a>throw 與 reject</h3><div class="note warning">Promise 中會隱藏 throw 例外的錯誤輸出，改用轉變狀態為 rejected(已拒絕)來做錯誤處理</div><p>在 Promise 建構函式中，直接使用 throw 語句相當於 reject 方法的作用，範例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> async_api = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'發生錯誤'</span>;</span><br><span class="line">    <span class="comment">// 如同使用下面語句</span></span><br><span class="line">    <span class="comment">// reject('發生錯誤');</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">async_api()</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error); <span class="comment">// 觸發：發生錯誤</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>我們知道 <code>throw</code> 主要用來使 JavaScript 停止執行並拋出錯誤，在 Promise 中按照規則，只要有丟出例外動作，當下狀態就會直接變成 <code>rejected</code> ，這也是使用 <code>throw</code> 能夠達到與 <code>reject()</code> 同樣效果的原因，但這僅限於同步的操作，我們以下面範例做補充：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> async_api = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">async_api()</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面這是一個使用 <code>setTimeout</code> 模擬非同步事件的範例，對於 <code>throw</code> 在一般程式使用中，會拋出錯誤並停止執行，在 Promise 的同步操作中，Promise 會隱藏錯誤並將當下狀態更改為 <code>rejected</code>，而在非同步操作中是無法隱藏錯誤的，這也代表 Promise 後續的連鎖都將出現錯誤，所以還是乖乖的使用 <code>reject</code> 方法就好，這才是正規操作 Promise 狀態的方法。</p><h3 id="執行流程與錯誤處理"><a href="#執行流程與錯誤處理" class="headerlink" title="執行流程與錯誤處理"></a>執行流程與錯誤處理</h3><p>在前面我們有介紹到關於 Promise Chain 的相關操作，這次我們來探討關於執行流程與錯誤處理的相關內容，先來看一下範例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> async_api = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="number">10</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">async_api()</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第一個'</span>);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第二個'</span>);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第三個'</span>); <span class="comment">// 觸發 (第三個)</span></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'第四個 - fulfillment'</span>); <span class="comment">// 觸發 (第四個 - fulfillment)</span></span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'第四個 - reject'</span>);</span><br><span class="line">      <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第五個'</span>);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第六個'</span>); <span class="comment">// 觸發 (第六個)</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第七個'</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>在 <code>then</code> 的第一個回傳條件下，會尋找相符合的第一個狀態，如同上面範例會觸發第三個 <code>catch</code>，接下來的回傳值都必須遵循下面的規範：</p><ul><li>回傳值不是函式或物件，直接將回傳值狀態用 <code>fulfilled</code> 實現，例：String、Number。</li><li>回傳值是 Promise 物件，回傳 Promise 最後的操作結果，例：resolve 方法、reject 方法。</li><li>回傳值是函式或物件，判斷是否為包裝的 Promise 物件，如果是，回傳 Promise 操作結果，如果不是，則直接將回傳值狀態用 <code>fulfilled</code> 實現，例：Object</li></ul><p>理解了上面三個規範，就能夠清楚的了解 <code>then</code> 的處理方式，如同上面這一個範例，雖然觸發了第三個 <code>catch</code>，但回傳值卻是 <code>Number</code>，這也就導致回傳值狀態用 <code>fulfilled</code> 實現，才會觸發第四個的 fulfilled 結果。</p><h2 id="Promise-靜態方法"><a href="#Promise-靜態方法" class="headerlink" title="Promise 靜態方法"></a>Promise 靜態方法</h2><div class="note warning">Promise.resolve 或 Promise.reject 只用於單純的傳入物件、值或外部的 thenable 物件，轉換為 Promise 物件的場合</div><p><code>Promise.resolve</code> 與 <code>Promise.reject</code> 是 Promise 的靜態方法，<code>Promise.resolve</code> 可直接產生 <code>fulfilled</code> 狀態的 Promise 物件，<code>Promise.reject</code> 則是 <code>rejected</code> 狀態的 Promise 物件，如下範例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promiseObject = <span class="built_in">Promise</span>.resolve(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">promiseObject.then(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise.resolve</code> 與 <code>Promise.reject</code> 與使用 Promise 建構式的方式相比，在使用上有很大的不同，以下面的例子說明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一： Promise 建構式</span></span><br><span class="line"><span class="keyword">const</span> initPromise_1 = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">'發生錯誤'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二： Promise.resolve + Promise.reject</span></span><br><span class="line"><span class="keyword">const</span> initPromise_2 = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (value % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'發生錯誤'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三： Promise.resolve + throw</span></span><br><span class="line"><span class="keyword">const</span> initPromise_3 = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (value % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'發生錯誤'</span>; <span class="comment">// error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">initPromise_3(<span class="number">7</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success： '</span> + value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error： '</span> + error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>在上面的三種方法中，方法三會直接 <code>throw</code> 出意外，造成程式中斷，與 Promise 建構式相比，<strong>Promise 靜態方法對於錯誤的處理方式是不同的</strong>，如果你的函式處理較為複雜時，你在回傳 <code>Promise.reject</code> 或 <code>Promise.resolve</code> 前發生意外，是完全無法控制的。</p><p>結論是 <code>Promise.reject</code> 或 <code>Promise.resolve</code> 只適用於單純的純入物件、值、或外部的 thenable 物件，如果你要把一整段程式碼或函式轉為 Promise 物件，不要使用這兩個靜態方法，要使用 Promise 建構式來產生物件才是正解。</p><h2 id="Promise-變體方法"><a href="#Promise-變體方法" class="headerlink" title="Promise 變體方法"></a>Promise 變體方法</h2><div class="note warning">Promise.all 與 Promise.race 的參數值，通常使用陣列結構作為傳入參數，而陣列中要不就是一般的值，要不就是 Promise 物件</div><p><code>Promise.all</code> 是<strong>並行運算</strong>使用的變體方法，它的語法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([...]);</span><br></pre></td></tr></table></figure><p><code>Promise.all</code> 方法會將陣列中的值並行運算，全部完成後才會接著下個 <code>thne</code> 方法，在執行時有以下幾種狀況：</p><ul><li>陣列中的索引值與執行順序無關，大家起跑線都一樣</li><li>陣列中的值如果不是 Promise 物件，會自動使用 <code>Promise.resolve</code>方法來轉換</li><li>執行過程時，陣列中只要有<strong>任何一個</strong> Promise 物件發生例外錯誤，或是有 reject 狀態的物件，會立即回傳一個 rejected 狀態的 Promise 物件。</li><li>實現完成後，接下來的 then 方法會獲取到的值為陣列值</li></ul><p>下面為 <code>Promise.all</code> 的範例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="number">98</span>;</span><br><span class="line"><span class="keyword">const</span> a3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">13</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([a1, a2, a3])</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  --- delay 1s ---</span></span><br><span class="line"><span class="comment">  [ 3, 98, 13 ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>Promise.race</code> 也是一個變體方法，它的語法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([...]);</span><br></pre></td></tr></table></figure><p><code>Promise.race</code> 方法就如同 <code>Promise.all</code>，一樣都是並行運算的變體，差別在於 <code>Promise.all</code> 指的是<strong>所有的</strong> Promise 物件都要 resolve 完成才進行下一步，而 <code>Promise.race</code> 則是<strong>任何一個</strong> Promise 物件 resolve 完成就進行下一步。用 <strong>race(競賽)</strong>這個字詞是在比喻就像賽跑一樣，只要有任何一個參賽者到達終點就結束了，當然它的回傳值也只會是那個優勝者而已。</p><p><code>Promise.race</code> 的規則與 <code>Promise.all</code> 相同，只不過實現的話，下一步的 <code>then</code> 方法只會獲取最快實現的那個值，範例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = <span class="function">(<span class="params">name, timeout</span>) =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">'優勝者：'</span> + name + <span class="string">'  時間：'</span> + timeout / <span class="number">1000</span> + <span class="string">'s'</span>);</span><br><span class="line">    &#125;, timeout);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([test(<span class="string">'大熊'</span>, <span class="number">2000</span>), test(<span class="string">'胖虎'</span>, <span class="number">3000</span>), test(<span class="string">'靜香'</span>, <span class="number">1000</span>)]).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response); <span class="comment">// 優勝者：靜香  時間：1s</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="改寫-Callback-函式"><a href="#改寫-Callback-函式" class="headerlink" title="改寫 Callback 函式"></a>改寫 Callback 函式</h2><p>在前面我們有強調使用 callback 容易造成 callback hell，這一次我們使用 Promise 來改寫 callback 的範例吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> async_api = <span class="function">(<span class="params">name, timeout</span>) =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name || timeout === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(name + <span class="string">' end'</span>), timeout);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      reject(name + <span class="string">'error'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">async_api(<span class="string">'async_api1'</span>, <span class="number">1000</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">    <span class="keyword">return</span> async_api(<span class="string">'async_api2'</span>, <span class="number">2000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">    <span class="keyword">return</span> async_api(<span class="string">'async_api3'</span>, <span class="number">3000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  --- delay 1s ---</span></span><br><span class="line"><span class="comment">  async_api1 end</span></span><br><span class="line"><span class="comment">  --- delay 2s ---</span></span><br><span class="line"><span class="comment">  async_api2 end</span></span><br><span class="line"><span class="comment">  --- delay 3s ---</span></span><br><span class="line"><span class="comment">  async_api3 end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>很明顯的，使用 Promise 大幅提高了結構的易讀性，且提供統一的流程管理，光是這幾點，就值得你花時間學習它了，Promise 的應用場景一定不只有這些，非同步對於 JavaScript 來說，幾乎是必備的條件，而 Promise 物件的出現，就是用來改善傳統非同步情境可能會發生的問題，好東西，不學嗎？</p>]]></content>
    
    <summary type="html">
    
      非同步處理一直以來都是 JavaScript 開發者很常遇到的情境，在之前，我們很常使用 callback 去完成任務，當結構變得複雜時，容易形成所謂的 callback hell，造成程式碼難以維護；在 ES6 版本中，新增了 Promise 物件，它能夠將非同步流程包裝成簡潔的結構，並提供統一的錯誤處理機制，解決了傳統 callback hell 的問題。此篇將會解析 Promise 的處理流程與相關方法。
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://awdr74100.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://awdr74100.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://awdr74100.github.io/tags/ES6/"/>
    
      <category term="w3HexSchool" scheme="https://awdr74100.github.io/tags/w3HexSchool/"/>
    
      <category term="Promise" scheme="https://awdr74100.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>Web APIs - 使用原生 Fetch API 獲取遠端資料</title>
    <link href="https://awdr74100.github.io/2020-08-08-webapis-fetch/"/>
    <id>https://awdr74100.github.io/2020-08-08-webapis-fetch/</id>
    <published>2020-08-08T01:36:48.000Z</published>
    <updated>2020-08-09T15:50:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大多人開發項目都是使用 Axios 或者 jQuery 庫的 $.ajax 方法來完成 HTTP 請求行為，如果要使用 JS 原生的方法，只有 XMLHttpRequest 可以選擇，但程序繁瑣、順序混亂等問題，我相信大家因該都有遇到過，這次來記錄一下 ES6 新增的原生方法 Fetch API。</p><h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul><li>傳統 XMLHttpRequest 方法</li><li>Fetch 基本用法</li><li>ReadableStream 解析方法</li><li>Fetch POST 行為</li></ul><h2 id="傳統-XMLHttpRequest-方法"><a href="#傳統-XMLHttpRequest-方法" class="headerlink" title="傳統 XMLHttpRequest 方法"></a>傳統 XMLHttpRequest 方法</h2><img src="https://i.imgur.com/Iz6mnGL.png" alt="XMLHttpRequest行為"><p>一般人對於 AJAX 行為的理解，差不多都是從封裝過後的方法去做學習，原因很簡單，容易理解、操作方便，但有時我們不想要套用框架，需要使用原生的寫法，我們就只能選擇 <code>XMLHttpRequest</code> 這一個物件去做使用，他是 JS 原生對於 HTTP 請求的操作物件，範例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宣告一個 xhr 物件</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 請求方式、請求網址、處理方式( true：非同步處理 , false：同步處理 ))</span></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'https://randomuser.me/api/'</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 送出請求</span></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 請求成功觸發</span></span><br><span class="line">xhr.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(xhr.response);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面是一個 GET 請求範例，很明顯的程序與封裝過後的方法相比較為繁瑣，且令人詬病的點在於<strong>每一個請求都必須新增一個請求的實體</strong>，一個網站通常也不會只有一個請求，整個建構下來，會變得非常混亂，通常不太建議使用這個方法做請求。</p><h2 id="Fetch-基本用法"><a href="#Fetch-基本用法" class="headerlink" title="Fetch 基本用法"></a>Fetch 基本用法</h2><p><code>Fetch()</code> 是 ES6 新增的 HTTP 請求方法，基於 Promise 所設計，他讓接口更簡單、簡潔、同時也避免了回調的複雜性，主要就是用來取代傳統的 <code>XMLHttpRequest</code> 方法，下面是一個基本的範例：</p><ul><li><code>json()</code> 解析為 JSON 物件</li><li><code>then()</code> 觸發下一步操作</li><li><code>catch()</code> 錯誤時觸發</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'https://randomuser.me/api/'</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 操作 response 屬性、方法</span></span><br><span class="line">    <span class="keyword">return</span> response.json();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 實際存取到資料</span></span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 錯誤回應</span></span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面是基於 GET 請求所撰寫的範例，很明顯的，更為簡單、直接，且利用 Promise 的特性，一步一步的使用 then 操作回應，關於 response 可應用的屬性、方法，將在下面做介紹。</p><h2 id="ReadableStream-解析方法"><a href="#ReadableStream-解析方法" class="headerlink" title="ReadableStream 解析方法"></a>ReadableStream 解析方法</h2><p>在 <code>Fetch()</code> 回應的資料中，我們可以使用相關的屬性、方法傳遞給下一步做使用，但要注意的是我們<strong>不能直接在回應資料中做資料取用</strong>，因為 Fetch 回應的資料，實際上是一個物件實例，我們所要做的，就是針對這一個物件實例中的 <strong>ReadableStream</strong> 做解析，下面是相關的解析方法：</p><ul><li><code>json()</code>：解析為 JSON 物件</li><li><code>text()</code>：解析為 String 字串</li><li><code>blob()</code>：解析為 Blob 內容</li><li><code>arrayBuffer()</code>：解析為 ArrayBuffer 內容</li><li><code>formData()</code>：解析為 formData 內容</li><li><code>clone()</code>：複製實例物件</li></ul><h2 id="Fetch-POST-行為"><a href="#Fetch-POST-行為" class="headerlink" title="Fetch POST 行為"></a>Fetch POST 行為</h2><p>在上面都是使用 GET 行為當作範例，不需設定 method，因為 GET 為預設行為，如需使用其他行為，只需要<strong>加入相對應屬性並包裝成物件</strong>即可，如下範例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'https://vue-course-api.hexschool.io/admin/signin'</span>, &#123;</span><br><span class="line">  <span class="comment">// 設定為 POST 請求</span></span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  <span class="comment">// 在 headers 加入 json 格式</span></span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 傳送內容須轉換為字串</span></span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    username: <span class="string">'test@gmail.com'</span>,</span><br><span class="line">    password: <span class="string">'66666666'</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> response.json();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>這次使用六角學院的登入帳號 API 做 POST 行為測試，Fetch 畢竟還是未經過封裝的原生行為，需在傳送內容中做一些調整，這邊要注意的是<strong>傳送內容需轉換為字串</strong>，不然會造成解析錯誤。</p><h2 id="使用感想"><a href="#使用感想" class="headerlink" title="使用感想"></a>使用感想</h2><p>針對 Fetch API 我認為的確有效改善傳統 <code>XMLHttpRequest</code> 為人所詬病的問題，<strong>寫起來乾淨又好維護</strong>，<strong>且基於 Promise 設計</strong>，<strong>支援 async/await</strong>，確實非常強大，不過對於開發稍有規模的專案來講，我還是會以 Axios 來做使用，畢竟支援 Promise 且操作方便，核心是以 xhr 物件做封裝，也不需考慮支援性問題；<strong>Fetch API 畢竟還是底層方法</strong>，操作過程還是得<strong>自己編寫各式各樣的封裝和異常處理</strong>，<strong>並非開箱即用</strong>，不過我認為，他絕對是推動前端 HTTP 行為的潛力股，時間問題而已。</p>]]></content>
    
    <summary type="html">
    
      大多人開發項目都是使用 Axios 或者 jQuery 庫的 $.ajax 方法來完成 HTTP 請求行為，如果要使用 JS 原生的方法，只有 XMLHttpRequest 可以選擇，但程序繁瑣、順序混亂等問題，我相信大家因該都有遇到過，這次來記錄一下 ES6 新增的原生方法 Fetch API。
    
    </summary>
    
    
      <category term="Web APIs" scheme="https://awdr74100.github.io/categories/Web-APIs/"/>
    
    
      <category term="JavaScript" scheme="https://awdr74100.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://awdr74100.github.io/tags/ES6/"/>
    
      <category term="w3HexSchool" scheme="https://awdr74100.github.io/tags/w3HexSchool/"/>
    
      <category term="Web APIs" scheme="https://awdr74100.github.io/tags/Web-APIs/"/>
    
      <category term="AJAX" scheme="https://awdr74100.github.io/tags/AJAX/"/>
    
  </entry>
  
  <entry>
    <title>導入 ESLint 控管程式碼品質</title>
    <link href="https://awdr74100.github.io/2020-08-01-tools-eslint/"/>
    <id>https://awdr74100.github.io/2020-08-01-tools-eslint/</id>
    <published>2020-08-01T04:36:42.000Z</published>
    <updated>2020-08-02T14:13:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>初期在寫 JavaScript 代碼時，都是以學習心態去完成目標，程式碼的品質較為不穩定，但到了業界，通常需要配合團隊開發專案規範，其中也包含了代碼規範，ESLint 就是 JavaScript 的代碼規範工具，他可以讓你維持一定的程式碼品質，敲代碼的同時也可以進行觀念的修正。</p><h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul><li>什麼是 Linter ？</li><li>ESLint 簡介</li><li>ESLint 安裝及使用</li><li>ESLint 配置規則</li></ul><h2 id="什麼是-Linter-？"><a href="#什麼是-Linter-？" class="headerlink" title="什麼是 Linter ？"></a>什麼是 Linter ？</h2><img src="https://i.imgur.com/exYojAl.jpg"><p>每個開發者都有自己的編碼習慣，最常見的操作為：</p><ul><li>編寫代碼時一行不會超過 80 個字串，簡潔明瞭</li><li>代碼結尾必須加分號，看起來比較拘謹</li><li>盡量使用 ES6 宣告變數，以 <code>let</code>、<code>const</code> 取代 <code>var</code></li><li>tab-width 限制為 2</li></ul><p>也因為這種習慣，當進行多人開發時，會造成諸多的不順，所以通常團隊間會規範一個共同標準，每一個開發者都必須遵守，但凡事都有疏忽的時候，且一個專案大小隨便都有上萬行代碼，你難道要一行一行的檢查？<strong>凡是重複性的工作，都因該被製作成工具來節省時間成本</strong>，而這個工具通常需要具備以下兩點：</p><ul><li>提供編碼規範，可自行訂製規則最好</li><li>提供自動檢測代碼程序，發現問題時，應提示用戶做處理</li></ul><p>Linter 就是負責處理此問題的工具，利用<strong>靜態代碼分析</strong>即可完成檢測，不需要進行任何 Script 動作。</p><h2 id="ESLint-簡介"><a href="#ESLint-簡介" class="headerlink" title="ESLint 簡介"></a>ESLint 簡介</h2><img src="https://i.imgur.com/tIU0AEj.png" alt="ESLint" width="70%"><p>ESLint 是眾多 JavaScript Linter 的其中一個，其優秀的支援性以及可自定義規則等功能，使他漸漸成為市場主流，其他包含 JSLint、JSHint、JSCS 等等，這些也都屬於 JS Linter，通常 Linter 大都具備以下功能：</p><ul><li>編碼規範：使用單引號還是雙引號、需不需要加分號、縮排使用 space 或 tab</li><li>變數宣告：禁止未宣告變數直接取用，以塊級作用域而非函式作用域下宣告變數</li><li>無效程序：已宣告卻未使用的變數、函式，建議刪除</li><li>代碼測試：<code>alert</code>、<code>console</code> 行為，建議刪除</li></ul><h2 id="ESLint-安裝及使用"><a href="#ESLint-安裝及使用" class="headerlink" title="ESLint 安裝及使用"></a>ESLint 安裝及使用</h2><blockquote><p>安裝環境：<a href="https://nodejs.org/en/" target="_blank" rel="external nofollow noopener noreferrer">Node.js</a> &gt;= 6.14、<a href="https://nodejs.org/en/" target="_blank" rel="external nofollow noopener noreferrer">npm</a> 3+<br>相關插件：<a href="https://github.com/Microsoft/vscode-eslint" target="_blank" rel="external nofollow noopener noreferrer">ESLint</a> for VSCode</p></blockquote><p>使用 npm 全域安裝 ESLint：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install eslint -g</span></span><br></pre></td></tr></table></figure><p>使用 VSCode 安裝 ESLint 擴展：</p><ul><li>切換至 Extensions，搜尋並安裝 ESLint</li></ul><p>專案目錄建立 package.json：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm init</span></span><br></pre></td></tr></table></figure><p>初始化 ESLint 項目：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> eslint --init</span></span><br></pre></td></tr></table></figure><img src="https://i.imgur.com/p8jgDqT.gif" alt="eslint初始化" width="100%"><p>自動檢測代碼並提示：</p><img src="https://i.imgur.com/gRwK5AV.jpg" alt="eslint插件"><p>根據提示修改代碼：</p><p>安裝步驟大致上就到這邊，接下來就是依造他所發現的錯誤，做出修正，在初期錯誤可能會有點多，不過沒關係，大多問題都有提示，不會說太困難。常見提示為：</p><ul><li><code>Unary operator &#39;++&#39; used</code><!-- ：建議使用 i += 1 取代 i++ --></li><li><code>Expected &#39;===&#39; and instead saw &#39;==&#39;</code><!-- ：建議使用 === 取代 == --></li><li><code>&#39;object&#39; is never reassigned. Use &#39;const&#39; instead</code><!-- ：不會更動的變數請用 const 宣告 --></li><li><code>&#39;fun&#39; was used before it was defined</code></li></ul><h2 id="ESLint-配置規則"><a href="#ESLint-配置規則" class="headerlink" title="ESLint 配置規則"></a>ESLint 配置規則</h2><blockquote><p>配置檔案：/.eslintrc.js<br>可配置規則：<a href="https://eslint.org/docs/rules/" target="_blank" rel="external nofollow noopener noreferrer">規則列表</a></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  env: &#123;</span><br><span class="line">    browser: <span class="literal">true</span>,</span><br><span class="line">    es6: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  extends: [<span class="string">'airbnb-base'</span>],</span><br><span class="line">  globals: &#123;</span><br><span class="line">    Atomics: <span class="string">'readonly'</span>,</span><br><span class="line">    SharedArrayBuffer: <span class="string">'readonly'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    ecmaVersion: <span class="number">2018</span>,</span><br><span class="line">    sourceType: <span class="string">'module'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">'no-alert'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'no-console'</span>: [<span class="number">2</span>, &#123; <span class="attr">allow</span>: [<span class="string">'warn'</span>] &#125;],</span><br><span class="line">    <span class="string">'eol-last'</span>: <span class="number">2</span>,</span><br><span class="line">    eqeqeq: [<span class="number">0</span>, <span class="string">'smart'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果想要自行配置規則，可參考官方規則列表自行定義，主要有三部分須配置：</p><ul><li>規則名稱：no-alert、eqeqeq、eol-last 等等</li><li>規則狀態：0 = off、1 = warn、2 = error</li><li>可配置選項：部分規則可更改預設觸發模式，可經由此選項做更改</li></ul>]]></content>
    
    <summary type="html">
    
      初期在寫 JavaScript 代碼時，都是以學習心態去完成目標，程式碼的品質較為不穩定，但到了業界，通常需要配合團隊開發專案規範，其中也包含了代碼規範，ESLint 就是 JavaScript 的代碼規範工具，他可以讓你維持一定的程式碼品質，敲代碼的同時也可以進行觀念的修正。
    
    </summary>
    
    
      <category term="Tools" scheme="https://awdr74100.github.io/categories/Tools/"/>
    
    
      <category term="JavaScript" scheme="https://awdr74100.github.io/tags/JavaScript/"/>
    
      <category term="w3HexSchool" scheme="https://awdr74100.github.io/tags/w3HexSchool/"/>
    
      <category term="ESLint" scheme="https://awdr74100.github.io/tags/ESLint/"/>
    
  </entry>
  
  <entry>
    <title>Webpack 前端打包工具 - 使用 image-webpack-loader 壓縮圖片</title>
    <link href="https://awdr74100.github.io/2020-07-24-webpack-imagewebpackloader/"/>
    <id>https://awdr74100.github.io/2020-07-24-webpack-imagewebpackloader/</id>
    <published>2020-07-23T16:13:27.000Z</published>
    <updated>2020-07-24T16:01:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Gulp 可使用 gulp-imagemin 套件來壓縮 PNG、JPG 等類型圖片，想當然的在 Webpack 也有類似的套件可使用，名為 image-webpack-loader，一樣都是基於 imagemin 所設計，兩者在使用上幾乎沒有差別，一般人可能聽過的是 imagemin-webpack-plugin，這是屬於 Plugin 類型的套件，代表是在生成資源時才進行壓縮，無法像 image-webpack-loader 一樣後續再交由 url-loader 進行處理，我自己是比較喜歡 image-webpack-loader 就是了。此篇將介紹如何使用 image-webpack-loader 壓縮各種類型的圖片。</p><h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul><li>image-webpack-loader 安裝</li><li>image-webpack-loader 基本使用</li><li>image-webpack-loader 可傳遞選項</li></ul><h2 id="image-webpack-loader-安裝"><a href="#image-webpack-loader-安裝" class="headerlink" title="image-webpack-loader 安裝"></a>image-webpack-loader 安裝</h2><blockquote><p>套件連結：<a href="https://github.com/tcoopman/image-webpack-loader" target="_blank" rel="external nofollow noopener noreferrer">image-webpack-loader</a></p></blockquote><p>主要的套件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install image-webpack-loader -D</span><br></pre></td></tr></table></figure><p>過程會使用到的套件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install file-loader url-loader css-loader mini-css-extract-plugin html-webpack-plugin cross-env -D</span><br></pre></td></tr></table></figure><p>package.json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"cross-env"</span>: <span class="string">"^7.0.2"</span>,</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^3.6.0"</span>,</span><br><span class="line">    <span class="attr">"file-loader"</span>: <span class="string">"^6.0.0"</span>,</span><br><span class="line">    <span class="attr">"html-webpack-plugin"</span>: <span class="string">"^4.3.0"</span>,</span><br><span class="line">    <span class="attr">"image-webpack-loader"</span>: <span class="string">"^6.0.0"</span>,</span><br><span class="line">    <span class="attr">"mini-css-extract-plugin"</span>: <span class="string">"^0.9.0"</span>,</span><br><span class="line">    <span class="attr">"url-loader"</span>: <span class="string">"^4.1.0"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.43.0"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.12"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>image-webpack-loader 只是負責將圖片給壓縮，實際上搬運圖片的這個動作還是得交由 file-loader 進行，當圖片壓縮後到達了一定大小，我們可改交由 url-loader 將其轉換為 Base64 型態，為了模擬實際開發上的情境，請將上面列出的套件都進行安裝。</p><h2 id="image-webpack-loader-基本使用"><a href="#image-webpack-loader-基本使用" class="headerlink" title="image-webpack-loader 基本使用"></a>image-webpack-loader 基本使用</h2><p>初始專案結構：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.css      # CSS 主檔案</span><br><span class="line">│   │</span><br><span class="line">│   └─── img&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── self.jpg     # JPG 圖檔</span><br><span class="line">│   │</span><br><span class="line">│   ├─── index.html       # HTML 主檔案</span><br><span class="line">│   └─── main.js          # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── webpack.config.js    # Webpack 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure><p>撰寫 CSS 範例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.image</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-position</span>: center center;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: contain;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'~@/self.jpg'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至 <code>./src/index.html</code> 撰寫 HTML 模板範例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"image"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>這邊我們採用 CSS 的方式來載入圖片，這樣就不用在 entry 入口處另外載入圖片了。</p><p>配置 <code>webpack.config.js</code> 檔案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: process.env.NODE_ENV,</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/[name].js'</span>,</span><br><span class="line">    publicPath: <span class="string">'/'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'@'</span>: path.resolve(__dirname, <span class="string">'src/img'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg|webp)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: <span class="number">8192</span>,</span><br><span class="line">              name: <span class="string">'img/[name].[ext]'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 配置 image-webpack-loader (第一步)</span></span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">// 只在 production 環境啟用壓縮 (第二步)</span></span><br><span class="line">              disable: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="literal">false</span> : <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/[name].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>壓縮圖片非常消耗時間，這邊我們選擇在 <code>production</code> 環境才啟用壓縮，<code>development</code> 環境則是不啟用壓縮，image-webpack-loader 本身支援 PNG、JPEG、GIF、SVG 和 WebP 圖片壓縮，算是支援大部分圖片類型了，這邊我們就先採預設的壓縮設定，下面會在介紹如何針對各類型圖片客製壓縮設定。</p><p>entry 入口處 (<code>src/main.js</code>) 引入 CSS 檔案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./css/all.css'</span>; <span class="comment">// 使用 ESM 方式引入</span></span><br></pre></td></tr></table></figure><p>至 <code>package.json</code> 新增編譯指令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"cross-env NODE_ENV=development webpack"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"cross-env NODE_ENV=production webpack"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊我們使用到了 cross-env 套件來解決設置 <code>NODE_ENV</code> 環境變數在跨平台可能會產生的問題。</p><p>執行編譯指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>檢查圖片是否正確被載入：</p><p><img src="https://i.imgur.com/hkApN1r.png" alt="檢查圖片是否正確被載入"></p><p>由於我們設定了 <code>publicPath</code> 為根目錄，如果單純打開 <code>./dist/index.html</code> 會沒辦法顯示網頁，這邊可以隨便開啟一個 <code>localhost</code> 用以模擬伺服器環境，或者使用 webpack-dev-server 來協助開發，接著來看這張圖片是否有被成功壓縮。</p><p>原圖：</p><p><img src="https://i.imgur.com/X7gOnEd.png" alt="原圖"></p><p>經過壓縮：</p><p><img src="https://i.imgur.com/uTORkdR.png" alt="經過壓縮"></p><p>可以發現壓縮後的圖檔幾乎看不出有任何失真的狀況，而圖檔大小卻整整縮小了 50% 之多，從原有的 153.1KB 縮減為 65.9KB，可以說是相當的有感，以後就再也不需要去使用是 <a href="https://tinypng.com/" target="_blank" rel="external nofollow noopener noreferrer">tinypng</a> 等類似的服務囉。</p><h2 id="image-webpack-loader-可傳遞選項"><a href="#image-webpack-loader-可傳遞選項" class="headerlink" title="image-webpack-loader 可傳遞選項"></a>image-webpack-loader 可傳遞選項</h2><p>image-webpack-loader 除了基本的 <code>disable</code> 與舊版 Webpack 才需使用的 <code>bypassOnDebug</code> 選項外，其餘可傳遞選項均為各類型圖片的優化器，可參考以下：</p><ul><li><a href="https://github.com/imagemin/imagemin-mozjpeg" target="_blank" rel="external nofollow noopener noreferrer">mozjpeg</a>：JPEG 圖片優化器</li><li><a href="https://github.com/imagemin/imagemin-optipng" target="_blank" rel="external nofollow noopener noreferrer">optipng</a>：PNG 圖片優化器</li><li><a href="https://github.com/imagemin/imagemin-pngquant" target="_blank" rel="external nofollow noopener noreferrer">pngquant</a>：PNG 圖片優化器 (推薦)</li><li><a href="https://github.com/imagemin/imagemin-svgo" target="_blank" rel="external nofollow noopener noreferrer">svgo</a>：SVG 圖片優化器</li><li><a href="https://github.com/imagemin/imagemin-gifsicle" target="_blank" rel="external nofollow noopener noreferrer">gifsicle</a>：GIF 圖片優化器</li><li><a href="https://github.com/imagemin/imagemin-webp" target="_blank" rel="external nofollow noopener noreferrer">webp</a>：WebP 圖片優化器 (預設不啟用)</li></ul><p>所有圖片優化器均為 image-webpack-loader 的相依套件，代表無須進行任何下載，配置即可使用，關於配置的方法可參考以下範例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg|webp)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="comment">// url-loader...</span></span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              disable: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="literal">false</span> : <span class="literal">true</span>,</span><br><span class="line">              mozjpeg: &#123;</span><br><span class="line">                progressive: <span class="literal">true</span>,</span><br><span class="line">                quality: <span class="number">65</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              optipng: &#123;</span><br><span class="line">                enabled: <span class="literal">false</span>, <span class="comment">// 表示不啟用這一個圖片優化器</span></span><br><span class="line">              &#125;,</span><br><span class="line">              pngquant: &#123;</span><br><span class="line">                quality: [<span class="number">0.65</span>, <span class="number">0.9</span>],</span><br><span class="line">                speed: <span class="number">4</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              gifsicle: &#123;</span><br><span class="line">                interlaced: <span class="literal">false</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              webp: &#123;</span><br><span class="line">                quality: <span class="number">75</span>, <span class="comment">// 配置選項表示啟用 WebP 優化器</span></span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      在 Gulp 可使用 gulp-imagemin 套件來壓縮 PNG、JPG 等類型圖片，想當然的在 Webpack 也有類似的套件可使用，名為 image-webpack-loader，一樣都是基於 imagemin 所設計，兩者在使用上幾乎沒有差別，一般人可能聽過的是 imagemin-webpack-plugin，這是屬於 Plugin 類型的套件，代表是在生成資源時才進行壓縮，無法像 image-webpack-loader 一樣後續再交由 url-loader 進行處理，我自己是比較喜歡 image-webpack-loader 就是了。此篇將介紹如何使用 image-webpack-loader 壓縮各種類型的圖片。
    
    </summary>
    
    
      <category term="Webpack" scheme="https://awdr74100.github.io/categories/Webpack/"/>
    
    
      <category term="Node.js" scheme="https://awdr74100.github.io/tags/Node-js/"/>
    
      <category term="w3HexSchool" scheme="https://awdr74100.github.io/tags/w3HexSchool/"/>
    
      <category term="Webpack" scheme="https://awdr74100.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack 前端打包工具 - 使用 prerender-spa-plugin 預渲染單頁應用</title>
    <link href="https://awdr74100.github.io/2020-07-13-webpack-prerenderspaplugin/"/>
    <id>https://awdr74100.github.io/2020-07-13-webpack-prerenderspaplugin/</id>
    <published>2020-07-12T16:14:38.000Z</published>
    <updated>2020-07-13T16:21:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通常我們在將一個專案改為目前流行的 SPA (Single-page application) 時，最大的考慮因素肯定是 SEO 是否重要，畢竟在 SPA 的世界裡幾乎沒有 SEO 的可能，對於爬蟲來說是無法爬取 JavaScript 檔案內容的，這也就印證 SPA 不適合用在強調 SEO 的專案上面，有些人可能會選擇使用像是 Nuxt.js、Next.js 等 SSR 框架，這確實是個解決辦法，但對於小型項目來說更好的做法是使用 Prerendering 方式，過程也相對簡單。此篇將介紹如何使用 prerender-spa-plugin 將我們的 SPA 添加預渲染。</p><h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul><li>prerender-spa-plugin 安裝</li><li>prerender-spa-plugin 基本使用</li><li>prerender-spa-plugin 可傳遞選項</li></ul><h2 id="prerender-spa-plugin-安裝"><a href="#prerender-spa-plugin-安裝" class="headerlink" title="prerender-spa-plugin 安裝"></a>prerender-spa-plugin 安裝</h2><blockquote><p>套件連結：<a href="https://www.npmjs.com/package/prerender-spa-plugin" target="_blank" rel="external nofollow noopener noreferrer">prerender-spa-plugin</a></p></blockquote><p>主要的套件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install prerender-spa-plugin -D</span><br></pre></td></tr></table></figure><p>prerender-sap-plugin 是 Vue 核心團隊成員開發出的預渲染插件，其內部運用了 Puppeteer 套件在 Webpack 構建的最後階段爬取指定路由的內容，之後再將這些內容實際渲染成獨立的 HTML 文件，並建立路由對應的目錄，這邊我們不需要下載 puppeteer，此為相依套件，關於 SPA 環境的搭建我們選擇使用 Vue CLI 來完成，如果你想使用 vue-loader 手動搭建出來，可參考我之前寫的 <a href="https://awdr74100.github.io/2020-04-13-webpack-vueloader/">文章</a>。</p><h2 id="prerender-spa-plugin-基本使用"><a href="#prerender-spa-plugin-基本使用" class="headerlink" title="prerender-spa-plugin 基本使用"></a>prerender-spa-plugin 基本使用</h2><p>使用 Vue CLI 快速搭建 SPA 環境：</p><p><img src="https://i.imgur.com/MI86Ycm.png" alt="Vue CLI 選擇 history 模式"></p><p>這邊要注意，通常我們為了求方便都會將 Vue Router 設為 hash 模式，也就是使用 <code>#</code> 來辨識不同的路由，但在 prerender-spa-plugin 中此模式是不被允許的，這樣會發生對應路由生成的 <code>index.html</code> 文件內容都一樣的問題，請將其改為 history 模式，這也是我推薦的模式，雖然還得再主機那邊設定重定向，但你不覺得這樣網址漂亮許多嗎？接著來看下一步：</p><p>新增 <code>vue.config.js</code> 檔案：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> prerender-demo/</span><br><span class="line"> │</span><br><span class="line"><span class="addition">+└─── vue.config.js</span></span><br></pre></td></tr></table></figure><p>對於某部分的人來講，Vue CLI v3+ 的配置可說是相當的友善，官方將 Vue CLI v2 存在的 Webpack 配置檔全部整合到了 package 內，我們只需要依造官方的配置文件撰寫對應的選項即可，但這對我來說就顯得有些麻煩，不能以傳統的 Webpack 配置方式進行配置，反而還得向官方文件查詢，這邊要新增 Plugin 必須使用以下方式撰寫：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack(config) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">      config.plugins.push();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這邊的 <code>config</code> 指向的是 Wbpack 配置檔本身，由於 Plugins 屬性是以陣列的方式存在，如果我們要將額外的 plugin 結合到現有的 plugins 中，自然就必須使用陣列的方式進行，這邊我習慣使用 <code>push</code> 方法新增至現有的 plugins 中，接著來看如何配置 prerender-spa-plugin：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 載入 prerender-spa-plugin (第一步)</span></span><br><span class="line"><span class="keyword">const</span> PrerenderSPAPlugin = <span class="built_in">require</span>(<span class="string">'prerender-spa-plugin'</span>);</span><br><span class="line"><span class="comment">// 載入 PuppeteerRenderer (第二步)</span></span><br><span class="line"><span class="keyword">const</span> Renderer = PrerenderSPAPlugin.PuppeteerRenderer;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack(config) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">      config.plugins.push(</span><br><span class="line">        <span class="comment">// 創建實例 (第三步)</span></span><br><span class="line">        <span class="keyword">new</span> PrerenderSPAPlugin(&#123;</span><br><span class="line">          staticDir: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">          routes: [<span class="string">'/'</span>, <span class="string">'/about'</span>],</span><br><span class="line">          renderer: <span class="keyword">new</span> Renderer(&#123;</span><br><span class="line">            renderAfterDocumentEvent: <span class="string">'render-event'</span>,</span><br><span class="line">          &#125;),</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>配置 prerender-spa-plugin 的關鍵在於 <code>routes</code> 與 <code>renderer</code> 選項，這邊的 <code>routes</code> 傳遞的就是需預渲染的路由路徑，而 <code>renderer</code> 傳遞的對象為所使用的渲染器，在 <code>v3.4.0</code> 預設使用 renderer-puppeteer，接著我們需配置 <code>renderAfterDocumentEvent</code> 選項用以告知預渲染觸發的事件名稱，都完成後再來就是至 Vue 的實例中去觸發這個事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="built_in">document</span>.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">'render-event'</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure><p>這邊我們選擇在 <code>mounted</code> 這個 hook 觸發事件，切記一定要加入觸發的時機，不然會卡在 puppeteer 等待觸發的環節，到這邊我們就完成配置了。</p><p>執行編譯指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>檢查傳遞的頁面路徑是否成功被預渲染：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dist&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── about</span><br><span class="line">│   │</span><br><span class="line">│   └─── index.html</span><br><span class="line">│</span><br><span class="line">├─── ... other</span><br><span class="line">│</span><br><span class="line">└─── index.html</span><br></pre></td></tr></table></figure><p>從結果可以看出我們傳入的路由路徑已經成功被預渲染成對應的 <code>index.html</code> 檔案了，是不是很簡單？其實也就只是告訴 puppeteer 需預渲染的頁面路由而已，此時如果你開啟一個 localhost 服務，會發現操作上與傳統 SPA 在切換模組毫無差別，畢竟實際在運作的還是 JavaScript，這些預渲染形成的頁面最終 <code>#app</code> 節點下的內容還是會被覆蓋掉。</p><p>這邊要強調，Prerender 只適合用在小型的專案或是純靜態頁面的 SPA 專案上面，如果你打開這些預渲染的 HTML 檔案，會發現他只是將對應路由下的 DOM 元素以及內容給添加上去而已，這時候可能就有人問了，動態加載的內容也能夠實現嗎？答案是不行，你可以嘗試操作 AJAX 行為，並將獲取的內容添加到 DOM 元素看看，就算你把行為放在 <code>created</code> 這個 hook 去跑還是沒辦法成功，預渲染最後只會添加這一個 DOM 元素，並不會添加內容。</p><p>還有一點是關於動態路由預渲染的問題，就像是 <code>/user/:id</code> 這樣的路由路徑，我們很常使用此方式來渲染對應的內容，這點在 Prerender 同樣也行不通，畢竟預渲染的實現方法就是獲取已存在的元素對象，既然元素狀態都處於未知，爬蟲自然也就爬取不到對應內容。</p><h2 id="prerender-spa-plugin-可傳遞選項"><a href="#prerender-spa-plugin-可傳遞選項" class="headerlink" title="prerender-spa-plugin 可傳遞選項"></a>prerender-spa-plugin 可傳遞選項</h2><p>可參考 <a href="https://www.npmjs.com/package/prerender-spa-plugin#plugin-options" target="_blank" rel="external nofollow noopener noreferrer">prerender-spa-plugin Options</a> 可傳遞參數列表，以下為常用的參數配置：</p><ul><li><p>staticDir：<code>String</code><br>預渲染輸出的位置，默認為 <code>none</code></p></li><li><p>minify：<code>Object</code><br>使用 <a href="https://github.com/kangax/html-minifier#options-quick-reference" target="_blank" rel="external nofollow noopener noreferrer">html-minifier</a> 最小化生成的 HTML，默認為 <code>none</code></p></li><li><p>headless：<code>Boolean</code><br>以 Headless 模式運行瀏覽器，此為 <a href="https://zhaoqize.github.io/puppeteer-api-zh_CN/#?product=Puppeteer&version=v1.17.0&show=api-puppeteerlaunchoptions" target="_blank" rel="external nofollow noopener noreferrer">puppeteer.launch</a> 的可傳遞選項，默認為 <code>true</code></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> PrerenderSPAPlugin = <span class="built_in">require</span>(<span class="string">'prerender-spa-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> Renderer = PrerenderSPAPlugin.PuppeteerRenderer;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack(config) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">      config.plugins.push(</span><br><span class="line">        <span class="keyword">new</span> PrerenderSPAPlugin(&#123;</span><br><span class="line">          staticDir: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">          routes: [<span class="string">'/'</span>, <span class="string">'/about'</span>, <span class="string">'/admin/addProduct'</span>],</span><br><span class="line">          minify: &#123;</span><br><span class="line">            collapseBooleanAttributes: <span class="literal">true</span>,</span><br><span class="line">            collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">            decodeEntities: <span class="literal">true</span>,</span><br><span class="line">            keepClosingSlash: <span class="literal">true</span>,</span><br><span class="line">            sortAttributes: <span class="literal">true</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          renderer: <span class="keyword">new</span> Renderer(&#123;</span><br><span class="line">            renderAfterDocumentEvent: <span class="string">'render-event'</span>,</span><br><span class="line">            headless: <span class="literal">false</span>,</span><br><span class="line">          &#125;),</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      通常我們在將一個專案改為目前流行的 SPA (Single-page application) 時，最大的考慮因素肯定是 SEO 是否重要，畢竟在 SPA 的世界裡幾乎沒有 SEO 的可能，對於爬蟲來說是無法爬取 JavaScript 檔案內容的，這也就印證 SPA 不適合用在強調 SEO 的專案上面，有些人可能會選擇使用像是 Nuxt.js、Next.js 等 SSR 框架，這確實是個解決辦法，但對於小型項目來說更好的做法是使用 Prerendering 方式，過程也相對簡單。此篇將介紹如何使用 prerender-spa-plugin 將我們的 SPA 添加預渲染。
    
    </summary>
    
    
      <category term="Webpack" scheme="https://awdr74100.github.io/categories/Webpack/"/>
    
    
      <category term="Node.js" scheme="https://awdr74100.github.io/tags/Node-js/"/>
    
      <category term="w3HexSchool" scheme="https://awdr74100.github.io/tags/w3HexSchool/"/>
    
      <category term="Webpack" scheme="https://awdr74100.github.io/tags/Webpack/"/>
    
      <category term="Vue.js" scheme="https://awdr74100.github.io/tags/Vue-js/"/>
    
      <category term="SEO" scheme="https://awdr74100.github.io/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>Webpack 前端打包工具 - 使用 optimize-css-assets-webpack-plugin 壓縮 CSS</title>
    <link href="https://awdr74100.github.io/2020-07-06-webpack-optimizecssassetswebpackplugin/"/>
    <id>https://awdr74100.github.io/2020-07-06-webpack-optimizecssassetswebpackplugin/</id>
    <published>2020-07-05T16:54:26.000Z</published>
    <updated>2020-07-06T16:12:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前我們有提到如何使用 html-webpack-plugin 內建的 minify 選項壓縮 HTML，而 JavaScript 則是依靠 Webpack 本身內建的 TerserWebpackPlugin 進行壓縮，唯獨少了 CSS 的方法，這次就來介紹如何使用 optimize-css-assets-webpack-plugin 壓縮我們的 CSS，其內部預設是使用 cssnano 作為編譯器，cssnano 是建立在 PostCSS 生態系統上的工具，代表我們也可使用 postcss-loader 搭配 cssnano 來達到同樣的目的及效果，如果專案本身已導入 PostCSS，建議直接搭配 cssnano 可更快的完成壓縮目的。</p><h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul><li>optimize-css-assets-webpack-plugin 安裝</li><li>optimize-css-assets-webpack-plugin 基本使用</li><li>optimize-css-assets-webpack-plugin 可傳遞選項</li><li>補充：搭配 mini-css-extract-plugin 生成 source-map 失敗</li><li>補充：使用 postcss-loader 搭配 cssnano 進行壓縮</li></ul><h2 id="optimize-css-assets-webpack-plugin-安裝"><a href="#optimize-css-assets-webpack-plugin-安裝" class="headerlink" title="optimize-css-assets-webpack-plugin 安裝"></a>optimize-css-assets-webpack-plugin 安裝</h2><blockquote><p>套件連結：<a href="https://www.npmjs.com/package/optimize-css-assets-webpack-plugin" target="_blank" rel="external nofollow noopener noreferrer">optimize-css-assets-webpack-plugin</a></p></blockquote><p>主要的套件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install optimize-css-assets-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>過程會使用到的套件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install css-loader mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure><p>package.json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^3.6.0"</span>,</span><br><span class="line">    <span class="attr">"mini-css-extract-plugin"</span>: <span class="string">"^0.9.0"</span>,</span><br><span class="line">    <span class="attr">"optimize-css-assets-webpack-plugin"</span>: <span class="string">"^5.0.3"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.43.0"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.12"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>optimize-css-assets-webpack-plugin 只是用來將 CSS 給進行壓縮，實際處理 CSS 的動作還是得交由 css-loader 和 mini-css-extract-plugin 來完成，這邊你不需要下載 cssnano，此為 optimize-css-assets-webpack-plugin 的相依套件，為了保證壓縮如預期進行，官方已經幫我們包裝好了。</p><h2 id="optimize-css-assets-webpack-plugin-基本使用"><a href="#optimize-css-assets-webpack-plugin-基本使用" class="headerlink" title="optimize-css-assets-webpack-plugin 基本使用"></a>optimize-css-assets-webpack-plugin 基本使用</h2><p>初始專案結構：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.css      # CSS 主檔案</span><br><span class="line">│   │</span><br><span class="line">│   └─── main.js          # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── webpack.config.js    # Webpack 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure><p>撰寫 CSS 範例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-danger</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置 <code>webpack.config.js</code> 檔案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="comment">// 載入 optimize-css-assets-webpack-plugin (第一步)</span></span><br><span class="line"><span class="keyword">const</span> OptimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/[name].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 創建實例 (第二步)</span></span><br><span class="line">    <span class="keyword">new</span> OptimizeCssAssetsPlugin(&#123;</span><br><span class="line">      <span class="comment">// 傳入編譯器可傳遞選項 (可選)</span></span><br><span class="line">      cssProcessorPluginOptions: &#123;</span><br><span class="line">        preset: [<span class="string">'default'</span>, &#123; <span class="attr">discardComments</span>: &#123; <span class="attr">removeAll</span>: <span class="literal">true</span> &#125; &#125;],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>optimize-css-assets-webpack-plugin 預設的編譯器為 cssnano，如果你想針對這一個編譯器傳入選項，這邊可使用 <code>cssProcessorPluginOptions</code> 屬性，方法就如同你在 <code>postcss.config.js</code> 內設置的那樣，記得格式不要寫錯，單純修改 <code>preset</code> 可採 <code>String</code> 的形式，如果想將選項傳遞進去，則須修改為 <code>Array</code> 的形式，詳細可參考 <a href="https://cssnano.co/guides/presets" target="_blank" rel="external nofollow noopener noreferrer">cssnano</a> 的說明。</p><p>entry 入口處 (<code>src/main.js</code>) 引入 CSS 檔案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./css/all.css'</span>; <span class="comment">// 使用 ESM 方式引入</span></span><br></pre></td></tr></table></figure><p>至 <code>package.json</code> 新增編譯指令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --mode development"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>執行編譯指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>檢查 <code>./dist/css/all.css</code> 是否成功被壓縮：</p><!-- prettier-ignore-start --><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span>&#123;<span class="attribute">color</span>:<span class="number">#00f</span>&#125;<span class="selector-class">.text-danger</span>&#123;<span class="attribute">color</span>:red&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p>大公告成！目前我們壓縮的配置都是參照 cssnano 中的 <code>default</code> 模式，另外還有 <code>advanced</code> 模式可做使用，這點將在下方 postcss-loader 結合 cssnano 的章節共同做介紹。</p><h2 id="optimize-css-assets-webpack-plugin-可傳遞選項"><a href="#optimize-css-assets-webpack-plugin-可傳遞選項" class="headerlink" title="optimize-css-assets-webpack-plugin 可傳遞選項"></a>optimize-css-assets-webpack-plugin 可傳遞選項</h2><p>可參考 <a href="https://www.npmjs.com/package/optimize-css-assets-webpack-plugin#configuration" target="_blank" rel="external nofollow noopener noreferrer">optimize-css-assets-webpack-plugin Options</a> 可傳遞參數列表，以下為常用的參數配置：</p><ul><li><p>assetNameRegExp：<code>RegExp</code><br>指示應壓縮的資源，默認為 <code>/\.css$/g</code></p></li><li><p>cssProcessor：<code>Compiler</code><br>用於處理壓縮的編譯器，默認為 <code>cssnano</code></p></li><li><p>cssProcessorOptions：<code>Object</code><br>將選項傳遞給 cssProcessor 的接口，默認為 <code>{}</code></p></li><li><p>cssProcessorPluginOptions：<code>Object</code><br>將選項傳遞給 cssProcessor 中 plugin 的接口，默認為 <code>{}</code></p></li></ul><p>說實在的，我不太能理解作者可傳遞選項的命名方式，這邊的 <code>cssProcessorOptions</code> 應該是要指 <code>cssProcessor</code> 的可傳遞選項才對，結果卻是傳入不包含 <code>plugins</code> 的 PostCSS 選項，詳細可參考 PostCSS 中的 <a href="https://github.com/postcss/postcss#options" target="_blank" rel="external nofollow noopener noreferrer">options</a>，直接來看範例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OptimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> OptimizeCssAssetsPlugin(&#123;</span><br><span class="line">      assetNameRegExp: <span class="regexp">/\.css$/g</span>,</span><br><span class="line">      cssProcessor: <span class="built_in">require</span>(<span class="string">'cssnano'</span>),</span><br><span class="line">      cssProcessorOptions: &#123;</span><br><span class="line">        map: &#123;</span><br><span class="line">          inline: <span class="literal">false</span>,</span><br><span class="line">          annotation: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      cssProcessorPluginOptions: &#123;</span><br><span class="line">        preset: <span class="string">'default'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="補充：搭配-mini-css-extract-plugin-生成-source-map-失敗"><a href="#補充：搭配-mini-css-extract-plugin-生成-source-map-失敗" class="headerlink" title="補充：搭配 mini-css-extract-plugin 生成 source-map 失敗"></a>補充：搭配 mini-css-extract-plugin 生成 source-map 失敗</h2><p>這套件有個詭異的地方在於使用 optimize-css-assets-webpack-plugin 搭配 mini-css-extract-plugin 會導致 source-map 生成失敗，先讓我們來模擬下情境：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> OptimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devtool: <span class="string">'source-map'</span>, <span class="comment">// 選擇生成實體 .map 文件</span></span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: <span class="literal">true</span>, <span class="comment">// 開啟 sourcemap 支持</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/[name].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> OptimizeCssAssetsPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>關於 source-map 的使用可參考我之前寫過的 <a href="https://awdr74100.github.io/2020-04-02-webpack-devtool/">文章</a>，接著進行編譯：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>編譯結果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── main.css</span><br><span class="line">│   │</span><br><span class="line">│   └─── js&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       ├─── main.js</span><br><span class="line">│       └─── main.js.map</span><br></pre></td></tr></table></figure><p>發現特別的地方了嗎？我們的 CSS 並沒有成功生成 <code>.map</code> 檔案，自然也就沒有 source-map 的效果，如果你把 optimize-css-assets-webpack-plugin 給拿掉，source-map 就生出來了，這很明顯是這個套件的問題，但也不用太過於擔心，這個問題不是只有我們遇到，且 GitHub 已經有人給出答案了，詳細可參考 <a href="https://github.com/NMFR/optimize-css-assets-webpack-plugin/issues/53" target="_blank" rel="external nofollow noopener noreferrer">Issues</a>，這邊需要使用到前面提到了 <code>cssProcessorOptions</code> 選項，參考以下範例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> OptimizeCssAssetsPlugin(&#123;</span><br><span class="line">      cssProcessorOptions: &#123;</span><br><span class="line">        map: &#123;</span><br><span class="line">          inline: <span class="literal">false</span>,</span><br><span class="line">          annotation: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>將 <code>inline</code> 設為 <code>false</code> 的用意是避免生成內聯映射，這樣就能正確生成 <code>.map</code> 文件了，以及將 <code>annotation</code> 設為 true 用以向 <code>.css</code> 文件添加 source-map 的路徑註釋，讓我們在編譯一次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       ├─── main.css</span><br><span class="line">│       └─── main.css.map</span><br><span class="line">│   │</span><br><span class="line">│   └─── js&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       ├─── main.js</span><br><span class="line">│       └─── main.js.map</span><br></pre></td></tr></table></figure><p>這次 CSS 的 source-map 就成功生成了，以上是在將 <code>devtool</code> 設為 <code>source-map</code> 時才需要這樣做，在 development 環境推薦使用的 <code>cheap-module-eval-source-map</code> 則有不同的做法，參考以下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> OptimizeCssAssetsPlugin(&#123;</span><br><span class="line">      cssProcessorOptions: &#123;</span><br><span class="line">        map: &#123;</span><br><span class="line">          inline: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>cheap-module-eval-source-map</code> 為內聯模式，代表我們須將 <code>inline</code> 設為 <code>true</code>，這時你可能就有疑問了，<code>true</code> 不是默認選項嗎？我們還需要設置？答案是沒錯，<a href="https://github.com/postcss/postcss/blob/master/docs/source-maps.md#options" target="_blank" rel="external nofollow noopener noreferrer">官方文檔</a> 有提到如果以前的 source-map 類型為外部地圖，而不是內聯地圖，則即使你未設置 <code>inline</code> 選項，PostCSS 也不會嵌入地圖，你可以把它理解為使用 mini-css-extract-plugin 生成實體 CSS 檔案，就是必須告訴她 <code>inline</code> 要為 <code>true</code>，不然會導致失敗，如果你使用的是 style-loader，就都沒這些問題，因為 style-loader 始終都為內聯地圖，並不會有 <code>.css</code> 實體檔案的產生。</p><h2 id="補充：使用-postcss-loader-搭配-cssnano-進行壓縮"><a href="#補充：使用-postcss-loader-搭配-cssnano-進行壓縮" class="headerlink" title="補充：使用 postcss-loader 搭配 cssnano 進行壓縮"></a>補充：使用 postcss-loader 搭配 cssnano 進行壓縮</h2><p>如果當前專案本身就已經導入 PostCSS，那我推薦你直接使用 cssnano 來完成壓縮，過程也不會像 optimize-css-assets-webpack-plugin 這麼多陷阱，請先將 postcss-loader 與 cssnano 安裝進來：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-loader cssnano -D</span><br></pre></td></tr></table></figure><p>cssnano 為 optimize-css-assets-webpack-plugin 的相依套件，這邊可以先檢查 <code>node_modules</code> 是否存在這個套件，或者直接將其覆蓋也是可以，接著將 postcss-loader 給配置進來：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devtool: <span class="string">'source-map'</span>,</span><br><span class="line">  mode: process.env.NODE_ENV,</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 新增 postcss-loader</span></span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: <span class="literal">true</span>, <span class="comment">// 開啟 sourcemap 支持</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/[name].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這邊我們可把與 optimize-css-assets-webpack-plugin 相關的代碼都給拿掉，我們不需要它了，我個人是偏好在獨立的 <code>postcss.config.js</code> 檔案內撰寫 PostCSS 設定，你也可以在 postcss-loader 中的 <code>options</code> 下進行撰寫，隨看個人喜好，參考以下：</p><p>在 <code>./</code> 根目錄新增名為 <code>postcss.config.js</code> 的檔案：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> webpack-demo/</span><br><span class="line"> │</span><br><span class="line"><span class="addition">+└─── postcss.config.js</span></span><br></pre></td></tr></table></figure><p>將相關 plugin 載入進來：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [<span class="built_in">require</span>(<span class="string">'cssnano'</span>)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有關 plugin 的傳遞選項可由後方帶入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'cssnano'</span>)(&#123;</span><br><span class="line">      preset: [<span class="string">'default'</span>, &#123; <span class="attr">discardComments</span>: &#123; <span class="attr">removeAll</span>: <span class="literal">true</span> &#125; &#125;],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果你配置過 autoprefixer，那你應該對上面過程很熟悉才對，兩者都屬於 PostCSS 中的 Plugin，配置方法自然也就都差不多，接著直接進行編譯：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>檢查是否成功壓縮：</p><!-- prettier-ignore-start --><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span>&#123;<span class="attribute">color</span>:<span class="number">#00f</span>&#125;<span class="selector-class">.text-danger</span>&#123;<span class="attribute">color</span>:red;<span class="attribute">display</span>:flex&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p>檢查是否成功生成 <code>.map</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       ├─── main.css</span><br><span class="line">│       └─── main.css.map</span><br><span class="line">│   │</span><br><span class="line">│   └─── js&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       ├─── main.js</span><br><span class="line">│       └─── main.js.map</span><br></pre></td></tr></table></figure><p>這不就與使用 optimize-css-assets-webpack-plugin 的結果一樣嗎？且我們不需要去操心 <code>inline</code> 之類的選項，過程簡單許多，這邊補充之前提到的 <code>advanced</code> 模式：</p><p>安裝高級優化組件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cssnano-preset-advanced</span><br></pre></td></tr></table></figure><p>更改 cssnano 中的 <code>preset</code> 選項：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'cssnano'</span>)(&#123;</span><br><span class="line">      preset: <span class="string">'advanced'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>關於 <code>default</code> 與 <code>advanced</code> 的差異，詳細可參考 <a href="https://cssnano.co/optimisations/" target="_blank" rel="external nofollow noopener noreferrer">這邊</a>，簡單來講就是啟用更深層的優化，但可能會有更改原始代碼的情況發生。請斟酌使用。</p>]]></content>
    
    <summary type="html">
    
      之前我們有提到如何使用 html-webpack-plugin 內建的 minify 選項壓縮 HTML，而 JavaScript 則是依靠 Webpack 本身內建的 TerserWebpackPlugin 進行壓縮，唯獨少了 CSS 的方法，這次就來介紹如何使用 optimize-css-assets-webpack-plugin 壓縮我們的 CSS，其內部預設是使用 cssnano 作為編譯器，cssnano 是建立在 PostCSS 生態系統上的工具，代表我們也可使用 postcss-loader 搭配 cssnano 來達到同樣的目的及效果，如果專案本身已導入 PostCSS，建議直接搭配 cssnano 可更快的完成壓縮目的。
    
    </summary>
    
    
      <category term="Webpack" scheme="https://awdr74100.github.io/categories/Webpack/"/>
    
    
      <category term="CSS" scheme="https://awdr74100.github.io/tags/CSS/"/>
    
      <category term="Node.js" scheme="https://awdr74100.github.io/tags/Node-js/"/>
    
      <category term="PostCSS" scheme="https://awdr74100.github.io/tags/PostCSS/"/>
    
      <category term="w3HexSchool" scheme="https://awdr74100.github.io/tags/w3HexSchool/"/>
    
      <category term="Webpack" scheme="https://awdr74100.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack 前端打包工具 - 使用 dotenv-webpack 設置全局變量</title>
    <link href="https://awdr74100.github.io/2020-06-29-webpack-dotenvwebpack/"/>
    <id>https://awdr74100.github.io/2020-06-29-webpack-dotenvwebpack/</id>
    <published>2020-06-29T13:23:49.000Z</published>
    <updated>2020-06-30T10:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Webpack 中我們會使用 DefinePlugin 或 EnvironmentPlugin 來設置全局變量，以提供 entry 內的模組針對這一個變數快速做響應，但有一點困擾我們的是，這兩個 Plugin 撰寫的全局變量都是屬於顯式性質的，代表任何人都能從所撰寫的位置得知這一個全局變量，如果情況發生在尚未發布的專案，有心人就可利用這一個變量，通常為測試主機位址，進一步做攻擊的動作，在後端我們會使用 dotenv 套件，前端可使用 dotenv-webpack 套件，屬 DefinePlugin 與 dotenv 的包裝，進一步將變量中的敏感信息隱藏起來。</p><h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul><li>dotenv-webpack 安裝</li><li>dotenv-webpack 基本使用</li><li>dotenv-webpack 可傳遞選項</li><li>補充：cross-env 與 dotenv-webpack 差別</li></ul><h2 id="dotenv-webpack-安裝"><a href="#dotenv-webpack-安裝" class="headerlink" title="dotenv-webpack 安裝"></a>dotenv-webpack 安裝</h2><blockquote><p>套件連結：<a href="https://www.npmjs.com/package/dotenv-webpack" target="_blank" rel="external nofollow noopener noreferrer">dotenv-webpack</a></p></blockquote><p>主要的套件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install dotenv-webpack -D</span><br></pre></td></tr></table></figure><p>package.json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"dotenv-webpack"</span>: <span class="string">"^1.8.0"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.43.0"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.12"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dotenv-webpack 屬 DefinePlugin 與 dotenv 的包裝，這兩個套件都不需要額外進行安裝，其中的 DefinePlugin 是 Webpack 本身就存在的套件，而 dotenv 則是 dotenv-webpack 的相依套件，嚴格來講是 dotenv-default 的相依套件。</p><h2 id="dotenv-webpack-基本使用"><a href="#dotenv-webpack-基本使用" class="headerlink" title="dotenv-webpack 基本使用"></a>dotenv-webpack 基本使用</h2><p>初始專案結構：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── main.js          # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── webpack.config.js    # Webpack 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure><p>前面我們先來看 DefinePlugin 與 EnvironmentPlugin 是如何設置全局變量的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      API_URL: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這邊要注意，上面 DefinePlugin 中的 value 寫法是錯誤的，可參考以下示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 讀取</span></span><br><span class="line"><span class="built_in">console</span>.log(API_URL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 結果</span></span><br><span class="line"><span class="built_in">console</span>.log(http:<span class="comment">//localhost:3000);</span></span><br></pre></td></tr></table></figure><p>DefinePlugin 會將編譯範圍內的全局變量 key 替換成對應的 value，這邊的替換是指原封不動的進行替換，此時可能就會造成像上面這樣子的結果，建議透過 <code>JSON.stringify()</code> 來完成予值動作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      API_URL: <span class="built_in">JSON</span>.stringify(<span class="string">'http://localhost:3000'</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此時就能確保編譯後的結果如預期：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'http://localhost:3000'</span>);</span><br></pre></td></tr></table></figure><p>很明顯的 DefinePlugin 有著不直覺的設計，這才有了後來的 EnvironmentPlugin 出現：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.EnvironmentPlugin(&#123;</span><br><span class="line">      API_URL: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面等效於以下 DefinePlugin 的寫法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env.API_URL'</span>: <span class="built_in">JSON</span>.stringify(<span class="string">'http://localhost:3000'</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>是不是很酷？在 EnvironmentPlugin 宣告的全局變量始終都會有 <code>process.env</code> 字串符前綴，這邊的 <code>process.env</code> 並不是指環境變數，如果你到 <code>process.env</code> 底下是找不到 <code>API_URL</code> 這個對象的，加入 <code>process.env</code> 的目的在於模擬環境變數的使用，這邊我們也不需要手動加入 <code>JSON.stringify()</code> 語法，EnvironmentPlugin 會自動幫我們添加，可參考以下示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 讀取</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.API_URL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 結果</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'http://localhost:3000'</span>);</span><br></pre></td></tr></table></figure><p>跑過 DefinePlugin 與 EnvironmentPlugin 你會發現兩者所撰寫的全局變量都是屬於顯示性質的，假設你將此專案推至 GitHub 等遠端 Repository 並將其設為公開，任何人都能在 Webpack 配置檔看到這些全局變量，這是很危險的一件事，這時候就是 dotenv-webpack 出場的時候了，配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 載入 dotenv-webpack (第一步)</span></span><br><span class="line"><span class="keyword">const</span> Dotenv = <span class="built_in">require</span>(<span class="string">'dotenv-webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 創建實例 (第二步)</span></span><br><span class="line">    <span class="keyword">new</span> Dotenv(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>配置 dotenv-webpack 相當簡單，與其他 Webpack Plugin 大同小異，在 dotenv-webpack 內部有一個可傳遞選項名為 <code>path</code>，預設指向 <code>./.env</code> 這支檔案，這也是我們設置全局變量的地方，請先新增名為 <code>.env</code> 的檔案：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> webpack-demo/</span><br><span class="line"> │</span><br><span class="line"><span class="addition">+└─── .env</span></span><br></pre></td></tr></table></figure><p>配置方法如同後端的 dotenv 套件，參考以下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">API_URL &#x3D; http:&#x2F;&#x2F;localhost:3000</span><br></pre></td></tr></table></figure><p>目前我們就只是將全局變量額外撰寫至 <code>.env</code> 檔內，為了達到隱藏的目的可將 <code>.env</code> 檔案新增至 <code>.gitignore</code> 內，這樣就能避免 GitHub 存在任何顯式型態的全局變量，接著來說明 <code>.env</code> 檔內的全局變量該如何做使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 讀取</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.API_URL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 結果</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'http://localhost:3000'</span>);</span><br></pre></td></tr></table></figure><p>畢竟 dotenv-webpack 屬 DefinePlugin 與 dotenv 的包裝，取用的方法自然就跟 DefinePlugin 很像，優點是少了 DefinePlugin 那些不直覺的設計，dotenv-webpack 內部與 EnvironmentPlugin 差不多，都已經幫我們處理好 <code>process.env</code> 與 <code>JSON.stringify()</code> 的問題，凡是在 <code>.env</code> 設置的全局變量，一律都是使用 <code>process.env.XXX</code> 將其讀取，這邊唯一要注意的是 <code>.env</code> 設置的全局變量都是屬於字串型態，在某些情況下我們得自己處理轉型的問題。</p><p>這邊做個補充，在 <code>.env</code> 撰寫的全局變量嚴格來講並不屬於隱式型態，畢竟在前端沒有所謂的隱式說法，最後還是會透過打包暴露給引用對象，凡是有基礎底子的人都能透過原始碼推測全局變量的內容值，dotenv-webpack 所能做的就是限制全局變量的暴露關係，只將代碼中顯示引用的全局變量暴露給最終綑綁包，代表未經引用的變量將被拋棄，任何人都無法查看這一個變量內容。</p><h2 id="dotenv-webpack-可傳遞選項"><a href="#dotenv-webpack-可傳遞選項" class="headerlink" title="dotenv-webpack 可傳遞選項"></a>dotenv-webpack 可傳遞選項</h2><p>可參考 <a href="https://www.npmjs.com/package/dotenv-webpack#properties" target="_blank" rel="external nofollow noopener noreferrer">dotenv-webpack Options</a> 可傳遞參數列表，以下為常用的參數配置：</p><ul><li><p>path：<code>String</code><br>配置全局變量的位置，默認為 <code>./.env</code></p></li><li><p>systemvars：<code>Boolean</code><br>允許加載所有系統變量，包含 cross-env 設置的變量，默認為 <code>false</code></p></li></ul><p>範例：</p><!-- prettier-ignore-start --><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Dotenv = <span class="built_in">require</span>(<span class="string">"dotenv-webpack"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> Dotenv(&#123;</span><br><span class="line">      path:</span><br><span class="line">        process.env.NODE_ENV === <span class="string">"development"</span></span><br><span class="line">          ? <span class="string">"./.env.development"</span></span><br><span class="line">          : <span class="string">"./.env.production"</span>,</span><br><span class="line">      systemvars: <span class="literal">true</span>, <span class="comment">// 允許讀取 process.env 下的任意系統變量</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><h2 id="補充：cross-env-與-dotenv-webpack-差別"><a href="#補充：cross-env-與-dotenv-webpack-差別" class="headerlink" title="補充：cross-env 與 dotenv-webpack 差別"></a>補充：cross-env 與 dotenv-webpack 差別</h2><p>這邊補充關於 cross-env 與 dotenv-webpack 的差別，嚴格來講是比較 cross-env 與 DefinePlugin 的差別，畢竟 dotenv-webpack 與 EnvironmentPlugin 都是基於 DefinePlugin 所設計，前面已經安裝過 dotenv-webpack 了，這邊將 cross-env 也給安裝進來：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cross-env -D</span><br></pre></td></tr></table></figure><p>接著在 <code>package.json</code> 新增 <code>cross-env</code> 指令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"cross-env NODE_ENV=development webpack"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"cross-env NODE_ENV=production webpack"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前我們有提到使用 cross-env 的目的在於兼容各平台的環境變數設置，畢竟在 Windows 系統下是無法直接像 <code>NODE_ENV=development</code> 這樣設置環境變數的，這時候就牽扯到一個問題了，那就是這個環境變數取用的範圍是到哪裡？直接來看範例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./webpack.config.js</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.NODE_ENV); <span class="comment">// development</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./src/main.js</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.NODE_ENV); <span class="comment">// development</span></span><br></pre></td></tr></table></figure><p>這時你可能會認為 cross-env 設置的環境變數可在任何地方做使用，代表運行環境與編譯環境都能讀取到值，這其實是錯誤的觀念，你可以嘗試將 cross-env 的變量更改為如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"cross-env NODE_ENV=development USER_NAME=Roya webpack"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"cross-env NODE_ENV=production USER_NAME=Eric webpack"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著讀取環境變量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./webpack.config.js</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.NODE_ENV); <span class="comment">// development</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.USER_NAME); <span class="comment">// Roya</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./src/main.js</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.NODE_ENV); <span class="comment">// development</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.USER_NAME); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>發現到神奇的地方了嗎？除了 <code>NODE_ENV</code> 變量以外，其它變量在編譯環境都讀不到值，這邊的編譯環境是指 entry 入口引入的那些模組，比如說 <code>./src/main.js</code>，而運行環境就是指除此之外的那些檔案，比如說 <code>./webpack.config.js</code>，這邊的 <code>NODE_ENV</code> 變量其實不是由 cross-env 設置的，而是我們在設置 <code>mode</code> 選項時，Webpack 自動使用 DefinePlugin 設置的，參考以下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env.NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(<span class="string">'&lt;當前環境&gt;'</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以我們可以得出的結論是，<strong>使用 cross-env 設置的環境變量只能在運行環境讀取到其值</strong>，在編譯環境是無法讀取到值的，較常使用在 <code>webpack.config.js</code> 做為邏輯的判斷。</p><p>看完了 cross-env 的介紹，接著來看 DefinePlugin 設置的變量範圍：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env.USER_NAME'</span>: <span class="built_in">JSON</span>.stringify(<span class="string">'Roya'</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如同我們前面所說，上面寫法等效於以下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.EnvironmentPlugin(&#123;</span><br><span class="line">      USER_NAME: <span class="string">'Roya'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也等效於 dotenv-webpack 的寫法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER_NAME &#x3D; Roya</span><br></pre></td></tr></table></figure><p>接著讀取全局變量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./webpack.config.js</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.USER_NAME); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./src/main.js</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.USER_NAME); <span class="comment">// Roya</span></span><br></pre></td></tr></table></figure><p>很明顯的 <strong>DefinePlugin、EnvironmentPlugin、dotenv-webpack 設置的全局變量都只存在於編譯環境內</strong>，畢竟要先有編譯的這個動作，Webpack 才能將這些變量注入進去，這點蠻合理的，這也是我前面強調這些方法屬於全局變量但不屬於環境變量的原因。</p><p>基於 cross-env 設置的變量是屬於環境變量，代表變量是掛載到 <code>process.env</code> 物件下，假設你使用的是 dotenv-webpack 設置變量，可開啟 <code>systemvars</code> 選項，這時編譯環境內就能夠讀取到 cross-env 設置的環境變量，可參考以下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> Dotenv(&#123;</span><br><span class="line">      systemvars: <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不須在 <code>.env</code> 設置全局變數，直接讀取 cross-env 設置的環境變量即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.env.USER_NAME);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      在 Webpack 中我們會使用 DefinePlugin 或 EnvironmentPlugin 來設置全局變量，以提供 entry 內的模組針對這一個變數快速做響應，但有一點困擾我們的是，這兩個 Plugin 撰寫的全局變量都是屬於顯式性質的，代表任何人都能從所撰寫的位置得知這一個全局變量，如果情況發生在尚未發布的專案，有心人就可利用這一個變量，通常為測試主機位址，進一步做攻擊的動作，在後端我們會使用 dotenv 套件，前端可使用 dotenv-webpack 套件，屬 DefinePlugin 與 dotenv 的包裝，進一步將變量中的敏感信息隱藏起來。
    
    </summary>
    
    
      <category term="Webpack" scheme="https://awdr74100.github.io/categories/Webpack/"/>
    
    
      <category term="Node.js" scheme="https://awdr74100.github.io/tags/Node-js/"/>
    
      <category term="w3HexSchool" scheme="https://awdr74100.github.io/tags/w3HexSchool/"/>
    
      <category term="Webpack" scheme="https://awdr74100.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Sass / SCSS 預處理器 - 自建 CSS 框架中的 Grid System 與 Spacing</title>
    <link href="https://awdr74100.github.io/2020-06-24-scss-gridsystem-spacing/"/>
    <id>https://awdr74100.github.io/2020-06-24-scss-gridsystem-spacing/</id>
    <published>2020-06-24T06:19:46.000Z</published>
    <updated>2020-06-25T12:58:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Grid System 可說是近年來前端工程師必備的一項技能，傳統上我們都是針對特定對象撰寫 media query 以達到 RWD 的效果，但對於可維護性及結構性來說，似乎這不是個好的做法，現在我們都會直接導入像是 Bootstrap 或 Tailwind 等 CSS 框架，利用內建的 Grid System 更有效率的撰寫出網站基底的 RWD 樣式，但這樣的問題是，在不考慮使用 PurgeCSS 或針對原始碼做刪減的情況下，我們將整個框架導入進來就為了使用 Grid System 會不會有點小題大作？不如我們自己來開發 Grid System 吧！</p><h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul><li>Grid System 建立及原理說明</li><li>Spacing 建立及原理說明</li></ul><h2 id="Grid-System-建立及原理說明"><a href="#Grid-System-建立及原理說明" class="headerlink" title="Grid System 建立及原理說明"></a>Grid System 建立及原理說明</h2><p>讓我們先來看 Bootstrap 4 中的 Grid System 是如何運作的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3 col-6"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3 col-6"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3 col-6"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3 col-6"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row no-gutters"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-6"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-6"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Bootstrap 在 v3 版本是使用 LESS 進行開發，當時的 Grid System 是以 <code>float</code> 撰寫而成，有用過 <code>float</code> 排版的人應該都知道其中的缺陷有多嚴重，而到了 v4 版本則是使用 SCSS 進行開發，並且使用了 <code>flexbox</code> 進行排版，這邊 <code>.row</code> 其實就是指 <code>flexbox</code> 控制子項目的父容器，<code>.container</code> 主要用來解決 <code>.row</code> 溢出問題及限制容器大小，<code>.col-*</code> 就是前面所指的子項目，有玩過 Bootstrap 的人應該都很熟悉了才對，在正式進入到開發環節時，請先完成 CSS Reset 及 <code>box-sizing</code> 的設置：</p><!-- prettier-ignore-start --><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*, *:before, *:after &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p>設置 <code>border-box</code> 的目的主要是讓我們在計算對象的大小時更為直覺，我想這應該是開發網站最基本的概念了，這邊就不多加以說明，接著我們來看 Grid System 是如何撰寫而成的：</p><div class="note warning">以下都是先以 Bootstrap 預設的 12 欄式排版做設計</div><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">1140px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.row</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: -<span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-6</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>製作 Grid System 最重要的就是 Gutter 的概念，所謂的 Gutter 就是指 <code>.col-*</code> 對象之間的間距，為了避免最左與最右邊的 Gutter 出現擠壓問題，我們必須在 <code>.row</code> 設置 <code>margin</code> 負值將容器給往外擴，這時會造成內容大小超出瀏覽器可視大小問題，進而導致 x 軸的產生，這對於 RWD 來說可是大忌，我們必須在 <code>.container</code> 設置 <code>padding</code> 將這一個負值補回，這就是我前面提到的 <code>.container</code> 不只可用來限制容器大小，還可用來將溢出的空間給補回，讓我們來看目前的效果如何：</p><p><img src="https://i.imgur.com/amWAcCl.png" alt="格線系統範例 - 1"></p><p>這邊我新增了 <code>.box</code> 樣式用以凸顯 Grid System 在畫面中呈現的感覺，你會發現與 Bootstrap 的結果是一模一樣的，目前我們只有撰寫 <code>.col-6</code> 樣式，代表只能完成兩欄式的排版，如果有其他欄式的要求，可分別在撰寫對應的樣式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.col-2</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">16.66667%</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">16.66667%</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-3</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">25%</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">25%</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我們都是基於 CSS 撰寫而成，通常我在建立 Grid System 時都會搭配 CSS 預處理器做開發，原因很簡單，不覺得一個一個撰寫對應的樣式很慢嗎？而且寬度都還要自己計算，想想就累，如果你有看我之前寫的 Sass 系列文章，此時你應該知道怎麼做了才對，參考以下範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$gutter-width</span>: <span class="number">30px</span>;</span><br><span class="line"><span class="variable">$grid-sum</span>: <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">1140px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.row</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">margin-left</span>: -(<span class="variable">$gutter-width</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="attribute">margin-right</span>: -(<span class="variable">$gutter-width</span> / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">for</span> <span class="variable">$var</span> from 1 through <span class="variable">$grid-sum</span> &#123;</span><br><span class="line">  <span class="selector-class">.col-</span>#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">100%</span> * (<span class="variable">$var</span> / <span class="variable">$grid-sum</span>);</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> (<span class="number">100%</span> * (<span class="variable">$var</span> / <span class="variable">$grid-sum</span>));</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊我們順便把 Gutter 的寬度及 Grid 的總數設置成一個變數方便日後做更改，不覺得這樣快很多嗎？寬度我們也不需要自己計算，對應的 <code>.col-*</code> 樣式全靠 <code>@for</code> 迴圈來生成就好了，到這邊我們的 Grid System 就完成一半了，結果如下：</p><p><img src="https://i.imgur.com/Kopi695.png" alt="格線系統範例 - 2"></p><p>有時候我們不想要 <code>.row</code> 中的 <code>.col-*</code> 有任何的 Gutter，意思是 <code>.col-*</code> 樣式不必存在為了 Gutters 而設計的 <code>padding</code>，既然 <code>padding</code> 都被拿掉了，<code>.row</code> 中自然也就不必存在往外擴的 <code>margin</code>，讓我們來實作這段：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.no-gutters</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">0px</span>;</span><br><span class="line"></span><br><span class="line">  &gt; <span class="selector-attr">[class*='col-']</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>與 Bootstrap 的概念相同，往後只要在 <code>.row</code> 新增 <code>.no-gutters</code> 樣式，即可將 <code>.row</code> 本身的 <code>margin</code> 以及 <code>.row</code> 下一階層 class 名稱含有 <code>col-</code> 之對象 <code>padding</code> 通通給拿掉，這邊要注意屬性選擇器的寫法，我們採用了 <code>*=</code> 來匹配對象，到了後面我們會加上 <code>.col-md-6</code>、<code>.col-sm-4</code> 之類的具有 RWD 斷點的樣式名稱，利用 <code>*=</code> 能將所有字串帶有 <code>.col-</code> 之對象通通給包含進來，處理起來方便很多，接著再來看 <code>.container-fluid</code> 的部分：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container-fluid</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>.container</code> 除了補償 <code>.row</code> 造成的多餘空間以外，還有將整個區塊置中的目的，主要依靠 <code>max-width</code> 與 <code>margin</code> 來達成，但有時候我們想要製作滿版的效果，這時候就不能使用 <code>.container</code> 了，取而代之的是 <code>.container-fluid</code> 樣式，其實就只是將 <code>max-width</code> 修改為 <code>wisth: 100%</code> 而已，詳細可參考上方，接下來進行 RWD 斷點的部分：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$grid-breakpoints</span>: (</span><br><span class="line">  <span class="string">''</span>: false,</span><br><span class="line">  sm: <span class="number">576px</span>,</span><br><span class="line">  md: <span class="number">768px</span>,</span><br><span class="line">  lg: <span class="number">992px</span>,</span><br><span class="line">  xl: <span class="number">1200px</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$grid-breakpoints</span> &#123;</span><br><span class="line">  @<span class="keyword">for</span> <span class="variable">$var</span> from 1 through <span class="variable">$grid-sum</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> (not <span class="variable">$value</span>) &#123;</span><br><span class="line">      <span class="selector-class">.col-</span>#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">padding-left</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">        <span class="attribute">padding-right</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="selector-class">.col-</span>#&#123;<span class="variable">$key</span>&#125;-#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">padding-left</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">        <span class="attribute">padding-right</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bootstrap 主要以 Mobile First 而設計，我們可以參考她的思維進行打底的動作，所謂的打底其實就是指對象小於 <code>min-width</code> 所指定的數值時所呈現的樣貌，這邊我們宣告了 <code>$grid-breakpoints</code> 變數，並在下方利用 <code>@each</code> 與 <code>@for</code> 快速生成所有 <code>.col-*</code> 或 <code>.col-*-*</code> 對象，這樣子的處理方式會造成樣式大量重複的問題，進而造成樣式表異常肥大，這邊推薦改使用 <code>@extend</code> 與佔位符選擇器來處理：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">%<span class="selector-tag">col</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$grid-breakpoints</span> &#123;</span><br><span class="line">  @<span class="keyword">for</span> <span class="variable">$var</span> from 1 through <span class="variable">$grid-sum</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> not <span class="variable">$value</span> &#123;</span><br><span class="line">      <span class="selector-class">.col-</span>#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">        @<span class="keyword">extend</span> %col;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="selector-class">.col-</span>#&#123;<span class="variable">$key</span>&#125;-#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">        @<span class="keyword">extend</span> %col;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時生成的 CSS 會長的像這個樣子：</p><!-- prettier-ignore-start --><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.col-1</span>, <span class="selector-class">.col-2</span>, <span class="selector-class">.col-3</span>, <span class="selector-class">.col-4</span>, <span class="selector-class">.col-5</span>, <span class="selector-class">.col-6</span>, <span class="selector-class">.col-7</span>, <span class="selector-class">.col-8</span>, <span class="selector-class">.col-9</span>, <span class="selector-class">.col-10</span>, <span class="selector-class">.col-11</span>, <span class="selector-class">.col-12</span>, <span class="selector-class">.col-sm-1</span>, <span class="selector-class">.col-sm-2</span>, <span class="selector-class">.col-sm-3</span>, <span class="selector-class">.col-sm-4</span>, <span class="selector-class">.col-sm-5</span>, <span class="selector-class">.col-sm-6</span>, <span class="selector-class">.col-sm-7</span>, <span class="selector-class">.col-sm-8</span>, <span class="selector-class">.col-sm-9</span>, <span class="selector-class">.col-sm-10</span>, <span class="selector-class">.col-sm-11</span>, <span class="selector-class">.col-sm-12</span>, <span class="selector-class">.col-md-1</span>, <span class="selector-class">.col-md-2</span>, <span class="selector-class">.col-md-3</span>, <span class="selector-class">.col-md-4</span>, <span class="selector-class">.col-md-5</span>, <span class="selector-class">.col-md-6</span>, <span class="selector-class">.col-md-7</span>, <span class="selector-class">.col-md-8</span>, <span class="selector-class">.col-md-9</span>, <span class="selector-class">.col-md-10</span>, <span class="selector-class">.col-md-11</span>, <span class="selector-class">.col-md-12</span>, <span class="selector-class">.col-lg-1</span>, <span class="selector-class">.col-lg-2</span>, <span class="selector-class">.col-lg-3</span>, <span class="selector-class">.col-lg-4</span>, <span class="selector-class">.col-lg-5</span>, <span class="selector-class">.col-lg-6</span>, <span class="selector-class">.col-lg-7</span>, <span class="selector-class">.col-lg-8</span>, <span class="selector-class">.col-lg-9</span>, <span class="selector-class">.col-lg-10</span>, <span class="selector-class">.col-lg-11</span>, <span class="selector-class">.col-lg-12</span>, <span class="selector-class">.col-xl-1</span>, <span class="selector-class">.col-xl-2</span>, <span class="selector-class">.col-xl-3</span>, <span class="selector-class">.col-xl-4</span>, <span class="selector-class">.col-xl-5</span>, <span class="selector-class">.col-xl-6</span>, <span class="selector-class">.col-xl-7</span>, <span class="selector-class">.col-xl-8</span>, <span class="selector-class">.col-xl-9</span>, <span class="selector-class">.col-xl-10</span>, <span class="selector-class">.col-xl-11</span>, <span class="selector-class">.col-xl-12</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p>你可能會好奇為什麼是使用 <code>width</code> 而不是使用 <code>flex</code> 屬性指定大小，在 <code>flexbox</code> 中，如果你沒有撰寫 <code>flex</code> 屬性，優先會參考 <code>width</code> 指定的大小，如果同時撰寫 <code>width</code> 與 <code>flex</code> 屬性，此時會直接參考 <code>flex</code> 所撰寫的大小，代表 <code>flex</code> 權重是高於 <code>width</code> 屬性的，這邊你也可以寫成 <code>flex</code>，兩者在打底的動作是沒有任何差別的，接著進行斷點樣式的撰寫：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$grid-breakpoints</span> &#123;</span><br><span class="line">  @<span class="keyword">if</span> not <span class="variable">$value</span> &#123;</span><br><span class="line">    @<span class="keyword">for</span> <span class="variable">$var</span> from 1 to <span class="variable">$grid-sum</span> &#123;</span><br><span class="line">      <span class="selector-class">.col-</span>#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">        <span class="attribute">max-width</span>: <span class="number">100%</span> * (<span class="variable">$var</span> / <span class="variable">$grid-sum</span>);</span><br><span class="line">        <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> (<span class="number">100%</span> * (<span class="variable">$var</span> / <span class="variable">$grid-sum</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">    @<span class="keyword">media</span> screen and (min-width: <span class="variable">$value</span>) &#123;</span><br><span class="line">      @<span class="keyword">for</span> <span class="variable">$var</span> from 1 to <span class="variable">$grid-sum</span> &#123;</span><br><span class="line">        <span class="selector-class">.col-</span>#&#123;<span class="variable">$key</span>&#125;-#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">          <span class="attribute">max-width</span>: <span class="number">100%</span> * (<span class="variable">$var</span> / <span class="variable">$grid-sum</span>);</span><br><span class="line">          <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> (<span class="number">100%</span> * (<span class="variable">$var</span> / <span class="variable">$grid-sum</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊唯一要注意的是 <code>@media</code> 撰寫的位置，雖然說 Sass 會將 <code>@media</code> 額外給提取出來，但他提取的依據是以當前所在的位置去做參考，如果你把 <code>@media</code> 寫在 <code>@for</code> 迴圈內，他會重複生成 <code>@media</code> 語句，這樣就又造成樣式大量重複的問題了，這邊我是採用判斷的方式去做處理，這樣就不會有前面提到的問題了，還有一點要注意的是，這邊我們也連同不包含斷點的 <code>.col-*</code> 一併做處理了，代表最一開始那段 <code>@for</code> 迴圈可以拿掉了，最後我們的 Grid System 會長的像這個樣子：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$gutter-width</span>: <span class="number">30px</span>;</span><br><span class="line"><span class="variable">$grid-sum</span>: <span class="number">12</span>;</span><br><span class="line"><span class="variable">$grid-breakpoints</span>: (</span><br><span class="line">  <span class="string">''</span>: false,</span><br><span class="line">  sm: <span class="number">576px</span>,</span><br><span class="line">  md: <span class="number">768px</span>,</span><br><span class="line">  lg: <span class="number">992px</span>,</span><br><span class="line">  xl: <span class="number">1200px</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">1140px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container-fluid</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.row</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">margin-left</span>: -(<span class="variable">$gutter-width</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="attribute">margin-right</span>: -(<span class="variable">$gutter-width</span> / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.no-gutters</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">0px</span>;</span><br><span class="line"></span><br><span class="line">  &gt; <span class="selector-attr">[class*='col-']</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%<span class="selector-tag">col</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$grid-breakpoints</span> &#123;</span><br><span class="line">  @<span class="keyword">for</span> <span class="variable">$var</span> from 1 through <span class="variable">$grid-sum</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> not <span class="variable">$value</span> &#123;</span><br><span class="line">      <span class="selector-class">.col-</span>#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">        @<span class="keyword">extend</span> %col;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="selector-class">.col-</span>#&#123;<span class="variable">$key</span>&#125;-#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">        @<span class="keyword">extend</span> %col;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$grid-breakpoints</span> &#123;</span><br><span class="line">  @<span class="keyword">if</span> not <span class="variable">$value</span> &#123;</span><br><span class="line">    @<span class="keyword">for</span> <span class="variable">$var</span> from 1 to <span class="variable">$grid-sum</span> &#123;</span><br><span class="line">      <span class="selector-class">.col-</span>#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">        <span class="attribute">max-width</span>: <span class="number">100%</span> * (<span class="variable">$var</span> / <span class="variable">$grid-sum</span>);</span><br><span class="line">        <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> (<span class="number">100%</span> * (<span class="variable">$var</span> / <span class="variable">$grid-sum</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">    @<span class="keyword">media</span> screen and (min-width: <span class="variable">$value</span>) &#123;</span><br><span class="line">      @<span class="keyword">for</span> <span class="variable">$var</span> from 1 to <span class="variable">$grid-sum</span> &#123;</span><br><span class="line">        <span class="selector-class">.col-</span>#&#123;<span class="variable">$key</span>&#125;-#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">          <span class="attribute">max-width</span>: <span class="number">100%</span> * (<span class="variable">$var</span> / <span class="variable">$grid-sum</span>);</span><br><span class="line">          <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> (<span class="number">100%</span> * (<span class="variable">$var</span> / <span class="variable">$grid-sum</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>當然這其中可能還有能夠優化的地方，比如說你可以把 <code>max-width</code> 與 <code>flex</code> 包裝成 <code>@mixin</code> 之類的，這些就留給大家去嘗試了，到這邊我們的 Grid System 就完成了，與 Bootstrap 中的 Grid System 操作可以說是幾乎一樣，短短的幾行代碼我們就打造出自己的 Grid System 了，有時候我不想要導入框架就會直接複製這裡的內容，讓我們以最一開始 Bootstrap 示範的那段 HTML 看看是否運行成功：</p><p><img src="https://i.imgur.com/boHC2GN.png" alt="格線系統範例 - 3"><br><img src="https://i.imgur.com/DRHX6Xo.png" alt="格線系統範例 - 4"></p><h2 id="Spacing-建立及原理說明"><a href="#Spacing-建立及原理說明" class="headerlink" title="Spacing 建立及原理說明"></a>Spacing 建立及原理說明</h2><p>既然我們都手刻出 Grid System 了，那麼順便把 Spacing 也給完成吧！Spacing 在 Bootstrap 是歸類在 Utilities 裡頭，幾乎在每個 Component 都可以看到它的身影，Bootstrap 是依造 OOCSS 撰寫而成的，自然就會有像是 <code>p-5</code>、<code>mt-3</code>、<code>my-1</code> 之類的抽象式樣式，這些就是所謂 Spacing，有效的利用 Spacing 將樣式給抽離出來，可大幅的提升元件的擴展性，讓我們直接開始吧：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$spacies</span>: (</span><br><span class="line">  <span class="string">'0'</span>: <span class="number">0px</span>,</span><br><span class="line">  <span class="string">'1'</span>: <span class="number">5px</span>,</span><br><span class="line">  <span class="string">'2'</span>: <span class="number">10px</span>,</span><br><span class="line">  <span class="string">'3'</span>: <span class="number">20px</span>,</span><br><span class="line">  <span class="string">'4'</span>: <span class="number">30px</span>,</span><br><span class="line">  <span class="string">'5'</span>: <span class="number">60px</span>,</span><br><span class="line">  <span class="string">'auto'</span>: auto,</span><br><span class="line">);</span><br><span class="line"><span class="variable">$property</span>: <span class="string">'m'</span>, <span class="string">'p'</span>;</span><br><span class="line"><span class="variable">$sides</span>: <span class="string">''</span>, <span class="string">'t'</span>, <span class="string">'b'</span>, <span class="string">'l'</span>, <span class="string">'r'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>;</span><br></pre></td></tr></table></figure><p>這邊我們先定義 <code>$spacing</code>、<code>$property</code>、<code>sides</code> 三個變數，<code>$spacing</code> 主要為間距的大小，你可以隨意新增或修改，<code>$property</code> 為作用的屬性，分別為 <code>margin</code> 與 <code>padding</code>，<code>sides</code> 為作用的方向，分別有 <code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>、<code>left</code> and <code>right</code>、<code>top</code> and <code>bottom</code> 等，其中空白代表四周都需作用的意思，這點 Bootstrap 的玩家應該很熟悉了才對，接著定義 RWD 斷點：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$grid-breakpoints</span>: (</span><br><span class="line">  <span class="string">''</span>: false,</span><br><span class="line">  sm: <span class="number">576px</span>,</span><br><span class="line">  md: <span class="number">768px</span>,</span><br><span class="line">  lg: <span class="number">992px</span>,</span><br><span class="line">  xl: <span class="number">1200px</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>你可以將所有的變數統一放置在 <code>_variables.scss</code> 做管理，這點在 7-1 模式中我們就曾經介紹過，接著開始撰寫 Spacing：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$grid-breakpoints</span> &#123;</span><br><span class="line">  @<span class="keyword">if</span> not <span class="variable">$value</span> &#123;</span><br><span class="line">    @<span class="keyword">each</span> <span class="variable">$pro</span> in <span class="variable">$property</span> &#123;</span><br><span class="line">      @<span class="keyword">each</span> <span class="variable">$side</span> in <span class="variable">$sides</span> &#123;</span><br><span class="line">        @<span class="keyword">each</span> <span class="variable">$spacKey</span>, <span class="variable">$spacValue</span> in <span class="variable">$spacies</span> &#123;</span><br><span class="line">          .#&#123;<span class="variable">$pro</span>&#125;#&#123;<span class="variable">$side</span>&#125;-#&#123;<span class="variable">$spacKey</span>&#125; &#123;</span><br><span class="line">            @<span class="keyword">include</span> generate(<span class="variable">$pro</span>, <span class="variable">$side</span>, <span class="variable">$spacValue</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">    @<span class="keyword">media</span> screen and (min-width: <span class="variable">$value</span>) &#123;</span><br><span class="line">      @<span class="keyword">each</span> <span class="variable">$pro</span> in <span class="variable">$property</span> &#123;</span><br><span class="line">        @<span class="keyword">each</span> <span class="variable">$side</span> in <span class="variable">$sides</span> &#123;</span><br><span class="line">          @<span class="keyword">each</span> <span class="variable">$spacKey</span>, <span class="variable">$spacValue</span> in <span class="variable">$spacies</span> &#123;</span><br><span class="line">            .#&#123;<span class="variable">$pro</span>&#125;#&#123;<span class="variable">$side</span>&#125;-#&#123;<span class="variable">$key</span>&#125;-#&#123;<span class="variable">$spacKey</span>&#125; &#123;</span><br><span class="line">              @<span class="keyword">include</span> generate(<span class="variable">$pro</span>, <span class="variable">$side</span>, <span class="variable">$spacValue</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其實方法與建構 Grid System 大同小異，都是將 map 或 list 的值給讀取出來，之後再看要怎麼操作，為了避免重複樣式的產生，這邊我使用到了 <code>@mixin</code> 的技巧：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> generate(<span class="variable">$pro</span>, <span class="variable">$side</span>, <span class="variable">$spacValue</span>) &#123;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">''</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'t'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-top</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-top</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'b'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-bottom</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-bottom</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'l'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-left</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-left</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'r'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-right</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-right</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'x'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-left</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">      <span class="attribute">margin-right</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-left</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">      <span class="attribute">padding-right</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'y'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-top</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">      <span class="attribute">margin-bottom</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-top</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">      <span class="attribute">padding-bottom</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我想應該還有更簡潔的寫法，這點一樣就留給大家去測試了，整體的 Spacing 長的會像這個樣子：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$spacies</span>: (</span><br><span class="line">  <span class="string">'0'</span>: <span class="number">0px</span>,</span><br><span class="line">  <span class="string">'1'</span>: <span class="number">5px</span>,</span><br><span class="line">  <span class="string">'2'</span>: <span class="number">10px</span>,</span><br><span class="line">  <span class="string">'3'</span>: <span class="number">20px</span>,</span><br><span class="line">  <span class="string">'4'</span>: <span class="number">30px</span>,</span><br><span class="line">  <span class="string">'5'</span>: <span class="number">60px</span>,</span><br><span class="line">  <span class="string">'auto'</span>: auto,</span><br><span class="line">);</span><br><span class="line"><span class="variable">$grid-breakpoints</span>: (</span><br><span class="line">  <span class="string">''</span>: false,</span><br><span class="line">  sm: <span class="number">576px</span>,</span><br><span class="line">  md: <span class="number">768px</span>,</span><br><span class="line">  lg: <span class="number">992px</span>,</span><br><span class="line">  xl: <span class="number">1200px</span>,</span><br><span class="line">);</span><br><span class="line"><span class="variable">$property</span>: <span class="string">'m'</span>, <span class="string">'p'</span>;</span><br><span class="line"><span class="variable">$sides</span>: <span class="string">''</span>, <span class="string">'t'</span>, <span class="string">'b'</span>, <span class="string">'l'</span>, <span class="string">'r'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">mixin</span> generate(<span class="variable">$pro</span>, <span class="variable">$side</span>, <span class="variable">$spacValue</span>) &#123;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">''</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'t'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-top</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-top</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'b'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-bottom</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-bottom</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'l'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-left</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-left</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'r'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-right</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-right</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'x'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-left</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">      <span class="attribute">margin-right</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-left</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">      <span class="attribute">padding-right</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'y'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-top</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">      <span class="attribute">margin-bottom</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-top</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">      <span class="attribute">padding-bottom</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$grid-breakpoints</span> &#123;</span><br><span class="line">  @<span class="keyword">if</span> not <span class="variable">$value</span> &#123;</span><br><span class="line">    @<span class="keyword">each</span> <span class="variable">$pro</span> in <span class="variable">$property</span> &#123;</span><br><span class="line">      @<span class="keyword">each</span> <span class="variable">$side</span> in <span class="variable">$sides</span> &#123;</span><br><span class="line">        @<span class="keyword">each</span> <span class="variable">$spacKey</span>, <span class="variable">$spacValue</span> in <span class="variable">$spacies</span> &#123;</span><br><span class="line">          .#&#123;<span class="variable">$pro</span>&#125;#&#123;<span class="variable">$side</span>&#125;-#&#123;<span class="variable">$spacKey</span>&#125; &#123;</span><br><span class="line">            @<span class="keyword">include</span> generate(<span class="variable">$pro</span>, <span class="variable">$side</span>, <span class="variable">$spacValue</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">    @<span class="keyword">media</span> screen and (min-width: <span class="variable">$value</span>) &#123;</span><br><span class="line">      @<span class="keyword">each</span> <span class="variable">$pro</span> in <span class="variable">$property</span> &#123;</span><br><span class="line">        @<span class="keyword">each</span> <span class="variable">$side</span> in <span class="variable">$sides</span> &#123;</span><br><span class="line">          @<span class="keyword">each</span> <span class="variable">$spacKey</span>, <span class="variable">$spacValue</span> in <span class="variable">$spacies</span> &#123;</span><br><span class="line">            .#&#123;<span class="variable">$pro</span>&#125;#&#123;<span class="variable">$side</span>&#125;-#&#123;<span class="variable">$key</span>&#125;-#&#123;<span class="variable">$spacKey</span>&#125; &#123;</span><br><span class="line">              @<span class="keyword">include</span> generate(<span class="variable">$pro</span>, <span class="variable">$side</span>, <span class="variable">$spacValue</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到這邊就完成我們的 Spacing 了，往後如果不需要某個特定斷點或者特定間距的 Spacing 時，也只需要註解調就可以了，簡直超方便，讓我們來看實際運行的狀況：</p><p><img src="https://i.imgur.com/eRuqgrM.png" alt="Spacing 運行結果 - 1"><br><img src="https://i.imgur.com/WyeEJtt.png" alt="Spacing 運行結果 - 2"><br><img src="https://i.imgur.com/aWtG6wO.png" alt="Spacing 運行結果 - 3"></p>]]></content>
    
    <summary type="html">
    
      Grid System 可說是近年來前端工程師必備的一項技能，傳統上我們都是針對特定對象撰寫 media query 以達到 RWD 的效果，但對於可維護性及結構性來說，似乎這不是個好的做法，現在我們都會直接導入像是 Bootstrap 或 Tailwind 等 CSS 框架，利用內建的 Grid System 更有效率的撰寫出網站基底的 RWD 樣式，但這樣的問題是，在不考慮使用 PurgeCSS 或針對原始碼做刪減的情況下，我們將整個框架導入進來就為了使用 Grid System 會不會有點小題大作？不如我們自己來開發 Grid System 吧！
    
    </summary>
    
    
      <category term="SCSS" scheme="https://awdr74100.github.io/categories/SCSS/"/>
    
    
      <category term="CSS" scheme="https://awdr74100.github.io/tags/CSS/"/>
    
      <category term="SCSS" scheme="https://awdr74100.github.io/tags/SCSS/"/>
    
      <category term="Bootstrap" scheme="https://awdr74100.github.io/tags/Bootstrap/"/>
    
      <category term="w3HexSchool" scheme="https://awdr74100.github.io/tags/w3HexSchool/"/>
    
  </entry>
  
  <entry>
    <title>Sass / SCSS 預處理器 - OOCSS、SMACSS、BEM 模組化方法論</title>
    <link href="https://awdr74100.github.io/2020-06-19-scss-oocss-smacss-bem/"/>
    <id>https://awdr74100.github.io/2020-06-19-scss-oocss-smacss-bem/</id>
    <published>2020-06-19T08:36:34.000Z</published>
    <updated>2020-06-21T14:38:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>所謂的 CSS 方法論是指無須任何套件或框架即可達成模組化目的的架構心法，用以讓 CSS 也能有良好的重用性、維護性及延展性，雖然我們前面已經可透過像是 SCSS 預處理器搭配 7-1 Pattern 達到模組化的效果，但 7-1 模式的模組化拆分最小單位為檔案，這代表著檔案內的所有樣式依然還是處於未模組化的狀態，此時我們就可利用知名的 OOCSS、SMACSS、BEM 等 CSS 方法論針對像是 class 這種較小的單位進行模組化，真正意義上的讓樣式表達到模組化目的。</p><h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul><li>OOCSS（Object Oriented CSS）</li><li>SMACSS (Scalable and Moduler Architecture fro CSS)</li><li>BEM (Block Element Modifier)</li></ul><h2 id="OOCSS（Object-Oriented-CSS）"><a href="#OOCSS（Object-Oriented-CSS）" class="headerlink" title="OOCSS（Object Oriented CSS）"></a>OOCSS（Object Oriented CSS）</h2><img src="https://i.imgur.com/qbPyQwF.jpg" width="80%"><p><a href="http://oocss.org/" target="_blank" rel="external nofollow noopener noreferrer">OOCSS</a> 是所有 CSS 方法論最早提出的一個，主要由 <a href="https://github.com/stubbornella" target="_blank" rel="external nofollow noopener noreferrer">Nicole Sullivan</a> 提出，你可以參考作者撰寫的 <a href="https://github.com/stubbornella/oocss/wiki" target="_blank" rel="external nofollow noopener noreferrer">WiKi</a>，OOCSS 就如同字面上的意思，主要依造物件導向 (Object-Oriented Programming, OOP) 方式來撰寫目標，這邊你可以把它理解為將 CSS 物件化、模組化，其主要概念為以下兩點：</p><ul><li>Separate structure and skin：結構與樣式分離<ul><li>例子：<code>.btn-primary</code>、<code>.rounded-top</code></li></ul></li><li>Separate container and content：容器與內容分離<ul><li>例子：<code>.container</code>、<code>.col-4</code></li></ul></li></ul><p>OOCSS 提倡的理念是樣式可重用性，在撰寫時需符合以下規則：</p><ul><li>應盡量避免使用後代選擇器 (<code>.navbar ul</code>) 或 id 選擇器 (<code>#list</code>)</li><li>應盡量避免樣式依賴於結構 (低耦合概念)，嘗試使用 class 替代 tag 選擇器</li></ul><h3 id="結構與樣式分離"><a href="#結構與樣式分離" class="headerlink" title="結構與樣式分離"></a>結構與樣式分離</h3><p>所謂的結構與樣式分離就如同 <code>.btn</code> 與 <code>.btn-primary</code> 之間的關係，讓我們先從一般在撰寫樣式的習慣開始說起：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$theme-colors</span>: (</span><br><span class="line">  primary: blue,</span><br><span class="line">  success: green,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn-primary</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.375rem</span> <span class="number">0.75rem</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: map-get(<span class="variable">$theme-colors</span>, primary);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid map-get(<span class="variable">$theme-colors</span>, primary);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.25rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>傳統上我們習慣把全部樣式都寫在同一個 class 對象上，就像上面這個樣子，此時如果我們又要新增色系為 <code>success</code> 的按鈕呢？你可能會這樣做：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn-primary</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.375rem</span> <span class="number">0.75rem</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: map-get(<span class="variable">$theme-colors</span>, primary);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid map-get(<span class="variable">$theme-colors</span>, primary);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.25rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn-success</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.375rem</span> <span class="number">0.75rem</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: map-get(<span class="variable">$theme-colors</span>, success);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid map-get(<span class="variable">$theme-colors</span>, success);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.25rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>發現問題了嗎？我們又浪費時間在撰寫相同的樣式了，在每次增加一個色系時，我們都必須整組做設定，這樣豈不是很浪費時間嗎？OOCSS 中的結構與樣式分離主要就是在改善這個問題，先將以上針對 OOCSS 的規範做個改寫：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.375rem</span> <span class="number">0.75rem</span>;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  <span class="attribute">background-color</span>: transparent;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.25rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: map-get(<span class="variable">$theme-colors</span>, primary);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid map-get(<span class="variable">$theme-colors</span>, primary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 OOCSS 的概念中，表現型的 style 就屬於樣式，封裝型的 style 就屬於結構，可參考以下：</p><ul><li>樣式 (skin)：<code>color</code>、<code>background-color</code>、<code>border-color</code></li><li>結構 (structure)：<code>display</code>、<code>box-sizing</code>、<code>padding</code> (通為樣式，但這控制其結構，故屬結構)</li></ul><p>這應該蠻好理解的，凡是顏色、邊框樣式、陰影這些都屬於 OOCSS 中所說的 skin，而像 <code>display</code> 這種或封裝對象本身就該擁有的屬性，這指 <code>padding</code>，就是所稱的 structure，你可能會問這樣的用意是什麼？直接來看 <code>button</code> 是如何使用這些樣式的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span>&gt;</span>Primary<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>是不是直覺很多？我們可以很明確的知道此對象的結構與樣式，往後如果要增加不同色系，這指 skin，也只需要撰寫像是 <code>.btn-success</code>、<code>.btn-danger</code> 的樣式即可，如果你想要更高效的做法，可以搭配 Sass 中的 <code>@each</code> 使結構更具可讀性：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$theme-colors</span>: (</span><br><span class="line">  primary: blue,</span><br><span class="line">  success: green,</span><br><span class="line">  danger: red,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.375rem</span> <span class="number">0.75rem</span>;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  <span class="attribute">background-color</span>: transparent;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.25rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$theme-colors</span> &#123;</span><br><span class="line">  <span class="selector-class">.btn-</span>#&#123;<span class="variable">$key</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="variable">$value</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="variable">$value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時按鈕只需加載對應樣式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span>&gt;</span>Primary<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-success"</span>&gt;</span>Success<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-danger"</span>&gt;</span>Danger<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>相信透過上面的範例你就能了解何謂結構與樣式分離了，如果以 OOCSS 中的 OO (Object Oriented) 做描述的話，這邊的結構 (Structure) 就是所指的對象，以上面範例來說，我們封裝了 <code>button</code> 對象，往後如果要使用 <code>button</code>的話，只需要撰寫 <code>.btn</code> 結構樣式名稱與對應的 skin 即可。</p><h3 id="容器與內容分離"><a href="#容器與內容分離" class="headerlink" title="容器與內容分離"></a>容器與內容分離</h3><p>介紹完了何謂結構與樣式分離，接下來換容器與內容該如何分離，它們之間就如同 <code>.card</code> 與 <code>.btn</code> 的關係，直接來看範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span> <span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.375rem</span> <span class="number">0.75rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我們在撰寫 CSS 時，很長根據 HTML 結構來撰寫其樣式，從上面可以看出 <code>.card</code> 裏頭似乎有個 <code>button</code>，這樣子的寫法毫無靈活度可言，<code>button</code> 完全被綁死在了 <code>.card</code> 裏頭，OOCSS 中的容器與內容分離主要就是在改善這個問題，先將以上針對 OOCSS 的規範做個改寫：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.375rem</span> <span class="number">0.75rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器與內容分離意旨將兩個不同的父子元素給分離出來，藉此達到父子元素不相互依賴的目的，且父子元素只存在於名稱上的關係，實際上兩者都可單獨存在並使用在不同的區域上，在這邊 <code>.card</code> 就屬於容器，<code>.btn</code> 就屬於內容，詳細可參考以下：</p><ul><li>容器 (container)：<code>.container</code>、<code>.col-4</code>、<code>.header</code></li><li>內容 (content)：<code>.btn</code>、<code>.input</code>、<code>.dropdown</code></li></ul><p>這邊要注意，並非所有對象都須遵守容器與內容分離的原則，可參考以下範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.col-4</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">100%</span> * (<span class="number">4</span>/<span class="number">12</span>);</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line"></span><br><span class="line">  &amp;-<span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span> auto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一個對象可能同時身兼容器與內容的角色，對於 <code>.col-4</code> 對象來說，<code>.card</code> 就屬於內容，而對於 <code>.card-body</code> 對象來說，<code>.card</code> 就屬於容器，你可能會想，怎不把 <code>.card-body</code> 做分離呢？不是說容器必須與內容作分離嗎？這邊的 <code>.card-body</code> 如果獨立存在本身是沒有任何意義的，需與 <code>.card</code> 搭配才會有意義，在這種情況下 <code>.card-body</code> 屬於 <code>.card</code> 的繼承，就無須將其分離出來，與前面的 <code>.btn</code> 不同，<code>.btn</code> 獨立存在是可重複使用在其他區塊上的。</p><p>跑過一次上面的範例你大概就能了解 OOCSS 該怎麼使用了，是不是其語法結構跟某框架很相似阿？沒錯！Bootstrap 便是根據 OOCSS 規範寫的，我們可以隨便拿個範例來看：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"navbar navbar-light bg-light"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"navbar-brand"</span>&gt;</span>Navbar<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"form-inline"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-control mr-sm-2"</span> <span class="attr">type</span>=<span class="string">"search"</span> <span class="attr">placeholder</span>=<span class="string">"Search"</span> <span class="attr">aria-label</span>=<span class="string">"Search"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-outline-success my-2 my-sm-0"</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Search<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中有 <code>.navbar</code>、<code>.navbar-light</code> 等 class，這些就屬於 OOCSS 中的結構與樣式分離，而 <code>.form-inline</code>、<code>.btn</code> 等 class，這些就屬於容器與內容分離，如果你想更深入的學習 OOCSS 概念，不妨參考下 Bootstrsp 的原始碼，其處理的細膩度可說是將 OOCSS 發揮的淋漓盡致。</p><h2 id="SMACSS-Scalable-and-Moduler-Architecture-fro-CSS"><a href="#SMACSS-Scalable-and-Moduler-Architecture-fro-CSS" class="headerlink" title="SMACSS (Scalable and Moduler Architecture fro CSS)"></a>SMACSS (Scalable and Moduler Architecture fro CSS)</h2><img src="https://i.imgur.com/w1b2SQf.png" width="80%"><p><a href="http://smacss.com/" target="_blank" rel="external nofollow noopener noreferrer">SMACSS</a> 主要由 <a href="https://snook.ca/" target="_blank" rel="external nofollow noopener noreferrer">Jonathan Snook</a> 提出，從名稱上的 Architecture 字樣可以得知他是以專案整體的結構來做考量，除了擁有與 OOCSS 類似的 HTML 與 CSS 分離概念，還有其最具特色的結構化命名概念，所謂的結構化命名是指將對象做結構分類並將其限制命名，藉此達到容易擴展及模組化目的，SMACSS 相比於 OOCSS 更偏向整個專案結構的分類及模組化你的 CSS，其中結構的分類有：</p><ul><li>Base</li><li>Layout</li><li>Module</li><li>State</li><li>Theme</li></ul><p>結構分類的目的在於將 CSS 做有效的區隔，你可以把它想成像 7-1 模式的概念，並且結合了其命名限制概念，這邊你可以先參考就好，關於實際的用途將在下面各項規則做完整介紹：</p><ul><li>Base：不須特別提供前綴，且不會使用到 class、id 選擇器，目的在於設定元素基本樣式<ul><li>例子：<code>html</code>、<code>*:before</code>、<code>img</code></li></ul></li><li>Layout：使用 <code>l-</code> 或 <code>layout-</code> 為次要佈局樣式提供前綴，目的在於將佈局樣式與其他樣式做區隔<ul><li>例子：<code>.l-header</code>、<code>.l-sidebar</code>、<code>.l-grid</code></li></ul></li><li>Module：使用模組本身命名為子模組樣式提供前綴，目的在於快速了解其相關性<ul><li>例子：<code>.card</code>、<code>.card-header</code>、<code>.card-body</code></li></ul></li><li>State：使用 <code>is-</code> 為狀態樣式提供前綴，透過語意化方式了解當前狀態<ul><li>例子：<code>.is-active</code>、<code>.is-hidden</code>、<code>.is-collapsed</code></li></ul></li><li>Theme：不須特別提供前綴，使用對象本身的名稱覆蓋其原先的主題樣式<ul><li>例子：<code>.l-header-dark</code>、<code>.card-dark</code></li></ul></li></ul><h3 id="Base-規則"><a href="#Base-規則" class="headerlink" title="Base 規則"></a>Base 規則</h3><p>Base 主要面相某些對象的基本及預設樣式，比如 <a href="https://meyerweb.com/eric/tools/css/reset/" target="_blank" rel="external nofollow noopener noreferrer">meyerweb</a> 或 <a href="https://necolas.github.io/normalize.css/8.0.1/normalize.css" target="_blank" rel="external nofollow noopener noreferrer">normalize</a> 版本的重製文件，或者是一些全域型的樣式設定，在撰寫時可參照以下規則：</p><ul><li>可使用元素選擇器、後代選擇器、子選擇器以及任何偽類將基本樣式應用於元素</li><li>不應該使用 class、id 選擇器設置元素預設樣式</li><li>不應該使用 <code>@important</code> 設置元素預設樣式 (權重過高，無法覆蓋)</li></ul><p>可參考以下：</p><!-- prettier-ignore-start --><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">form</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*, *:before, *:after &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><h3 id="Layout-規則"><a href="#Layout-規則" class="headerlink" title="Layout 規則"></a>Layout 規則</h3><p>Layout 主要面向一些網站中的大型區塊樣式，你可以把它想像成 7-1 模式中的 Layout，所處理的對象大同小異，較特別的是 SMACSS 中的 Layout 有針對重用性劃分出主要佈局樣式和次要佈局樣式，主要佈局樣式是指畫面不發生重用的對象，而次要佈局樣式自然就是指會發生重用的對象，在撰寫時可參照以下規則：</p><ul><li>主要佈局樣式通常使用 id 選擇器進行設置</li><li>次要佈局樣式通常使用 class 選擇器進行設置</li><li>次要佈局樣式可提供 <code>l-</code> 或 <code>layout-</code> 前綴用以將佈局樣式與基本樣式做區隔</li><li><strong>參考 OOCSS 中的容器與內容分離概念</strong></li></ul><p>可參考以下：</p><!-- prettier-ignore-start --><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#header</span>, <span class="selector-id">#article</span>, <span class="selector-id">#footer</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">960px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">#CCC</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">1px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p>有違於其他 SMACSS 中的規則，在 Layout 規則中的主要佈局樣式是可以使用 id 將其宣告的，當然這僅限於畫面中不重複的對象，通常為 HTML5 帶有語意化的那些標籤，如果你想要在特定情況更改其佈局樣式，可以與次要佈局樣式搭配做使用，如下所示：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#article</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.l-flipped</span> <span class="selector-id">#article</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.l-flipped</span> <span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>藉由 CSS 疊層的特性，可讓對象應用到更高層的佈局樣式，用以覆蓋其預設樣式，這邊要注意，所謂的主要佈局樣式以及次要佈局樣式就只是名稱上的定義，請不要把思維限制在只能使用主要佈局樣式，也就是通通使用 id 選擇器撰寫其佈局樣式，大部分情況次要佈局樣式要來的比主要佈局樣式有用太多了，你可以參考接下來的這個範例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"featured"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Featured<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"…"</span>&gt;</span>…<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"…"</span>&gt;</span>…<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    …</span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果不考慮 SMACSS 中的次要佈局樣式寫法，我們可能會傾向於在 <code>featured</code> 周圍的 <code>div</code> 添加 id，然後從那裡進行樣式設置：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-id">#featured</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">list-style-type</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#featured</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣撰寫等同於把對象給完全綁死了，這邊指 <code>#featured</code> 只能套用在 <code>div</code> 標籤上，且由於使用了 id 選擇器，代表同個頁面中只能存在單個套用對象，是不是有點熟悉？這不就是當時 OOCSS 在解決的問題嗎？在 SMACSS 我們可以使用次要佈局樣式改善這個問題：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.l-grid</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">list-style-type</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.l-grid</span> &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其實 SMACSS 中的次要佈局樣式道理就如同 OOCSS 的容器與內容分離，目的都是將其依賴性降到最低，從上面範例來看，<code>l-grid</code> 目前已可應用於任何容器以創建浮動樣式的佈局了，同時我們也將選擇器修改為 <code>&gt;</code> 子對象選擇器避免有例外的樣式套用到對象，還有將高度給拿掉讓對象能夠自適應，關於次要佈局樣式的實作，你就把它當成在 OOCSS 的基礎下加上其命名限制中的 <code>-l</code> 前綴就可以了。</p><h3 id="Module-規則"><a href="#Module-規則" class="headerlink" title="Module 規則"></a>Module 規則</h3><p>Module 主要面向一些網站中的可重用元件樣式，與 Layout 不同的地方在於其對象更為準確，你可以把它想像成 7-1 模式中的 Component，所處理的對象大同小異，基於 Module 的對象都應該能以獨立組件方式存在，如果操作正確，則可以輕鬆的將元件移動到 Layout 的不同部分，在撰寫時可參照以下規則：</p><ul><li>不應該使用元素選擇器、id 選擇器設置元素樣式</li><li>僅使用 class 選擇器設置元素樣式</li><li>使用模組本身命名為子模組樣式提供前綴</li><li><strong>參考 OOCSS 中的結構與樣式分離概念</strong></li></ul><p>可參考以下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>Card Header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>Card Footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果遇到以上情境，我們通常會選擇偷懶的方式撰寫樣式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.card</span> &gt; <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣的問題在於 <code>.card</code> 底下第一層 <code>div</code> 都被綁死了，如果我們今天要針對不同 <code>div</code> 撰寫效果，勢必要做些調整，在 SMACSS 中的 Module 建議通通使用 class 選擇器撰寫樣式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.card-header</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card-footer</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣子的做法解決了 <code>div</code> 被綁死的情況，同時也增加了不少可讀性，作者有強調盡量不要使用 <code>div</code>、<code>span</code> 這種大眾化的元素選擇器，使用 class 選擇器強調語意化及可重用性才是正解，繼續來看下個範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.pod</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pod</span> <span class="selector-tag">input</span><span class="selector-attr">[type='text']</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#sidebar</span> <span class="selector-class">.pod</span> <span class="selector-tag">input</span><span class="selector-attr">[type='text']</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我們有提到，基於 Module 的對象應能夠在網頁中的任一位置使用，這時我們撰寫出的樣式可能就會長的像上面這個樣子，若專案越來越複雜，可能會不小心忽略 CSS 的優先權，進而產生樣式互蓋導致跑版的問題，SMACSS 建議更改為下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.pod</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.pod</span> <span class="selector-tag">input</span><span class="selector-attr">[type='text']</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.pod-constrained</span> <span class="selector-tag">input</span><span class="selector-attr">[type='text']</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著在指定對象添加模組與子模組的 class 名稱：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pod pod-constrained"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其實他的概念就如同 OOCSS 中的結構與樣式分離，只不過在這稱其為子類化 (Subclassing)，透過將基底樣式抽離出來，往後在不同區域使用模組時，只需添加模組名稱與子類化模組名稱即可達到效果</p><h3 id="State-規則"><a href="#State-規則" class="headerlink" title="State 規則"></a>State 規則</h3><p>State 主要面向 Layout 或 Module 在網頁上的種種特效及動作，概念類似於 BEM 中的 Modifier，為了保證樣式作用於對象，允許使用 <code>@important</code>，在撰寫時可參照以下規則：</p><ul><li>State 可套用在 Layout 或 Module 上</li><li>可以使用 JavaScript 改變樣式</li><li>提供 <code>is-</code> 前綴用以辨識此為狀態樣式</li><li>可以合理的使用 <code>!important</code> 覆蓋樣式</li></ul><p>可參考以下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"nav-item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"nav-link is-active"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"nav-item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"nav-link"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"nav-item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"nav-link is-disabled"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>與前面介紹的子模組樣式不同的地方在於狀態樣式不需繼承於任何對象，他就只是單純的將樣式應用於對象，你可以參考 Bootstrap 中的 <code>.active</code> 或 <code>.disabled</code> 樣式，概念就如同上面的 <code>is-active</code> 與 <code>is-disabled</code>，為了保證狀態樣式作用於指定對象，在 State 中是允許使用 <code>@important</code> 的。</p><h3 id="Theme-規則"><a href="#Theme-規則" class="headerlink" title="Theme 規則"></a>Theme 規則</h3><p>Theme 主要面向網站主視覺而定義的 Layout 或 Module 樣式，你可以把它想像成 7-1 模式中的 theme，包含在不同國家 (語系) 中的樣式、字形轉變等。由於一般人的專案未必有如此規模，故此規則在項目不常使用，在撰寫時可參照以下規則：</p><ul><li>直接使用 Layout 或 Module 定義的 class 覆蓋其樣式</li></ul><p>可參考以下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// all.css</span></span><br><span class="line"><span class="selector-class">.mod</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// themeA.css</span></span><br><span class="line"><span class="selector-class">.mod</span> &#123;</span><br><span class="line">  <span class="attribute">border-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊要注意，你不需要以獨立的 class 去添加主題樣式，在 Theme 的規則中是建議使用與原先 Layout 或 Module 同樣的樣式名稱，而 <code>themeA.css</code> 這隻檔案務必得在 <code>all.css</code> 之後才載入，這樣就可達到覆蓋樣式的目的，如果網站有很多的主題樣式，也只需要新增像是 <code>themeB.css</code> 的檔案並撰寫如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mod</span> &#123;</span><br><span class="line">  <span class="attribute">border-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之後改載入 <code>all.css</code> 與 <code>themeB.css</code> 檔案，這樣就能達到更改不同主題顏色的目的。</p><h3 id="改變狀態"><a href="#改變狀態" class="headerlink" title="改變狀態"></a>改變狀態</h3><p>SMACSS 連同對象的狀態如何改變也有做說明，主要透過以下三種方式：</p><ul><li>透過 JavaScript 改變對象狀態</li><li>透過 pseudo-class 改變對象狀態</li><li>透過 media query 改變對象狀態</li></ul><h4 id="透過-JavaScript-改變對象狀態"><a href="#透過-JavaScript-改變對象狀態" class="headerlink" title="透過 JavaScript 改變對象狀態"></a>透過 JavaScript 改變對象狀態</h4><p>在大多數情況下，使用 JavaScript 更改對象狀態可能是最直接的方式，參考以下範例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.btn-close'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="keyword">this</span>).parents(<span class="string">'.dialog'</span>).addClass(<span class="string">'is-hidden'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>這應該蠻好理解的，這邊運用了 State 所定義的樣式來更改父層對象狀態，你可能會想，我是否可以透過 Module 所定義的子類別模組來更改對象狀態呢？如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.btn-close'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="keyword">this</span>).parents(<span class="string">'.dialog'</span>).addClass(<span class="string">'dialog-hidden'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>除了直接以 class 來操作對象狀態外，也可以利用 <code>data-*</code> 屬性來完成同樣目的，以下範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn</span><span class="selector-attr">[data-state='default']</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-attr">[data-state='pressed']</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-attr">[data-state='disabled']</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">  <span class="attribute">pointer-events</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">data-state</span>=<span class="string">"disabled"</span>&gt;</span>Disabled<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>data-*</code> 屬性是 HTML5 新增的語法，我們通常使用它來塞入一些抽象的 Primary Key，在資料庫操作時特別好用，同樣道理，我們也可塞入屬性的關鍵字，你可以參考上面範例，接著使用 JavaScript 將其更改以切換對象狀態：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.btn'</span>).bind(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="keyword">this</span>).attr(<span class="string">'data-state'</span>, <span class="string">'pressed'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="透過-pseudo-class-改變對象狀態"><a href="#透過-pseudo-class-改變對象狀態" class="headerlink" title="透過 pseudo-class 改變對象狀態"></a>透過 pseudo-class 改變對象狀態</h4><p>在 SMACSS 有提到請不要過度的使用 JavaScript 去控制對象的狀態，像是一些基本的轉換效果使用 CSS 中的 <code>:hover</code>、<code>:focus</code> 偽類可能是更好的選擇，如下範例：</p><!-- prettier-ignore-start --><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="selector-class">.btn</span>:hover &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="selector-class">.btn</span>:focus &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn-default</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="selector-class">.btn-default</span>:hover &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-class">.is-pressed</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-class">.is-pressed</span>:hover &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn-default</span><span class="selector-class">.is-pressed</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="selector-class">.btn-default</span><span class="selector-class">.is-pressed</span>:hover &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><h4 id="透過-media-query-改變對象狀態"><a href="#透過-media-query-改變對象狀態" class="headerlink" title="透過 media query 改變對象狀態"></a>透過 media query 改變對象狀態</h4><p>除了透過 class 與偽類更改對象狀態以外，我們也可使用 media query 來完成同樣目的，以下範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.nav</span> &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (max-width: 400px) &#123;</span><br><span class="line">  <span class="selector-class">.nav</span> &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (max-width: 400px) &#123;</span><br><span class="line">  <span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: none;</span><br><span class="line">    <span class="attribute">width</span>: auto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以往我們會習慣把 <code>@media</code> 放在所有程式碼的最下方統一做管理，但在 SMACSS 的建議中，反而是希望把 <code>@media</code> 放在相關的程式碼下方，就像上面範例這樣，當然你可能會想，這樣不是會造成 <code>@media</code> 語句重複被撰寫嗎？比起程式碼大小，網頁中載入的靜態資源，比如圖片，這些才是真正會影響性能的關鍵，不然你看怎麼一般人都喜歡使用 <code>@mixin</code> 搭配 <code>@content</code> 來撰寫 RWD 內容？</p><h2 id="BEM-Block-Element-Modifier"><a href="#BEM-Block-Element-Modifier" class="headerlink" title="BEM (Block Element Modifier)"></a>BEM (Block Element Modifier)</h2><img src="https://i.imgur.com/VXNptuL.png" width="80%"><p><a href="http://getbem.com/" target="_blank" rel="external nofollow noopener noreferrer">BEM</a> 主要由 <a href="https://tech.yandex.com/bem/" target="_blank" rel="external nofollow noopener noreferrer">Yandex</a> 公司所推出，其概念為透過命名方式將網頁獨立的區塊包裝成元件，有別於 OOCSS 或 SMACSS 需了解其中的組件化思維才能動作，BEM 透過最簡單且最直接的方式將原本抽象的組件化過程實踐在網頁裡頭，該方法論是基於三個要點所組成，分別為：</p><ul><li>Block：盡量以工具性質來命名對象<ul><li>例子：<code>.list</code>、<code>.card</code>、<code>.navbar</code></li></ul></li><li>Element：使用 <code>__</code> 兩個下劃線 (underline) 連接 Block 對象<ul><li>例子：<code>.list__item</code>、<code>.card__img</code>、<code>.navbar__brand</code></li></ul></li><li>Modifier：使用 <code>--</code> 兩個連字符 (hyphen) 連結 Block 或 Element 對象<ul><li>例子：<code>.list__item--active</code>、<code>.card__img--rounded</code>、<code>.navbar--dark</code></li></ul></li></ul><p>在 BEM 並沒有那些抽象的規則，任意對象都能透過其命名包裝成元件，且 BEM 是基於功能導向 (Function-Oriented Programming, FOP) 而設計的，不存在像是 <code>.pl-5</code> 這種難以理解的 class 名稱，為了保證 BEM 能夠合理的將對象模組化，請務必遵守以下規則：</p><ul><li>嚴禁使用 class 除外的選擇器撰寫樣式</li><li>不要過度模組化，應適當拿捏對象的模組化深度</li></ul><h3 id="Block-區塊"><a href="#Block-區塊" class="headerlink" title="Block 區塊"></a>Block 區塊</h3><p>所謂的 Block 是指網頁中可獨立存在的對象，你可以把它想像成 SMACSS 中的 Layout 或 Module，這邊稱其為區塊，參考以下範例：</p><ul><li>Block 名稱需能清楚的表達其用途、功能、意義，且具有唯一性</li><li>Block 可以放置在頁面上的任何位置，也可以互相嵌套</li><li>單詞之間可採小駝峰式或使用 <code>-</code> 將其分隔</li></ul><!-- prettier-ignore-start --><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.navbar</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p>還記得我們之前在 OOCSS 提到的結構與樣式分離嗎？這邊的 Block 就是指結構，Block 相比於 Element、Modifier，本身可獨立存在，不須依賴於任何對象。</p><h3 id="Element-元素"><a href="#Element-元素" class="headerlink" title="Element 元素"></a>Element 元素</h3><p>如果把區塊描述成元件，所謂的 Element 就是指依賴於此元件的子元件，參考以下範例：</p><ul><li>Element 名稱需能清楚的表達存在於元件的用途及意義性</li><li>Element 和 Element 之間可以彼此嵌套</li><li>Element 與 Block 之間使用 <code>__</code> 兩個下劃線 (underline) 連接</li><li>單詞之間可採小駝峰式或使用 <code>-</code> 將其分隔</li></ul><!-- prettier-ignore-start --><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list__item</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card__img</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.navbar__brand</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header__title</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p>這邊要注意，Element 無法獨立於 Block 之外，其存在的目的為子元件，元件既不存在何來的子元件？如果你使用的是 SCSS，可以改透過 <code>&amp;</code> 父選擇器來撰寫：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line"></span><br><span class="line">  &amp;__item &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">25%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣是不是快很多？且可讀性增加了不少，接著將樣式套用的 HTML 對象上：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有沒有逐漸感受到 BEM 的魅力阿？我們不需要去背像是 SMACSS 這麼複雜的結構概念，成效也未必來的比較好，不覺得使用 BEM 輕鬆許多嗎？且能夠直接從 class 名稱就能得知其元件的結構性，這也是 BEM 相比於 SMACSS、OOCSS 更多人使用的原因。</p><hr><p>這邊補充關於 Element 彼此嵌套的案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"list__item__link"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"list__item__link"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一個元件不太可能只有兩層結構，通常都具有三層以上的結構，此時如果使用 BEM 來撰寫，可能就會長的像上面這個樣子，但問題是這樣子的組件化處理會造成嵌套越來越深，導致 HTML 代碼相對醜陋，如果存在多級嵌套，可嘗試做以下修改：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"list__link"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"list__link"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>這意謂著所有的子元素都僅僅會被 <code>.list</code> 影響，<code>link</code> 不會被綁死在 <code>item</code> 下，代表 <code>link</code> 可自由放置在 <code>list</code> 的任何位置。</p><h3 id="Modifier-修飾子"><a href="#Modifier-修飾子" class="headerlink" title="Modifier 修飾子"></a>Modifier 修飾子</h3><p>Modifier 就如同 OOCSS 中的 Skin 與 SMACSS 中的 State，主要用來表述 Block 或 Element 的行為及外觀，參考以下範例：</p><ul><li>Modifier 名稱需能清楚表達對象外觀、狀態或行為</li><li>Modifier 與 Block 或 Element 之間使用 <code>--</code> 兩個連字符 (hyphen)</li><li>單詞之間可採小駝峰式或使用 <code>-</code> 將其分隔</li></ul><!-- prettier-ignore-start --><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list__item--active</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card__img--rounded</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.navbar--dark</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header__title--size-s</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p>Modifier 無法單獨存在，畢竟 Modifier 的出現必定是作用於某個對象，這邊所指的對象有可能為 Block 或 Element，如果你使用的是 SCSS，可以改透過 <code>&amp;</code> 父選擇器來撰寫：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line"></span><br><span class="line">  &amp;__item &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">25%</span>;</span><br><span class="line"></span><br><span class="line">    &amp;--active &#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#fffc3d</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &amp;--dark &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#272727</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我們在使用 BEM 時，都會與 SCSS 搭配做使用，不管是效率還是可讀性都提升了不少，接著套用到 HTML 對象上</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list list--dark"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item list__item--active"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>從結果可以很明顯看出其關聯性，在多人合作時，新接手這個項目的人也可以很容易從 class 名稱來分辨對象的元件結構，那些是 Block，那些是 Element，那些是 Modifier，並進一步推斷出哪部分的 HTML 可以獨立使用，這也就是 BEM 當初設立的初衷，你不需要花費很多的時間去了解像是 SMACSS、OOCSS 那種抽象的規則，BEM 用最直接的方式告訴你似乎一切不需要這麼複雜。</p><h3 id="Mix-混入"><a href="#Mix-混入" class="headerlink" title="Mix 混入"></a>Mix 混入</h3><p>Mix 並不是什麼 BEM 的概念，他算是一種處理方式，直接來看範例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"menu__list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"menu__item"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"menu__link"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn--primary"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure><p>就像我們前面講的，Block 之間是可以互相嵌套的，這邊放置了由 <code>.btn</code> 與 <code>.btn--primary</code> 組成的按鈕，很明顯的 <code>.btn</code> 就是所指的 Block，假設我們想在這一個按鈕新增像是圓角的樣式，依照 Mix 會這樣處理：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"menu__list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"menu__item"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"menu__link"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn--primary menu__btn"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之後在針對 <code>menu__btn</code> 撰寫圓角的樣式即可，Mix 想要表達的是在保持 Block 獨立存在的同時，也可以針對不同嵌套的 Block 做樣式的混入，但在這邊又一個問題是，<code>.menu__btn</code> 必須寫在 <code>.btn</code> 之前才能將其覆蓋並作用，如果依照 OOCSS 的概念，結構與樣式應該要徹底分離才對，此時可以這樣做：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"menu__list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"menu__item"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"menu__link"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn--primary btn--rounded"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure><p>沒錯，就是直接在 <code>.btn</code> 新增一個 Modifier 樣式，這樣也就能確保 <code>.menu</code> 與 <code>.btn</code> 彼此沒有關連性，且依然能有其目的效果，雖然你的 Modifier 可能會隨著項目而增加，但不覺得這樣子的處理相比於 Mix 要來的更好嗎？各位可以自行參考看看。</p>]]></content>
    
    <summary type="html">
    
      所謂的 CSS 方法論是指無須任何套件或框架即可達成模組化目的的架構心法，用以讓 CSS 也能有良好的重用性、維護性及延展性，雖然我們前面已經可透過像是 SCSS 預處理器搭配 7-1 Pattern 達到模組化的效果，但 7-1 模式的模組化拆分最小單位為檔案，這代表著檔案內的所有樣式依然還是處於未模組化的狀態，此時我們就可利用知名的 OOCSS、SMACSS、BEM 等 CSS 方法論針對像是 class 這種較小的單位進行模組化，真正意義上的讓樣式表達到模組化目的。
    
    </summary>
    
    
      <category term="SCSS" scheme="https://awdr74100.github.io/categories/SCSS/"/>
    
    
      <category term="CSS" scheme="https://awdr74100.github.io/tags/CSS/"/>
    
      <category term="SCSS" scheme="https://awdr74100.github.io/tags/SCSS/"/>
    
      <category term="w3HexSchool" scheme="https://awdr74100.github.io/tags/w3HexSchool/"/>
    
      <category term="CSS Methodologies" scheme="https://awdr74100.github.io/tags/CSS-Methodologies/"/>
    
  </entry>
  
  <entry>
    <title>Sass / SCSS 預處理器 - 依造 Sass 7-1 Pattern 構建項目</title>
    <link href="https://awdr74100.github.io/2020-06-08-scss-7-1-pattern/"/>
    <id>https://awdr74100.github.io/2020-06-08-scss-7-1-pattern/</id>
    <published>2020-06-08T10:08:59.000Z</published>
    <updated>2020-06-09T16:44:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前一篇說明了如何利用 @import 將 partial 檔案給載入進來，進而達到模組化的目的，但這邊有一個問題是，我們該針對那些內容來模組化呢？當初這點捆擾了我許久，直到發現原來有所謂的 Sass 7-1 Pattern 可參考，7-1 模式是構建 Sass 項目的一種流行且有效的模組化方法，由 7 個資料夾與 1 個檔案所組成，每一個資料夾都有各自實現的對象，我們可把同個實現對象但不同部分的 Sass 模組給放進去，這些模組最後都會被根目錄檔案視為 @import 對象，使之編譯成單獨的 CSS 檔案。</p><h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul><li>Sass 7-1 Pattern 介紹</li><li>Sass 7-1 Pattern 實際案例</li></ul><h2 id="Sass-7-1-Pattern-介紹"><a href="#Sass-7-1-Pattern-介紹" class="headerlink" title="Sass 7-1 Pattern 介紹"></a>Sass 7-1 Pattern 介紹</h2><p>Sass 7-1 Pattern 主要由國外開發者 <a href="https://hugogiraudel.com/" target="_blank" rel="external nofollow noopener noreferrer">Hugo Giraudel</a> 在廣為流傳的 <a href="https://sass-guidelin.es/" target="_blank" rel="external nofollow noopener noreferrer">Sass Guidelines</a> 所提出，其架構主要由 7 個文件夾與 1 個檔案所組成，他看起來像這個樣子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">scss&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── abstracts&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── _variables.scss</span><br><span class="line">│   ├─── _functions.scss</span><br><span class="line">│   ├─── _mixins.scss</span><br><span class="line">│   └─── _placeholders.scss</span><br><span class="line">│</span><br><span class="line">├─── base&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── _reset.scss</span><br><span class="line">│   ├─── _typography.scss</span><br><span class="line">│   └─── ...</span><br><span class="line">│</span><br><span class="line">├─── components&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── _buttons.scss</span><br><span class="line">│   ├─── _carousel.scss</span><br><span class="line">│   ├─── _cover.scss</span><br><span class="line">│   ├─── _dropdown.scss</span><br><span class="line">│   └─── ...</span><br><span class="line">│</span><br><span class="line">├─── layout&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── _navigation.scss</span><br><span class="line">│   ├─── _grid.scss</span><br><span class="line">│   ├─── _header.scss</span><br><span class="line">│   ├─── _footer.scss</span><br><span class="line">│   ├─── _sidebar.scss</span><br><span class="line">│   ├─── _forms.scss</span><br><span class="line">│   └─── ...</span><br><span class="line">│</span><br><span class="line">├─── pages&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── _home.scss</span><br><span class="line">│   ├─── _contact.scss</span><br><span class="line">│   └─── ...</span><br><span class="line">│</span><br><span class="line">├─── themes&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── _theme.scss</span><br><span class="line">│   ├─── _dark.scss</span><br><span class="line">│   └─── ...</span><br><span class="line">│</span><br><span class="line">├─── vendors&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── _bootstrap.scss</span><br><span class="line">│   ├─── _jquery-ui.scss</span><br><span class="line">│   └─── ...</span><br><span class="line">│</span><br><span class="line">└─── all.scss</span><br></pre></td></tr></table></figure><p>其中每個資料夾代表的意義為：</p><p><strong>Abstracts 資料夾</strong></p><p><code>abstracts/</code> (有些稱為 <code>helpers/</code> 或 <code>utils/</code>) 資料夾包含了整個項目中所使用到的 Sass 輔助工具，這裡存放著每一個全局變數、函數、混入與佔位符，只要是編譯後不輸出任何 CSS 的檔案都屬此類，以下參考：</p><ul><li><code>_variables.scss</code></li><li><code>_functions.scss</code></li><li><code>_mixins.scss</code></li><li><code>_placeholders.scss</code></li></ul><p><strong>Base 資料夾</strong></p><p><code>base/</code> (有些稱為 <code>config/</code>) 資料夾主要放置整個網站大規模使用到的樣式設定，比如 <a href="https://meyerweb.com/eric/tools/css/reset/" target="_blank" rel="external nofollow noopener noreferrer">meyerweb</a> 或 <a href="https://necolas.github.io/normalize.css/8.0.1/normalize.css" target="_blank" rel="external nofollow noopener noreferrer">normalize</a> 版本的重製文件，又或者是一些全域套用的預設樣式，包含字行字體相關的設定也算在內，以下參考：</p><ul><li><code>_reset.scss</code></li><li><code>_typography.scss</code></li><li><code>_base.scss</code></li></ul><p><strong>Components 資料夾</strong></p><p><code>components/</code> (有些稱為 <code>modules/</code>) 資料夾存放網站某些較小可重複使用的元件，可以把它理解為 <a href="http://getbem.com/" target="_blank" rel="external nofollow noopener noreferrer">BEM</a> 中的 Block，以下參考：</p><ul><li><code>_buttons.scss</code></li><li><code>_carousel.scss</code></li><li><code>_cover.scss</code></li><li><code>_dropdown.scss</code></li></ul><p><strong>Layout 資料夾</strong></p><p><code>layout/</code> 資料夾存放構建網站或者應用程序使用到的佈局部分，可以把它理解為網站的每一頁都需使用到的大型元件，常見的 <code>header</code>、<code>footer</code>、<code>sidebar</code> 就包含在此類，像是 RWD 必備的 Grid System 也算在內，以下參考：</p><ul><li><code>_navigation.scss</code></li><li><code>_grid.scss</code></li><li><code>_header.scss</code></li><li><code>_footer.scss</code></li><li><code>_sidebar.scss</code></li><li><code>_forms.scss</code></li></ul><p><strong>Pages 資料夾</strong></p><p><code>pages/</code> 資料夾存放每一個網頁特定且零碎的樣式檔案，通常 <code>layout/</code> 與 <code>components</code> 除外的頁面樣式就包含在此類，建議將檔案名稱取做與頁面同樣名稱：</p><ul><li><code>_home.scss</code></li><li><code>_contact.scss</code></li></ul><p><strong>Themes 資料夾</strong></p><p><code>themes/</code> 資料夾存放網站中的主題顏色，如果你有設計像是 Dark Mode 的轉換效果，相關的樣式就算在此類，以下參考：</p><ul><li><code>_theme.scss</code></li><li><code>_dark.scss</code></li></ul><p><strong>Vendors 資料夾</strong></p><p><code>vendors</code> 資料夾主要放置由外部庫或框架使用的第三方代碼，如果你必須覆蓋任何 <code>vendors</code> 的某個樣式，建議另外新增同名的檔案並放入名為 <code>vendors-extensions/</code> 的第 8 個新增資料夾，以下參考：</p><ul><li><code>_bootstrap.scss</code></li><li><code>_jquery-ui</code></li></ul><p>以上就是各資料夾專門放置的檔案對象，接著就是將這些檔案彙整到 <code>all.scss</code> 中，為了保持可讀性，主文件不該存在任何 <code>@import</code> 以外的代碼，且必須遵守以下規則：</p><ul><li>每個 <code>@import</code> 引用一個文件</li><li>每個 <code>@import</code> 單獨一行</li><li>從相同資料夾引入的檔案之間不用空行</li><li>從不同資料夾引入的檔案之間需用空行分隔</li><li>忽略文件擴展名與 <code>_</code> 前綴</li></ul><p>Sass Guidelines 中有建議的 <code>@import</code> 順序，你可以依造他的順序，或者是自行排序，只要記住 SCSS 是由上到下進行編譯代表需注意其模組依賴性即可，最後他看起來應該像這個樣子：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">'./base/reset'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./base/typography'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/variables'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/functions'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/mixins'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/placeholders'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./layout/grid'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./layout/footer'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./layout/forms'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./layout/header'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./layout/navigation'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./layout/sidebar'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/buttons'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/carousel'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/cover'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/dropdown'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./pages/home'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./pages/contact'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./vendors/bootstrap'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./vendors/jquery-ui'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./themes/theme'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./themes/dark'</span>;</span><br></pre></td></tr></table></figure><p>這邊做個補充，官方有提到也可使用以下方式載入元件：</p><!-- prettier-ignore-start --><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span></span><br><span class="line">    <span class="string">'./base/reset'</span>,</span><br><span class="line">    <span class="string">'./base/typography'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span></span><br><span class="line">    <span class="string">'./helpers/variables'</span>,</span><br><span class="line">    <span class="string">'./helpers/functions'</span>,</span><br><span class="line">    <span class="string">'./helpers/mixins'</span>,</span><br><span class="line">    <span class="string">'./helpers/placeholders'</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p>這邊要強調，所謂的 7-1 模式只是提供參考用，具體上要怎麼搭，最好按項目大小來決定，如果項目規模較小，用 7-1 模式就顯得有點大材小用了，7-1 模式最重要的是它拆分模組的概念，如果了解其概念，往後在處理各種規模的樣式表都能勢如破竹。</p><h2 id="Sass-7-1-Pattern-實際案例"><a href="#Sass-7-1-Pattern-實際案例" class="headerlink" title="Sass 7-1 Pattern 實際案例"></a>Sass 7-1 Pattern 實際案例</h2><p>如果你還是對 7-1 模式感到困惑，不妨可參考下面提供的實際案例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">'./base/reset'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/variables'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/spacing'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./layout/grid'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./layout/footer'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./layout/header'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/banner'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/button'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/card'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/formLogin'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/formRegister'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/formCard'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/navbar'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/ribbon'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/search'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./pages/home'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./pages/login'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./pages/register'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./pages/cart'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./vendors/pure'</span>;</span><br></pre></td></tr></table></figure><p>從 Sass 的主文件可以得知這個網站總共有 4 個頁面，分別為 <code>home</code>、<code>login</code>、<code>register</code>、<code>cart</code>，在樣式表的開頭使用了 CSS Reset 將畫面樣式做重整，內部使用了 Grid System 與 Spacing 來完成基本的佈局，網站充滿了大量可重複使用的元件，比如說 <code>button</code>、<code>card</code> 等，最後在 <code>vendors/</code> 資料夾載入了 <a href="https://purecss.io/" target="_blank" rel="external nofollow noopener noreferrer">Pure.css</a> 框架。</p><p>有沒有發現我少建立 <code>themes/</code> 資料夾？如果你的網站沒有主題顏色自然也就沒有建立的必要，這也是我們之前提到的 7-1 模式只是提供參考用，具體上該怎麼做還是得依專案而定。</p><p>跑過了一次實際案例相信你對 7-1 模式的模組拆分技巧有更深入的了解，你也可以參考 <a href="https://sass-guidelin.es/" target="_blank" rel="external nofollow noopener noreferrer">Sass Guidelines</a> 作者 <a href="https://hugogiraudel.com/" target="_blank" rel="external nofollow noopener noreferrer">Hugo Giraudel</a> 使用 <a href="https://hugogiraudel.com/" target="_blank" rel="external nofollow noopener noreferrer">Hugo</a> 所創建的 Blog 原始碼，裏頭 Sass 拆分的方式就是依造 7-1 模式，以下為連結：</p><ul><li><a href="https://github.com/HugoGiraudel/hugogiraudel.com/tree/master/assets/sass" target="_blank" rel="external nofollow noopener noreferrer">Source Code</a></li></ul>]]></content>
    
    <summary type="html">
    
      前一篇說明了如何利用 @import 將 partial 檔案給載入進來，進而達到模組化的目的，但這邊有一個問題是，我們該針對那些內容來模組化呢？當初這點捆擾了我許久，直到發現原來有所謂的 Sass 7-1 Pattern 可參考，7-1 模式是構建 Sass 項目的一種流行且有效的模組化方法，由 7 個資料夾與 1 個檔案所組成，每一個資料夾都有各自實現的對象，我們可把同個實現對象但不同部分的 Sass 模組給放進去，這些模組最後都會被根目錄檔案視為 @import 對象，使之編譯成單獨的 CSS 檔案。
    
    </summary>
    
    
      <category term="SCSS" scheme="https://awdr74100.github.io/categories/SCSS/"/>
    
    
      <category term="SCSS" scheme="https://awdr74100.github.io/tags/SCSS/"/>
    
      <category term="w3HexSchool" scheme="https://awdr74100.github.io/tags/w3HexSchool/"/>
    
      <category term="CSS Methodologies" scheme="https://awdr74100.github.io/tags/CSS-Methodologies/"/>
    
  </entry>
  
  <entry>
    <title>Sass / SCSS 預處理器 - @import 載入模組與 Partials 建立部分模組</title>
    <link href="https://awdr74100.github.io/2020-06-05-scss-import-partials/"/>
    <id>https://awdr74100.github.io/2020-06-05-scss-import-partials/</id>
    <published>2020-06-05T06:28:02.000Z</published>
    <updated>2020-06-08T04:36:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>模組化一直以來都是網頁端一項很重要的處理，有效的模組化可讓程式碼進一步提升其閱讀性，以讓後續維護人員更快速的進入狀況，且利用模組可重用的特性，我們也不需要撰寫這麼多的重複代碼，載入即完成，可說是大幅提高了其開發效率。在 CSS 可使用 @import 來拆分模組，而 SCSS 同樣也是使用 @import 來拆分模組，兩者不同的地方在於 CSS 的 @import 會產生額外的 request，而 SCSS 主要利用其特殊的 partial 檔案形成模組化的效果，再不產生額外 request 下達到模組化目的。</p><h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul><li>建立部分模組</li><li>載入模組</li></ul><h2 id="建立部分模組"><a href="#建立部分模組" class="headerlink" title="建立部分模組"></a>建立部分模組</h2><p>所謂的部分模組其實就是指不會被編譯出實體檔案的模組，請先新增以下檔案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">project&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── scss&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── a.scss</span><br><span class="line">│   └─── b.scss</span><br></pre></td></tr></table></figure><p>前面我們都是示範在單個 SCSS 檔案進行開發，並透過編譯器生成對應的 CSS 檔案，那如果是兩個 SCSS 檔案呢？此時的編譯結果為：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> project/</span><br><span class="line"> │</span><br><span class="line"><span class="addition">+├─── css/</span></span><br><span class="line"><span class="addition">+│   │</span></span><br><span class="line"><span class="addition">+│   ├─── a.css</span></span><br><span class="line"><span class="addition">+│   └─── b.css</span></span><br><span class="line"> │</span><br><span class="line"> ├─── scss/</span><br><span class="line"> │   │</span><br><span class="line"> │   ├─── a.scss</span><br><span class="line"> │   └─── b.scss</span><br></pre></td></tr></table></figure><p>沒錯，這樣就會生成兩個 CSS 檔案，這應該是蠻好理解的，每一個 SCSS 檔案都是獨立的存在，編譯器會針對每個 SCSS 檔案生成對應的 CSS 檔案，如果你不想讓編譯器針對 SCSS 檔案生成實體檔案，可改使用 <code>_</code> 為開頭將其建立，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">project&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── scss&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── a.scss</span><br><span class="line">│   └─── _b.scss</span><br></pre></td></tr></table></figure><p>在這邊我們將 <code>b.scss</code> 更改為 <code>_b.scss</code>，神奇的事情要發生了，直接進行編譯：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> project/</span><br><span class="line"> │</span><br><span class="line"><span class="addition">+├─── css/</span></span><br><span class="line"><span class="addition">+│   │</span></span><br><span class="line"><span class="addition">+│   └─── a.css</span></span><br><span class="line"> │</span><br><span class="line"> ├─── scss/</span><br><span class="line"> │   │</span><br><span class="line"> │   └─── a.scss</span><br><span class="line"> │   └─── b.scss</span><br></pre></td></tr></table></figure><p>你會發現 <code>_b.scss</code> 沒有被編譯出實體檔案，在 SCSS 會稱其為 <code>partial</code>，以 <code>_</code> 開頭的 <code>.scss</code> 或 <code>.sass</code> 檔案都屬於 <code>partial</code> 類型檔案，用以告知編譯器不要嘗試自行編譯這些檔案。</p><p>你可能會問，這樣的用意是什麼？你可以把 <code>partial</code> 理解為只供予其他檔案 <code>@import</code> 的模組，如果單獨存在，本身是沒有任何意義的，通常都是與 <code>@import</code> 搭配居多，讓我們繼續看下去。</p><h2 id="載入模組"><a href="#載入模組" class="headerlink" title="載入模組"></a>載入模組</h2><p>前面已經介紹 <code>partial</code> 的作用了，接著讓我們正式進入到 SCSS 模組化的章節，先建立以下結構：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">project&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── scss&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── helpers&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       ├─── _mixins.scss</span><br><span class="line">│       └─── _variables.scss</span><br><span class="line">│   │</span><br><span class="line">│   └─── all.scss</span><br></pre></td></tr></table></figure><p>一般來說我們都會把 SCSS 的模組彙整到 <code>all.scss</code> 檔案中，而模組的命名必定會以 <code>_</code> 為開頭 ，這點在前面已經有解釋過，最後的編譯結果就只會生成 <code>all.scss</code> 對應的 <code>all.css</code> 檔案，接著在每個模組檔案撰寫其對應內容：</p><p><code>./scss/helpers/_variables.scss</code> 檔案內容：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$theme-colors</span>: (</span><br><span class="line">  primary: blue,</span><br><span class="line">  success: green,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>./scss/helpers/_mixins.scss</code> 檔案內容：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> bg-invert(<span class="variable">$color</span>) &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: invert(<span class="variable">$color</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>./scss/all.scss</code> 檔案內容：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/variables'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/mixins'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 測試輸出</span></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$theme-colors</span> &#123;</span><br><span class="line">  <span class="selector-class">.text-</span>#&#123;<span class="variable">$key</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$value</span>;</span><br><span class="line">    @<span class="keyword">include</span> bg-invert(<span class="variable">$value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@import</code> 語句可用來載入其他模組，並且不需要撰寫 <code>_</code> 與 <code>.scss</code> 字樣，SCSS 能夠自動辨認其模組，上面範例就等同於將全部代碼撰寫在 <code>all.scss</code> 中，如下所示：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$theme-colors</span>: (</span><br><span class="line">  primary: blue,</span><br><span class="line">  success: green,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">@<span class="keyword">mixin</span> bg-invert(<span class="variable">$color</span>) &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: invert(<span class="variable">$color</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 測試輸出</span></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$theme-colors</span> &#123;</span><br><span class="line">  <span class="selector-class">.text-</span>#&#123;<span class="variable">$key</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$value</span>;</span><br><span class="line">    @<span class="keyword">include</span> bg-invert(<span class="variable">$value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊你應該就能理解何謂 SCSS 模組化了，其實到頭來我們都是在呼叫 <code>@import</code> 的對象 <code>all.scss</code> 做撰寫，只不過將其撰寫內容拆分到被呼叫的 <code>@import</code> 對象而已，這也是與傳統 CSS 模組化最大的不同，SCSS 的模組化是發生在未編譯之前，這時你可以任意的拆分模組，反正不影響編譯生成的 CSS 檔案數量，而 CSS 的模組化是發生在 Browser 讀取到其 <code>@import</code> 字樣，進而發送 HTTP Request 時，這也是為什麼一般都推薦使用 SCSS 來完成模組化目的。</p><p>這邊還有一點要注意的是，通常 <code>all.scss</code> 不應該存在任何 <code>@import</code> 以外的代碼，進而影響檔案的可讀性，此時我們可針對以上做個改寫：</p><p>新增 <code>./scss/helpers/_text.scss</code>：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$theme-colors</span> &#123;</span><br><span class="line">  <span class="selector-class">.text-</span>#&#123;<span class="variable">$key</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$value</span>;</span><br><span class="line">    @<span class="keyword">include</span> bg-invert(<span class="variable">$value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>./scss/all.scss</code> 將其載入：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/variables'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/mixins'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/text'</span>;</span><br></pre></td></tr></table></figure><p>這樣是不是整潔許多？在 <code>@import</code> 時需要注意其依賴性，只需要保持一個原則就是 SCSS 是由上到下進行編譯，你總不可能把 <code>_variables.scss</code> 放在 <code>_text.scss</code> 下面吧？這樣肯定會發生 <code>Undefined</code> 的錯誤。</p>]]></content>
    
    <summary type="html">
    
      模組化一直以來都是網頁端一項很重要的處理，有效的模組化可讓程式碼進一步提升其閱讀性，以讓後續維護人員更快速的進入狀況，且利用模組可重用的特性，我們也不需要撰寫這麼多的重複代碼，載入即完成，可說是大幅提高了其開發效率。在 CSS 可使用 @import 來拆分模組，而 SCSS 同樣也是使用 @import 來拆分模組，兩者不同的地方在於 CSS 的 @import 會產生額外的 request，而 SCSS 主要利用其特殊的 partial 檔案形成模組化的效果，再不產生額外 request 下達到模組化目的。
    
    </summary>
    
    
      <category term="SCSS" scheme="https://awdr74100.github.io/categories/SCSS/"/>
    
    
      <category term="SCSS" scheme="https://awdr74100.github.io/tags/SCSS/"/>
    
  </entry>
  
  <entry>
    <title>Sass / SCSS 預處理器 - @entend 繼承樣式與 Placeholder 佔位符選擇器</title>
    <link href="https://awdr74100.github.io/2020-06-03-scss-extend/"/>
    <id>https://awdr74100.github.io/2020-06-03-scss-extend/</id>
    <published>2020-06-02T16:00:55.000Z</published>
    <updated>2020-06-04T15:49:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前面我們有提到可使用 @mixin 將發生重用的樣式給包裝起來，進而減少重複撰寫樣式的時間，但在這邊有一個問題是，此做法會造成編譯後的 CSS 發生樣式大量重複的問題，搞得檔案異常肥大，在較為嚴苛的環境下，此問題是不被允許的，建議的作法是使用 @entend 並搭配 placeholder 選擇器將重用樣式給綑綁起來，@extend 就類似於 @mixin，不同的地方在於 @extend 會將目標對象進行合併而不是載入，而 placeholder 選擇器主要用來創建重用對象，在不被編譯的狀態下給予 @extend 繼承用。</p><h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul><li>繼承樣式</li><li>佔位符選擇器</li><li>@extend 與 @mixin 使用時機和差異</li></ul><h2 id="繼承樣式"><a href="#繼承樣式" class="headerlink" title="繼承樣式"></a>繼承樣式</h2><p>讓我們先來回顧 <code>@mixin</code> 是怎麼解決樣式重用問題的：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> flex-center &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> flex-center;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> flex-center;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> flex-center;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@mixin</code> 是我最常使用的 SCSS 功能，只需要在 <code>@include</code> 之前撰寫一次會發生重用的樣式，後續就都利用 <code>@include</code> 載入其樣式即可，此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>雖然說編譯後的檔案我們通常不會有太多的關注，但在某些情況下，我們確實需要做些改善以符合當前專案的規範，比如說樣式表的檔案大小，從上面結果你會發現 <code>@mixin</code> 形成了許多重複樣式，也因為這些重複樣式造成樣式表異常的肥大，建議的做法是將發生重用的樣式以合併的方式進行處理，如下所示：</p><!-- prettier-ignore-start --><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span>, <span class="selector-class">.section</span>, <span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p>合併樣式的目的在於保持代碼的精簡性，以不發生重複代碼為原則，依然保持樣式作用於對象，為了滿足合併樣式的目的，我們可改使用 <code>@extend</code> 方法，直接來看範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-center</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  @<span class="keyword">extend</span> .flex-center;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  @<span class="keyword">extend</span> .flex-center;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  @<span class="keyword">extend</span> .flex-center;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@extend</code> 的目的在於繼承其指定樣式，呼叫 <code>@extend</code> 的對象會被合併到指定的對象上，相較於 <code>@mixin</code> 的處理方式，此方法既能減少重複樣式的撰寫也能達到編譯後 CSS 精簡化的目的，此時的編譯結果為：</p><!-- prettier-ignore-start --><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-center</span>, <span class="selector-class">.header</span>, <span class="selector-class">.section</span>, <span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p>這不就是我們要的結果嗎？相關的樣式都被合併到了指定樣式上，讓我們再來看個範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.font-base</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#1d1d1d</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.5em</span>;</span><br><span class="line">    @<span class="keyword">extend</span> .font-base;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">  <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.25em</span>;</span><br><span class="line">    @<span class="keyword">extend</span> .font-base;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如同我們前面所說，呼叫 <code>@extend</code> 的對象會被合併到指定對象上，這邊所指的對象為 <code>.header h1</code> 與 <code>.footer h1</code>，並不是指單純的 <code>h1</code> 對象，最後的編譯結果為：</p><!-- prettier-ignore-start --><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.font-base</span>, <span class="selector-class">.header</span> <span class="selector-tag">h1</span>, <span class="selector-class">.footer</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#1d1d1d</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.25em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><h2 id="佔位符選擇器"><a href="#佔位符選擇器" class="headerlink" title="佔位符選擇器"></a>佔位符選擇器</h2><p>在前面範例中，我們必定是要宣告個對象用以讓其他對象 <code>@extend</code>，這不就會導致產生無意義的樣式對象了嗎？如之前的 <code>.flex-center</code>、<code>.font-base</code> 等，如果繼承的對象沒有任何作用，我們可改使用 SCSS 獨特的佔位符選擇器將其宣告，這樣就不會有實體的樣式對象了，如下範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%<span class="attribute">flex</span>-center &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>佔位符選擇器顧名思義就是使用 <code>%</code> 符號將其宣告，與傳統 <code>class</code>、<code>id</code> 選擇器較不同的地方在於它不會產生實體的對象，你可以嘗試編譯上面範例，最後並不會有任何的樣式被編譯出來，利用此特性我們可針對之前範例做個改寫：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">%<span class="attribute">flex</span>-center &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  @<span class="keyword">extend</span> %flex-center;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  @<span class="keyword">extend</span> %flex-center;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  @<span class="keyword">extend</span> %flex-center;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>將原本利用 <code>class</code> 選擇器宣告的對象更改為 <code>%</code> 宣告，同時 <code>@extend</code> 此對象，最後的編譯結果為：</p><!-- prettier-ignore-start --><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span>, <span class="selector-class">.section</span>, <span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p>大功告成！編譯結果與當初設定目標一模一樣，佔位符選擇器的應用範圍可能也只有供予 <code>@extend</code> 繼承用，畢竟它不會被實體編譯出來，在多的延伸也沒有其意義。</p><h2 id="extend-與-mixin-使用時機和差異"><a href="#extend-與-mixin-使用時機和差異" class="headerlink" title="@extend 與 @mixin 使用時機和差異"></a>@extend 與 @mixin 使用時機和差異</h2><p>如果你對 <code>@extend</code> 與 <code>@mixin</code> 的使用時機和差異感到困惑，可以從以下兩點去做思考：</p><ul><li>是否需要傳遞參數？</li><li>是否在意樣式表大小？</li></ul><p>傳遞參數這點沒啥好說的，你只能使用 <code>@mixin</code> 來完成任務，因為 <code>@extend</code> 是無法傳遞任何參數的，而 <code>@mixin</code> 與 <code>@function</code> 相同，都可傳入任意的參數做使用，可參考以下範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> size(<span class="variable">$num1</span>, <span class="variable">$num2</span>) &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$num1</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="variable">$num2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> size(<span class="number">200px</span>, 200px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@extend</code> 自然是無法完成上面任務的，畢竟它沒辦法傳遞任何參數，還有另外一個判斷的依據為是否在意樣式表大小，可參考以下範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%<span class="selector-tag">col</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">for</span> <span class="variable">$var</span> from 1 through 12 &#123;</span><br><span class="line">  <span class="selector-class">.col-</span>#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">    @<span class="keyword">extend</span> %col;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面使用了 <code>@extend</code> 來完成任務，將所有相關的樣式進行合併以減少樣式表大小，同樣道理，你也可以使用 <code>@mixin</code> 來完成，參考以下範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> col &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">for</span> <span class="variable">$var</span> from 1 through 12 &#123;</span><br><span class="line">  <span class="selector-class">.col-</span>#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">    @<span class="keyword">include</span> col;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.col-1</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 省略 .col-2 ~ .col-11 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-12</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>發現問題了嗎？明明所有對象都是套用相同的樣式，使用 <code>@mixin</code> 就硬生生的生成了全部實體樣式，像在這種情況就推薦使用 <code>@extend</code> 來完成，其編譯結果為：</p><!-- prettier-ignore-start --><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.col-1</span>, <span class="selector-class">.col-2</span>, <span class="selector-class">.col-3</span>, <span class="selector-class">.col-4</span>, <span class="selector-class">.col-5</span>, <span class="selector-class">.col-6</span>, <span class="selector-class">.col-7</span>, <span class="selector-class">.col-8</span>, <span class="selector-class">.col-9</span>, <span class="selector-class">.col-10</span>, <span class="selector-class">.col-11</span>, <span class="selector-class">.col-12</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- prettier-ignore-end --><p>這樣不是好多了嗎？所有對象都被合併到了 <code>%col</code> 對象內，如果你並不在意樣式表的大小，大可使用 <code>@mixin</code> 來完成任務，但我個人推薦使用 <code>@extend</code> 就是了。</p>]]></content>
    
    <summary type="html">
    
      在前面我們有提到可使用 @mixin 將發生重用的樣式給包裝起來，進而減少重複撰寫樣式的時間，但在這邊有一個問題是，此做法會造成編譯後的 CSS 發生樣式大量重複的問題，搞得檔案異常肥大，在較為嚴苛的環境下，此問題是不被允許的，建議的作法是使用 @entend 並搭配 placeholder 選擇器將重用樣式給綑綁起來，@extend 就類似於 @mixin，不同的地方在於 @extend 會將目標對象進行合併而不是載入，而 placeholder 選擇器主要用來創建重用對象，在不被編譯的狀態下給予 @extend 繼承用。
    
    </summary>
    
    
      <category term="SCSS" scheme="https://awdr74100.github.io/categories/SCSS/"/>
    
    
      <category term="SCSS" scheme="https://awdr74100.github.io/tags/SCSS/"/>
    
  </entry>
  
  <entry>
    <title>Sass / SCSS 預處理器 - @function 建立函式與 @return 返回結果</title>
    <link href="https://awdr74100.github.io/2020-06-01-scss-function-return/"/>
    <id>https://awdr74100.github.io/2020-06-01-scss-function-return/</id>
    <published>2020-06-01T04:30:43.000Z</published>
    <updated>2020-06-02T09:50:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前介紹 @mixin 時是以一般語言的函式做為參考進行操作，事實上 SCSS 有更符合函式定義的語法名為 @function，與 @mixin 不同的地方在於 @function 無法直接將 CSS 樣式加載至當前所在的 CSS 塊內，反而是透過 @return 將函式內處理的結果返回給呼叫的對象後續再進行相關處理，簡單來講就是 @mixin 負責包裝 CSS 樣式，而 @function 則是包裝需透過處理使之形成的有效對象，該如何透過 @function 進一步提升開發效率也就是本篇的重點。</p><h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul><li>建立函式與返回結果</li><li>添加並傳入其餘參數</li><li>添加並傳入可選參數</li><li>添加並傳入關鍵字參數</li></ul><h2 id="建立函式與返回結果"><a href="#建立函式與返回結果" class="headerlink" title="建立函式與返回結果"></a>建立函式與返回結果</h2><p>目前都是推薦使用 LibSass 做為 Sass 實現的對象，關於 LibSass 與 Dart Sass 的差別可參考我之前寫過的 <a href="https://awdr74100.github.io/2020-03-04-webpack-sassloader/#%E8%A3%9C%E5%85%85%EF%BC%9ADart-Sass-%E8%88%87-Node-Sass">文章</a>，而 LibSass 本身並沒有 <code>math.pow</code> 方法，此方法只能在 Dart Sass 的環境下使用，不如我們利用函式手刻出效果不就得了？直接來看範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@function pow(<span class="variable">$base</span>, <span class="variable">$exponent</span>) &#123;</span><br><span class="line">  <span class="variable">$result</span>: <span class="number">1</span>;</span><br><span class="line">  @<span class="keyword">for</span> <span class="variable">$var</span> from 1 through <span class="variable">$exponent</span> &#123;</span><br><span class="line">    <span class="variable">$result</span>: <span class="variable">$result</span> * <span class="variable">$base</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  @return <span class="variable">$result</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">z-index</span>: pow(<span class="number">2</span>, <span class="number">10</span>) * <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 SCSS 宣告函式可使用 <code>@function</code> 關鍵字，當產生結果時可使用 <code>@return</code> 將其返回給呼叫的對象，其實與一般語言的函式沒啥兩樣，以下為編譯結果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1024px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你是 JavaScript 的開發者，可能會嘗試使用 ES7 的指數運算符 <code>**</code> 來完成任務，在 SCSS 你不能這樣做，因為本身並沒有相關的運算符可做使用，只能依靠自己將其效果手刻出來，讓我們再來看個例子：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _variables.scss</span></span><br><span class="line"><span class="variable">$theme-colors</span>: map-merge(</span><br><span class="line">  (</span><br><span class="line">    <span class="string">'primary'</span>: <span class="number">#007bff</span>,</span><br><span class="line">    <span class="string">'secondary'</span>: <span class="number">#6c757d</span>,</span><br><span class="line">    <span class="string">'success'</span>: <span class="number">#28a745</span>,</span><br><span class="line">  ),</span><br><span class="line">  ()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// _functions.scss</span></span><br><span class="line">@function theme-color(<span class="variable">$key</span>) &#123;</span><br><span class="line">  @return map-get(<span class="variable">$theme-colors</span>, <span class="variable">$key</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: theme-color(primary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Bootstrap 的 SCSS 檔案中，你會多次看到上面這種寫法，起初我本來以為 <code>theme-color</code> 是 SCSS 內建的方法，後來才發現原來是 <code>_functions.scss</code> 這隻檔案宣告的函式阿，這時你可能會想，這樣不是多此一舉嗎？我直接使用 <code>map-get</code> 不就能取得對應的顏色了嗎？幹嘛還要使用函式方式做取得？老實講我也不太能理解這樣的處理手段，我認為這也是 <code>@function</code> 使用頻率較低的原因，畢竟 SCSS 的撰寫是以樣式為主，在這種情況下 <code>@mixin</code> 往往來的比 <code>@function</code> 更好用，且在 SCSS 不需要處理一般語言中這麼複雜的對象，<code>@function</code> 的存在也就越來越模糊。</p><h2 id="添加並傳入其餘參數"><a href="#添加並傳入其餘參數" class="headerlink" title="添加並傳入其餘參數"></a>添加並傳入其餘參數</h2><p>與 <code>@mixin</code> 處理手法相同，<code>@function</code> 同樣也可添加類似於 JavaScript 中的 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Functions/rest_parameters" target="_blank" rel="external nofollow noopener noreferrer">Rest parameter</a>，直接來看範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@function px-to-rem(<span class="variable">$sizes</span>...) &#123;</span><br><span class="line">  <span class="variable">$result</span>: ();</span><br><span class="line">  @<span class="keyword">each</span> <span class="variable">$value</span> in nth(<span class="variable">$sizes</span>, 1) &#123;</span><br><span class="line">    <span class="variable">$result</span>: append(<span class="variable">$result</span>, (<span class="variable">$value</span> / <span class="number">16px</span>) * <span class="number">1rem</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  @return <span class="variable">$result</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: px-to-rem(<span class="number">20px</span>);</span><br><span class="line">  <span class="attribute">padding</span>: px-to-rem(<span class="number">20px</span> <span class="number">16px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所謂的其餘參數就是指將未明確定義其接收變數的參數通通放在 <code>$...</code> 變數裡頭，這一個 <code>$...</code> 變數會以 List 的形式存在，接下來就看要用迴圈還是相關方法進行取用動作。</p><h2 id="添加並傳入可選參數"><a href="#添加並傳入可選參數" class="headerlink" title="添加並傳入可選參數"></a>添加並傳入可選參數</h2><p>所謂的可選參數其實就是預設參數的意思，代表應該被接收的變數就算不傳入還是可直接向預設參數取值進而避免處理時發生錯誤，直接來看例子：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@function getUrl(<span class="variable">$fileName</span>, <span class="variable">$ext</span>: <span class="string">'png'</span>) &#123;</span><br><span class="line">  <span class="variable">$baseUrl</span>: <span class="string">'/src/assets/img/'</span>;</span><br><span class="line">  @return <span class="variable">$baseUrl</span> + <span class="variable">$fileName</span> + <span class="string">'.'</span> + <span class="variable">$ext</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.logo</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(getUrl(<span class="string">'logo'</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(getUrl(<span class="string">'facebook'</span>, <span class="string">'svg'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SCSS 預設參數賦值是使用 <code>:</code> 關鍵字，就如同宣告變數一般，與一般語言中使用 <code>=</code> 關鍵字有所不同，這邊要多加留意，以下為編譯結果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.logo</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'/src/assets/img/logo.png'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'/src/assets/img/facebook.svg'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加並傳入關鍵字參數"><a href="#添加並傳入關鍵字參數" class="headerlink" title="添加並傳入關鍵字參數"></a>添加並傳入關鍵字參數</h2><p>除了基本依造順序將參數傳遞進去以外，我們也可透過關鍵字，這指接收參數的變數名稱，將參數傳遞給指定的變數，如下範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@function sqrt(<span class="variable">$str</span>: <span class="string">'undefined'</span>, <span class="variable">$num</span>: 10) &#123;</span><br><span class="line">  <span class="variable">$x0</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="variable">$x1</span>: <span class="variable">$x0</span>;</span><br><span class="line">  @<span class="keyword">for</span> <span class="variable">$i</span> from 1 through 10 &#123;</span><br><span class="line">    <span class="variable">$x1</span>: <span class="variable">$x0</span> - (<span class="variable">$x0</span> * <span class="variable">$x0</span> - abs(<span class="variable">$num</span>)) / (<span class="number">2</span> * <span class="variable">$x0</span>);</span><br><span class="line">    <span class="variable">$x0</span>: <span class="variable">$x1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  @return <span class="variable">$x1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: sqrt(<span class="variable">$num</span>: <span class="number">100</span>) * <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是蠻新奇的？以往參數都必須依照順序傳入以保證對象如預期被接收，在 SCSS 你可以不必這樣做，直接以關鍵字方式傳入參數值即可，此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>雖然說方便度提高了不少，但我認為這樣子的寫法可能存在可讀性低落的問題，你沒辦法立即得知那些參數未傳入那些參數已傳入，最後可能就會跳出錯誤。</p>]]></content>
    
    <summary type="html">
    
      之前介紹 @mixin 時是以一般語言的函式做為參考進行操作，事實上 SCSS 有更符合函式定義的語法名為 @function，與 @mixin 不同的地方在於 @function 無法直接將 CSS 樣式加載至當前所在的 CSS 塊內，反而是透過 @return 將函式內處理的結果返回給呼叫的對象後續再進行相關處理，簡單來講就是 @mixin 負責包裝 CSS 樣式，而 @function 則是包裝需透過處理使之形成的有效對象，該如何透過 @function 進一步提升開發效率也就是本篇的重點。
    
    </summary>
    
    
      <category term="SCSS" scheme="https://awdr74100.github.io/categories/SCSS/"/>
    
    
      <category term="SCSS" scheme="https://awdr74100.github.io/tags/SCSS/"/>
    
      <category term="w3HexSchool" scheme="https://awdr74100.github.io/tags/w3HexSchool/"/>
    
  </entry>
  
  <entry>
    <title>Sass / SCSS 預處理器 - @mixin 建立混入與 @include 載入混入</title>
    <link href="https://awdr74100.github.io/2020-05-30-scss-mixin-include/"/>
    <id>https://awdr74100.github.io/2020-05-30-scss-mixin-include/</id>
    <published>2020-05-30T05:11:11.000Z</published>
    <updated>2020-05-31T08:20:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>傳統在撰寫樣式表上很常發生重工的現象，雖然說作用的對象是不同的，這指 CSS 選擇器作用的目標，但無法否認確實降低了我們的開發效率，最理想的做法應該是將會重用的樣式包裝成一個物件，每當有相同樣式的撰寫需求時，只需要取用這一個物件即可達到目的，而 Sass / SCSS 正好有提供像是 @mixin 的語句，用法就類似於 Vue.js 的 mixin，只不過將其撰寫內容更改為樣式而已，最後使用 @include 載入 mixin 即可完成取用動作，藉此達到減少重工發生可能的目的。</p><h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul><li>建立混入與載入混入</li><li>添加並傳入其餘參數</li><li>添加並傳入可選參數</li><li>添加並傳入關鍵字參數</li><li>結合 @content 構建 RWD 混入</li></ul><h2 id="建立混入與載入混入"><a href="#建立混入與載入混入" class="headerlink" title="建立混入與載入混入"></a>建立混入與載入混入</h2><p>要在 SCSS 使用 mixin 相當簡單，先使用 <code>@mixin</code> 指令將其建立，如下範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> size &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣就建立好屬於我們自己的 mixin 了，接著要載入 mixin 可使用 <code>@include</code> 指令：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> size;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是相當容易？其實就只是單純把可能會重用的樣式利用 <code>@mixin</code> 將其包裝成 mixin，每當要取用時就使用 <code>@include</code> 將 mixin 的樣式附加在當前的區塊內，讓我們來看更實際的案例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> clearfix &#123;</span><br><span class="line">  &amp;::after &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> clearfix;</span><br><span class="line"></span><br><span class="line">  &amp;__item &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list__item</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以往我們都得在各別的 float 父元素添加 clearfix 樣式，現在使用 SCSS 中的 mixin 即可快速的產生清除樣式，這邊做個強調，<strong>mixin 不只可以包裝 CSS 樣式，嚴格來講可以包裝 CSS 和 SCSS 中的任何有效內容</strong>，比如說 mixin 內使用 <code>@include</code> 載入另個 mixin：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> font-reset &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Arial, Helvetica, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">mixin</span> horizontal-center &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">  @<span class="keyword">include</span> font-reset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.nav</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> horizontal-center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.nav</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">  <span class="attribute">font-family</span>: Arial, Helvetica, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面所建立的 <code>@mixin</code> 都是屬於無參數型的 mixin，我們可透過大括號將參數傳遞進去使之成為參數型 <code>@mixin</code>，先將上面範例做一個改寫：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> size() &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>與一般語言中的函式類似，函式名稱旁都有個小括號可帶入參數，這邊你可以先把 mixin 理解為一般語言中的函式，但不要直接把他認知成函式，雖然這樣講有點矛盾，因為 SCSS 確實還有另個 <code>@function</code> 方法更貼近於函式，這點以後再做討論，在 <code>@mixin</code> 新增接收參數的變數並傳入參數：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> size(<span class="variable">$num1</span>, <span class="variable">$num2</span>) &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$num1</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="variable">$num2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> size(<span class="number">200px</span>, 200px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這應該蠻好理解的，就只是將 mixin 內宣告的變數進行使用，最後 <code>@include(num1, num2)</code> 的結果就會是相對應處理後的結果，如同一般語言中函式的處理方式。</p><h2 id="添加並傳入其餘參數"><a href="#添加並傳入其餘參數" class="headerlink" title="添加並傳入其餘參數"></a>添加並傳入其餘參數</h2><p>每當我們要傳入參數時，mixin 就必須要有對應的變數已接收此參數，這樣不是很麻煩嗎？有沒有辦法是直接在 mixin 定義一個能接收全部參數的變數呢？答案是有的，概念類似於 JavaScript 中的 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Functions/rest_parameters" target="_blank" rel="external nofollow noopener noreferrer">Rest parameter</a>，直接來看範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> size(<span class="variable">$num1</span>, <span class="variable">$num</span>...) &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$num1</span>;</span><br><span class="line">  <span class="attribute">height</span>: inspect(<span class="variable">$num</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> size(<span class="number">100</span>, 200, 300);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了指定參數 <code>$num1</code> 所接受到的數值外，其餘都屬於 <code>$num</code> 的部分，所得到的資料型態會以 List 表示，結果如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200</span>, <span class="number">300</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面主要為示範才會使用 <code>inspect</code> 函式，正確的做法應該是使用 <code>nth</code> 取出 List 對應的值才對：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> size(<span class="variable">$num1</span>, <span class="variable">$num</span>...) &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$num1</span>;</span><br><span class="line">  <span class="attribute">height</span>: nth(<span class="variable">$num</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="attribute">font-weight</span>: nth(<span class="variable">$num</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> size(<span class="number">100</span>, 200, 300);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能會覺得與 JavaScript 將 <code>...</code> 放在變數前面有所出入，SCSS 是將 <code>...</code> 放在變數後面，剛開始我也不太習慣時常打錯，後來習慣後就沒這個問題了，我想可能是要區別兩者的獨特性吧？</p><h2 id="添加並傳入可選參數"><a href="#添加並傳入可選參數" class="headerlink" title="添加並傳入可選參數"></a>添加並傳入可選參數</h2><p>所謂的可選參數其實就是預設參數的意思，代表應該被接收的變數就算不傳入還是可直接向預設參數取值進而避免處理時發生錯誤，直接來看例子：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> size(<span class="variable">$num1</span>: 150px, <span class="variable">$num2</span>: 150px) &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$num1</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="variable">$num2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> size(<span class="number">120px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SCSS 預設參數賦值是使用 <code>:</code> 關鍵字，就如同宣告變數一般，與一般語言中使用 <code>=</code> 關鍵字有所不同，這邊要多加留意，以下為編譯結果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由於我們只有傳入 <code>$num1</code> 參數的內容，故 <code>$num2</code> 就會使用預設的參數值做處理，而 <code>$num1</code> 則會覆蓋預設值以傳入的數值為目標完成操作。</p><h2 id="添加並傳入關鍵字參數"><a href="#添加並傳入關鍵字參數" class="headerlink" title="添加並傳入關鍵字參數"></a>添加並傳入關鍵字參數</h2><p>除了基本依造順序將參數傳遞進去以外，我們也可透過關鍵字，這指接收參數的變數名稱，將參數傳遞給指定的變數，如下範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> size(<span class="variable">$num1</span>: 150px, <span class="variable">$num2</span>: 150px) &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$num1</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="variable">$num2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> size(<span class="variable">$num2</span>: 300px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是蠻新奇的？以往參數都必須依照順序傳入以保證對象如預期被接收，在 SCSS 你可以不必這樣做，直接以關鍵字方式傳入參數值即可，此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>雖然說方便度提高了不少，但我認為這樣子的寫法可能存在可讀性低落的問題，你沒辦法立即得知那些參數未傳入那些參數已傳入，最後可能就會跳出錯誤。</p><h2 id="結合-content-構建-RWD-混入"><a href="#結合-content-構建-RWD-混入" class="headerlink" title="結合 @content 構建 RWD 混入"></a>結合 @content 構建 RWD 混入</h2><p><code>@mixin</code> 最常被用來包裝 RWD (Responsive Web Design) 的 <code>@media</code> 以解決 media queries 重複撰寫問題，先來看傳統上我們是怎麼撰寫 RWD 的：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.col-md-4</span>,</span><br><span class="line"><span class="selector-class">.col-md-6</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: 768px) &#123;</span><br><span class="line">  <span class="selector-class">.col-md-4</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> (<span class="number">100%</span> * <span class="number">4</span>/<span class="number">12</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.col-md-6</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> (<span class="number">100%</span> * <span class="number">6</span>/<span class="number">12</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我習慣將 RWD 代碼撰寫在樣式表的尾端以方便做管理，但這有一個問題是，假如我們的代碼量很龐大呢？豈不是要在每次撰寫時都得滑個老半天？且之前就有提到 SCSS 主要解決我們重工的問題，如果其他的 <a href="https://sass-lang.com/guide#topic-4" target="_blank" rel="external nofollow noopener noreferrer">Partials</a> 也要使用的話不就又造成重工的問題了嗎？這時我們可利用前面學到的 <code>@mixin</code> 將 <code>@media</code> 包裝起來：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> pad(<span class="variable">$col</span>) &#123;</span><br><span class="line">  @<span class="keyword">media</span> screen and (min-width: 768px) &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> (<span class="number">100%</span> * <span class="variable">$col</span>/<span class="number">12</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-md-4</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">  @<span class="keyword">include</span> pad(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-md-6</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">  @<span class="keyword">include</span> pad(<span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.col-md-4</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.col-md-4</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">33.33333%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-md-6</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.col-md-6</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">50%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊你可能會對 <code>@mixin</code> 與 <code>@media</code> 的結合感到困惑，為何 <code>@media</code> 會自動跳脫到外層呢？當時的我也感到困惑，後來看到官方的 <a href="https://sass-lang.com/documentation/at-rules/css" target="_blank" rel="external nofollow noopener noreferrer">CSS At-Rules</a> 發現這其實是 SCSS 其中一種處理方式，你可以嘗試編譯下面範例看看：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.print-only</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line"></span><br><span class="line">  @<span class="keyword">media</span> print &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>編譯器對 @media 的巢狀結構處理是將其跳脫到外層去</strong>，畢竟沒有人會將 CSS 寫做 <code>.print-only @media</code>，這才導致這樣子的結果，這也是前面 RWD 能夠結合 <code>@mixin</code> 的關鍵，是不是覺得這樣子清楚許多？但在這邊還有一個小問題是，目前都是依靠參數去做響應變化，參數一多容易造成可讀性低落問題，比較好的做法是使用 <code>@content</code> 才對：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> pad &#123;</span><br><span class="line">  @<span class="keyword">media</span> screen and (min-width: 768px) &#123;</span><br><span class="line">    @<span class="keyword">content</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-md-4</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">  @<span class="keyword">include</span> pad &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> (<span class="number">100%</span> * <span class="number">4</span>/<span class="number">12</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-md-6</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">  @<span class="keyword">include</span> pad &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> (<span class="number">100%</span> * <span class="number">6</span>/<span class="number">12</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.col-md-4</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.col-md-4</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">33.33333%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-md-6</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.col-md-6</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">50%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>與前面使用參數傳遞的結果相同，但靈活度卻提高了不少，事實上 <code>@include</code> 還可以透過大括號進行傳遞，而 <code>@mixin</code> 則是透過 <code>@content</code> 接收，我自己是蠻常使用此方式撰寫 RWD，不覺得這樣直覺多了嗎？雖然說編譯後會產生多餘的代碼，但以開發體驗來說，我認為完全是不同等級的，這邊做個最後的補充：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> hamburger &#123;</span><br><span class="line">  <span class="selector-class">.open</span> &amp; &#123;</span><br><span class="line">    @<span class="keyword">content</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.menu</span> &#123;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">0px</span>;</span><br><span class="line">  @<span class="keyword">include</span> hamburger &#123;</span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">300px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>還記得之前介紹的 <code>&amp;</code> 父選擇器搭配 hamburger menu 範例嗎？我們同樣可把它包裝成 <code>@mixin</code> 並搭配 <code>@content</code> 使之更具靈活度，可以參考上面範例。</p>]]></content>
    
    <summary type="html">
    
      傳統在撰寫樣式表上很常發生重工的現象，雖然說作用的對象是不同的，這指 CSS 選擇器作用的目標，但無法否認確實降低了我們的開發效率，最理想的做法應該是將會重用的樣式包裝成一個物件，每當有相同樣式的撰寫需求時，只需要取用這一個物件即可達到目的，而 Sass / SCSS 正好有提供像是 @mixin 的語句，用法就類似於 Vue.js 的 mixin，只不過將其撰寫內容更改為樣式而已，最後使用 @include 載入 mixin 即可完成取用動作，藉此達到減少重工發生可能的目的。
    
    </summary>
    
    
      <category term="SCSS" scheme="https://awdr74100.github.io/categories/SCSS/"/>
    
    
      <category term="SCSS" scheme="https://awdr74100.github.io/tags/SCSS/"/>
    
  </entry>
  
  <entry>
    <title>Sass / SCSS 預處理器 - @if、@else if 條件判斷與 @for、@each 迴圈處理</title>
    <link href="https://awdr74100.github.io/2020-05-26-scss-conditions-loops/"/>
    <id>https://awdr74100.github.io/2020-05-26-scss-conditions-loops/</id>
    <published>2020-05-26T12:15:42.000Z</published>
    <updated>2020-05-27T17:13:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>雖然說撰寫樣式表其複雜性遠遠低於一般的主流程式語言，但無法否認在某些時候我們確實需要更高效的做法來達到目的，迴圈處理就是個很好的例子，傳統 CSS 撰寫樣式必定是透過手動輸入的方式來完成，而 Sass / SCSS 提供了像是 @for、@each、@while 語句，讓我們透過迴圈的方式快速產出樣式，藉此達到高效開發的目的，其中也包含像是 @if、@else if 等條件判斷式，可根據其判斷輸出不同的樣式，讓我們在較複雜的情境依然能夠保持其樣式表的靈活度。</p><h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul><li>條件判斷式與邏輯運算子</li><li>迴圈處理與實際應用</li></ul><h2 id="條件判斷式與邏輯運算子"><a href="#條件判斷式與邏輯運算子" class="headerlink" title="條件判斷式與邏輯運算子"></a>條件判斷式與邏輯運算子</h2><p>像是 <code>if</code>、<code>else if</code> 這種條件判斷式有接觸過任一程式語言的人應該都很熟悉了才對，能夠幫助我們依造判斷的結果選用不同的內容，讓我們直接來看範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$device</span>: mobile;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$device</span> == desktop &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.5rem</span>;</span><br><span class="line">  &#125; @<span class="keyword">else</span> if <span class="variable">$device</span> == pad &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.25rem</span>;</span><br><span class="line">  &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1rem</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就如同一般程式語言的條件判斷式寫法，這應該蠻好理解的，但這邊要注意 SCSS 並未提供像是 <code>switch</code> 等語句，僅提供以下條件判斷式語句：</p><ul><li><code>@if</code>：如果為 <code>true</code>，則該塊被運行</li><li><code>@else</code>：跟隨 <code>@if</code> 規則，如果為 <code>false</code>，則該塊被運行</li><li><code>@else if</code>：在 <code>@else</code> 評估其規則，運作如同 <code>@if</code></li></ul><p>與 Python 類似，僅提供以上三種判斷式語句，且比對的方法也幾乎差不多，如果你是 JavaScript 的開發者，應該很常使用像是 <code>===</code> 進行比對，在 SCSS 你不必這樣做，也不能這樣做，只需要撰寫傳統的 <code>==</code>、<code>!=</code>、<code>&gt;=</code> 比較其目標即可，這邊針對邏輯運算子做個補充：</p><ul><li><code>and</code>：兩個運算式都是 <code>true</code> 時才會回傳 <code>true</code></li><li><code>or</code>：兩個運算式有任一個是 <code>true</code> 時就會回傳 <code>true</code></li><li><code>not</code> 反轉運算式結果</li></ul><p>一樣與 Python 類似，其邏輯判斷子都變得更為直接，這邊我們再來看個範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$primary</span>: rgb(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  @<span class="keyword">if</span> (<span class="variable">$primary</span> == black and <span class="variable">$primary</span> == <span class="number">#000000</span>) &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$primary</span>;</span><br><span class="line">  &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般對於這種邏輯運算子不外乎就是比較字串或數值之間的關係，在 SCSS 定義了像是 <code>#000000</code> 顏色的型態，我們可透過相同方式比較顏色之間的關係，當初看到也覺得很新奇，居然連顏色也可以比較，雖然使用頻率可能未必來的比基本型態高，但確實在某些時候可能能夠帶來關鍵性的作用。</p><h2 id="迴圈處理與實際應用"><a href="#迴圈處理與實際應用" class="headerlink" title="迴圈處理與實際應用"></a>迴圈處理與實際應用</h2><p>接下來進入到迴圈處理的環節，在這邊要先強調，SCSS 並未像一般程式語言需處理各種複雜的情境，為了方便開發者的處理流程，進而衍伸出像是 JavaScript 中的 <code>for in</code>、<code>for of</code> 等方法，這些東西在 SCSS 都不存在，SCSS 就只有提供像 <code>@for</code>、<code>@each</code>、<code>@while</code> 等基本迴圈處理方法，畢竟需求很單純，這點在下面會在做說明，讓我們先從 <code>@for</code> 開始介紹：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">for</span> <span class="variable">$var</span> from 1 to 3 &#123;</span><br><span class="line">  <span class="selector-class">.mt-</span>#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="variable">$var</span> * <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊的 <code>$var</code> 就類似於 JavaScript 中用 <code>let</code> 宣告的變數，區塊外是讀不到這個變數的，其他字詞的解釋如下：</p><ul><li><code>start</code>：迴圈的起始值，這裡為 <code>1</code></li><li><code>end</code>：迴圈的結束值，這裡為 <code>3</code></li><li><code>to</code>：處理方式為 <code>start &lt; end</code>，不包含迴圈的結束值</li><li><code>through</code>：處理方式為 <code>start &lt;= end</code>，包含迴圈的結束值</li></ul><p>如同上面解釋，使用 <code>to</code> 的話迴圈只會跑兩次，我們想要跑三次，故這邊使用 <code>through</code> 來進行：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">for</span> <span class="variable">$var</span> from 1 through 3 &#123;</span><br><span class="line">  <span class="selector-class">.mt-</span>#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="variable">$var</span> * <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊還有一點要注意，在之前我們有提到在某些時候 SCSS 無法辨認其值是屬於需解析的變數還是預設的屬性值，其中的屬性值也有可能是字串，以上面範例來說，當我們把 <code>$var</code> 寫在 class 名稱時，就會產生此問題，解決辦法如之前，使用 <code>#{}</code> 將變數包裝起來即可，讓我們來看最後的編譯結果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mt-1</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.mt-2</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.mt-3</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用迴圈處理，我們就能快速產生需要的樣式，這樣子的結果就如同 Bootstrap 中的 Spacing 處理一般，大幅提高了其開發效率，讓我們在試一次：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$list</span>: red blue black;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">for</span> <span class="variable">$var</span> from 1 through length(<span class="variable">$list</span>) &#123;</span><br><span class="line">  <span class="selector-class">.text-</span>#&#123;nth(<span class="variable">$list</span>,<span class="variable">$var</span>)&#125; &#123;</span><br><span class="line">    <span class="attribute">color</span>: nth(<span class="variable">$list</span>, <span class="variable">$var</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這也是我們在撰寫一般程式語言最常用到的迴圈處理，利用迴圈產生數值進而取出陣列中的值，但在這邊我不太推薦以 <code>@for</code> 下去做，從編譯結果就可以得知：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text-red</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-blue</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-black</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般我們不會取作像 <code>.text-blue</code> 這樣的 class 名稱，如果其樣式顏色做了更改，這會導致名稱與內容不相符的狀況，搞的很詭異，盡量都是以工具性質去做命名，不要以語意化方式命名，這時就是 <code>maps</code> 出場的時候了：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$theme-colors</span>: (</span><br><span class="line">  primary: <span class="number">#0000ff</span>,</span><br><span class="line">  success: <span class="number">#008000</span>,</span><br><span class="line">  warning: <span class="number">#ffff00</span>,</span><br><span class="line">  danger: <span class="number">#ff0000</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>maps</code> 型態就如同一般語言的 Object，關於 <code>maps</code> 的介紹可參考上一篇文章，一般語言如果要遍歷 Object 可使用 <code>for in</code> 語句，但 SCSS 並沒有 <code>for in</code> 語句，取而代之的是 <code>@each</code> 語句，如下範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$theme-colors</span> &#123;</span><br><span class="line">  <span class="selector-class">.text-</span>#&#123;<span class="variable">$key</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊的 <code>@each</code> 就類似於 Python 的 <code>for in</code> 語句，我個人是把它記成 JavaScript 中 <code>for of</code> 結合 <code>Object.entries()</code> 並搭配解構的處理方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// primary</span></span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 0000ff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果將被賦值的兩個變數更改為一個，此時這一個變數拿到的就是單獨的 List 物件，你可以從 JavaScript 解構的方向去思考，更可以直接拿掉 <code>$value</code> 變數，直接讀取 <code>$key</code> 變數看看，這個變數就會得到 <code>iterator</code> 的結果，讓我們來看最後的編譯結果為何：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0000ff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-success</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#008000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-warning</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ffff00</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-danger</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有沒有似曾相似的感覺？沒錯，Bootstrap 中的主題顏色就是依靠此方式生成的，可以參考 <a href="https://github.com/twbs/bootstrap/blob/master/scss/_variables.scss" target="_blank" rel="external nofollow noopener noreferrer">官方文檔</a>，其中也包含像 <code>.bg-primary</code>、<code>btn-primary</code> 等樣式，原理都是一模一樣的，相比於傳統 CSS 依靠手動方式撰寫樣式，使用 SCSS 能夠快速並符合結構化方式自動生成樣式，這也是為什麼 SCSS 越來越火紅的原因，這個坑跳了就不想回去了，最後來介紹 <code>@while</code> 迴圈處理語句：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$num</span>: <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">while</span> <span class="variable">$num</span> &lt;= 3 &#123;</span><br><span class="line">  <span class="selector-class">.pt-</span>#&#123;<span class="variable">$num</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="variable">$num</span> * <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable">$num</span>: <span class="variable">$num</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就如同一般語言的 <code>while</code> 語句，透過 <code>true</code> 或 <code>false</code> 控制迴圈流程，我比較不建議使用 <code>@while</code> 來處理迴圈，就連官方自己也說除非是特別複雜的情境，不然盡量不要使用 <code>@while</code> 語句，易造成可讀性低落的問題，更好的選擇應該是 <code>@for</code> 或 <code>@each</code> 才對。</p>]]></content>
    
    <summary type="html">
    
      雖然說撰寫樣式表其複雜性遠遠低於一般的主流程式語言，但無法否認在某些時候我們確實需要更高效的做法來達到目的，迴圈處理就是個很好的例子，傳統 CSS 撰寫樣式必定是透過手動輸入的方式來完成，而 Sass / SCSS 提供了像是 @for、@each、@while 語句，讓我們透過迴圈的方式快速產出樣式，藉此達到高效開發的目的，其中也包含像是 @if、@else if 等條件判斷式，可根據其判斷輸出不同的樣式，讓我們在較複雜的情境依然能夠保持其樣式表的靈活度。
    
    </summary>
    
    
      <category term="SCSS" scheme="https://awdr74100.github.io/categories/SCSS/"/>
    
    
      <category term="SCSS" scheme="https://awdr74100.github.io/tags/SCSS/"/>
    
  </entry>
  
  <entry>
    <title>Sass / SCSS 預處理器 - Variables 變數宣告與 !global、!default 標誌定義</title>
    <link href="https://awdr74100.github.io/2020-05-25-scss-variables/"/>
    <id>https://awdr74100.github.io/2020-05-25-scss-variables/</id>
    <published>2020-05-24T16:32:34.000Z</published>
    <updated>2020-05-26T11:38:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先前我們就有提到 Sass / SCSS 真正意義上的將樣式表變為了一門程式語言，即 SassScript，而身為程式語言，想當然就會有所謂的變數可以使用，這也是我跳坑的其中一個原因，你能想像樣式表居然能夠使用變數做撰寫嗎？這指的變數與其他語言差不多，同樣有分為字串、陣列、物件等型態可做使用，大幅提高了代碼的重用性，以後如有更改的需求，也只需針對變數做處理即可，改善傳統樣式表不易維護問題。</p><h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul><li>變數的宣告與取用</li><li>!global、!default 標誌定義</li><li>Sass 的計算功能</li><li>Sass 的內建函式</li></ul><h2 id="變數的宣告與取用"><a href="#變數的宣告與取用" class="headerlink" title="變數的宣告與取用"></a>變數的宣告與取用</h2><p>Sass / SCSS 變數的宣告主要依靠 <code>$</code> 關鍵字，並且依造屬性聲明來做撰寫，其中的資料型態有：</p><ul><li>數值 (Number)：<code>12</code>、<code>100px</code> (可能有或沒有單位)</li><li>字串 (String)：<code>Microsoft JhengHei</code> (可能有或沒有引號)</li><li>顏色 (Color)：<code>blue</code>、<code>#4cb5fc</code>、<code>hsl(204, 97%, 64%)</code></li><li>列表 (List)：<code>0 0.5rem 1rem #0000ff</code>、<code>Helvetica, Arial, sans-serif</code></li><li>地圖 (Maps)：<code>(primary: blue, danger: red)</code></li><li>布林 (Boolean)：<code>true</code>、<code>false</code></li><li>空值 (Null)：<code>null</code></li><li>函式參考 (Function references)：可參考 <a href="https://sass-lang.com/documentation/values" target="_blank" rel="external nofollow noopener noreferrer">官方文檔</a> 說明</li></ul><p>這邊比較特別就是 Maps 這個資料型態，其實它就類似 JavaScript 中的 Object，只不過將其 <code>{}</code> 換成 <code>()</code> 而已，下面會再做示範，讓我們先來看以下範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$primary</span>: <span class="number">#2050ec</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有關變數的取用應該是蠻好理解的，就只是將其宣告在上方並在指定位置進行取用而已，這邊要注意的是，<strong>SCSS 中的變數就如同 JavaScript 用 let 宣告的變數</strong>，這也代表著變數必定要在取用之前進行宣告，不然會跳出 <code>Undefined</code> 的錯誤，此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#2050ec</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>數值、字串、顏色取用過程幾乎差不多，這邊就不再做示範，比較有疑問的可能是 List 這型態，其實它就類似一般所謂的 Array，如下範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sizes</span>: <span class="number">10px</span> <span class="number">20px</span> <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.p-5</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="variable">$sizes</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>List 是在 SCSS 中用來表達 CSS 樣式的方法，像是 <code>10px 20px 10px 20px</code> 或 <code>Helvetica, Arial</code> 等，並不一定要像一般 Array 需用逗號隔開以辨識每一個項目，在 List 你也可以使用空格做區隔，如果要取用其中的項目，可使用內建的 <code>nth</code> 函式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sizes</span>: <span class="number">10px</span> <span class="number">20px</span> <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.pt-5</span> &#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: nth(<span class="variable">$sizes</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.pt-5</span> &#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>List 的初始值即為 1，並不像一般語言中的 Array 初始值為 0</p><p><code>nth</code> 函式的第一個參數為作用的 List，第二個為取用的位置，這邊比較特殊的是，<strong>List 的初始值即為 1，並不像一般語言中的 Array 為 0</strong>，以及所有的函式都是作用在 List 的副本，這代表原有的 List 不會受任何更動，除了 <code>nth</code> 之外，還有以下函式可使用：</p><ul><li><code>set-nth($list, $n, $value)</code>：修改 List 副本的指定項目並返回</li><li><code>append($list, $value)</code>：在 List 副本最後位置新增項目並返回</li><li><code>join($list1, $list2)</code>：將 List 副本進行合併並返回</li><li><code>length($list)</code>：計算 List 長度並返回</li></ul><p>這邊只列出幾個比較常用到的函式，其它函式可在至官方的 <a href="https://sass-lang.com/documentation/modules/list" target="_blank" rel="external nofollow noopener noreferrer">Built-In Modules</a> 文檔進行查看，接著讓我們來看 Maps 型態：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$theme-colors</span>: (</span><br><span class="line">  primary: blue,</span><br><span class="line">  danger: red,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bg-primary</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="variable">$theme-colors</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Maps 就如同 JavaScript 的 Object，只不過須將其 <code>{}</code> 更改為 <code>()</code>，且 Maps 無法直接進行取用，像是上面這樣子的寫法就是錯誤的，沒有任何一個 CSS 屬性有這樣子的格式，故編譯時即會跳錯，如果你想讓編譯器堅持輸出 Maps 的內容，可使用 <code>inspect</code> 函式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$theme-colors</span>: (</span><br><span class="line">  primary: blue,</span><br><span class="line">  danger: red,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bg-primary</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: inspect(<span class="variable">$theme-colors</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>inspect</code> 就類似 JavaScript 中的 <code>console.log</code>，主要都是用於輸出指定的對象，方便我們測試用，此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bg-primary</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: (primary: blue, danger: red);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如同我們前面所說，沒有半個 CSS 屬性格式是長這樣，正確的做法應該是讀取其鍵以取用其值才對，此時可使用 <code>map-get</code> 函式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$theme-colors</span>: (</span><br><span class="line">  primary: blue,</span><br><span class="line">  danger: red,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bg-primary</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: map-get(<span class="variable">$theme-colors</span>, primary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map-get</code> 主要用來取用 Maps 的內容，第一個參數為作用的 Maps，第二個參數為須取用值的鍵，此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bg-primary</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣就能完成像是一般語言取用物件的目的，除了 <code>map-get</code> 之外，還有以下函式可使用：</p><ul><li><code>map-merge($map1, $map2)</code>：將 map 副本進行合併並返回 (如有重複項，後者將覆蓋前者)</li><li><code>map-remove($map, $key1, $key2...)</code>：刪除 map 副本中的指定項目並返回</li><li><code>map-keys($map)</code>：將 map 中的鍵以 List 型式返回</li><li><code>map-values($map)</code>：將 map 中的值以 List 型式返回</li></ul><p>這時你可能會想，List 與 Maps 實用性看起來好像不高？光是取個值就得大費周章，那是因為我們還沒提到迴圈的使用，這兩個型別通常都是與迴圈共同使用才能發揮其強大，在下一篇文章會有詳細的介紹，這邊先寫個簡單的範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$theme-colors</span>: (</span><br><span class="line">  primary: blue,</span><br><span class="line">  danger: red,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$theme-colors</span> &#123;</span><br><span class="line">  <span class="selector-class">.text-</span>#&#123;<span class="variable">$key</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-danger</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="global、-default-標誌定義"><a href="#global、-default-標誌定義" class="headerlink" title="!global、!default 標誌定義"></a>!global、!default 標誌定義</h2><p>SCSS 的變數與一般語言的變數同樣都有作用範圍之分，直接來看範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$primary</span>: blue;</span><br><span class="line"><span class="variable">$primary</span>: red;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我們有提到 SCSS 的變數就如同 JavaScript 用 <code>let</code> 宣告的變數，與 <code>const</code> 宣告的常數不同，<code>let</code> 宣告的變數可以被重新賦值，此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重複的變數宣告就如同重新賦值，這才導致此結果，只要記住 SCSS 是由上到下進行編譯就很好理解了，讓我們來看下個範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$primary</span>: blue;</span><br><span class="line"><span class="variable">$primary</span>: red !default;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這次我們加入了 <code>!default</code> 標誌，此標誌可針對變數設定預設值，如變數前或後都沒有重新賦值的發生，即使用此預設值，此時的編譯結果為：</p><div class="note warning">補充：除非變數前的設定值為 null，不然預設值的權重必定是最小的，任何都能將其覆蓋</div><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由於 <code>$primary</code> 發生了重新賦值的操作，故使用預設值除外的設定值，如果同時發生預設值之前之後都有設定值，此時會使用之後的設定值，因為 SCSS 是由上到下進行編譯的，讓我們來看下個範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="variable">$primary</span>: red;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bg-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>變數不只可以宣告在全域環境 (不在任何大括號內宣告之變數)，也可以宣告在區域環境 (大括號內所宣告之變數)，以上面範例來說，<code>.bg-primary</code> 是存取不到 <code>$primary</code> 這個區域變數的，此時會跳 <code>Undefined</code> 的提示，如果堅持要存取這個變數，可使用 <code>!global</code> 標誌：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="variable">$primary</span>: red !global;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bg-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時 <code>$primary</code> 變數就會被拉升到全域環境內，意即不再任何大括號宣告之變數，<code>.bg-primary</code> 自然就能夠取用這個變數，這邊再補充一個範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="variable">$primary</span>: red;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary</span>;</span><br><span class="line"></span><br><span class="line">  &amp;__item &#123;</span><br><span class="line">    <span class="variable">$primary</span>: blue !global;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$primary</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如同 JavaScript 的作用域觀念，變數取用會先以當下區域進行尋找，如果找不到再往上層尋找，以上面的範例來說，<code>list__item</code> 宣告的 <code>$primary</code> 變數被拉升到了全域環境裡，表示區域已經不存在變數，故往上層尋找是否存在此變數，此時找到了值為 <code>red</code> 的 <code>$primary</code> 變數，最後的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list__item</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sass-的計算功能"><a href="#Sass-的計算功能" class="headerlink" title="Sass 的計算功能"></a>Sass 的計算功能</h2><p>傳統的 CSS 需要依靠其 <code>calc()</code> 函式才能完成數值加減乘除的目的，在 Sass / SCSS 中，一切似乎變得更容易了，讓我們直接來看範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$gutter-width</span>: <span class="number">30px</span>;</span><br><span class="line"><span class="variable">$grid-sum</span>: <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-4</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span> * (<span class="number">4</span> / <span class="variable">$grid-sum</span>);</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> (<span class="number">100%</span> * (<span class="number">4</span> / <span class="variable">$grid-sum</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如同我們之前所強調，Sass / SCSS 讓 CSS 真正意義上的成為了一門程式語言，而程式語言理所當然就會有數值計算的功能，不管是哪種運算方式都難不倒它，你不需要特別使用函式，如同一般語言撰寫其算式即可，此時的編譯結果為：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.col-4</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">33.33333%</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">33.33333%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了基本的加減乘除外，取餘數也難不倒它，最扯的是連顏色都可以計算：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$base</span>: <span class="number">16px</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">letter-spacing</span>: <span class="variable">$base</span> % <span class="number">6</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ff0000</span> + <span class="number">#002fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">letter-spacing</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ff2fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般的程式語言數值並不會像 SCSS 有 <code>px</code>、<code>em</code>、<code>%</code> 之分，此時如果進行運算，可能就會跳出錯誤：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span> - <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像這樣不同單位間的計算就會跳出 <code>Incompatible units</code> 的提示，導致編譯失敗，Sass / SCSS 是屬於 CSS 的預處理器，它無法像 <code>calc()</code> 函式作用在 Browser 可得知當下的數值並加以計算，盡量在撰寫時都是以同單位做計算，<code>px</code> 就對 <code>px</code>，<code>em</code> 就對 <code>em</code>，如果真的有不同單位間的計算需求，就使用 CSS3 的 <code>calc()</code> 函式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: calc(<span class="number">100%</span> - <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>並沒有說使用 Sass / SCSS 就無法撰寫 CSS 的函式，畢竟底層就是 CSS，也就不存在兼容的問題，這邊再做個非常重要的補充：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$base</span>: <span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: calc(<span class="variable">$base</span> - <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能會想，這不就是個基本的變數取用嗎？還需要特別介紹？這你就錯了，讓我們先來看編譯結果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="built_in">calc</span>($base - 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>雖然編譯是成功了，但其變數並沒有成功被解析出來，此時就會導致 CSS 無法辨認其值進而產生錯誤的問題，這也是我特別要提的點，<strong>在某些情況下，SCSS 無法辨認其值是屬於需解析的變數還是預設的屬性值</strong>，這是很麻煩的一件事，但其實不用太過擔心，這問題發生的機率非常低，通常都是在某些較為特殊的情況下才會發生，解決方式也很簡單，只需利用 SCSS 提供的 <a href="https://sass-lang.com/documentation/interpolation" target="_blank" rel="external nofollow noopener noreferrer">Interpolation</a> 方法：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$base</span>: <span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: calc(#&#123;<span class="variable">$base</span>&#125; - <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>#{}</code> 將變數給帶入，用以告知編譯器此段需進行編譯，此時的結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="built_in">calc</span>(100% - 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最後的編譯結果就會如同預期，這時你可能會問，那是否所有屬性有帶入變數的地方都使用 <code>#{}</code> 比較安全？答案是否定的，這樣會顯得代碼很雜亂，有需要再使用就好了，畢竟此問題發生的機率真的非常低。</p><h2 id="Sass-的內建函式"><a href="#Sass-的內建函式" class="headerlink" title="Sass 的內建函式"></a>Sass 的內建函式</h2><p>Sass 提供了許多內建函式，這些函式可以更快速的讓我們達到某些目的，其中包含的種類有：</p><ul><li><a href="https://sass-lang.com/documentation/modules/math" target="_blank" rel="external nofollow noopener noreferrer">sass:math</a>：提供對數值進行運算的功能</li><li><a href="https://sass-lang.com/documentation/modules/string" target="_blank" rel="external nofollow noopener noreferrer">sass:string</a>：使組合、搜索或拆分變的更加容易</li><li><a href="https://sass-lang.com/documentation/modules/color" target="_blank" rel="external nofollow noopener noreferrer">sass:color</a>：根據現有顏色生成新顏色，從而輕鬆構建主題顏色</li><li><a href="https://sass-lang.com/documentation/modules/list" target="_blank" rel="external nofollow noopener noreferrer">sass:list</a>：使你可以訪問和修改列表中的值</li><li><a href="https://sass-lang.com/documentation/modules/map" target="_blank" rel="external nofollow noopener noreferrer">sass:map</a>：可以查找、編輯地圖中指定鍵匹配的值</li><li><a href="https://sass-lang.com/documentation/modules/selector" target="_blank" rel="external nofollow noopener noreferrer">sass:selector</a>：提供對 Sass 強大選擇器引擎的訪問</li><li><a href="https://sass-lang.com/documentation/modules/meta" target="_blank" rel="external nofollow noopener noreferrer">sass:meta</a>：公開了 Sass 內部工作的細節</li></ul><p>像是之前介紹的 <code>nth</code>、<code>append</code> 這些就屬於 list 的內建函式，這邊補充關於顏色的內建函式：</p><ul><li><code>darken($color, $amount)</code>：暗化指定顏色並返回</li><li><code>lighten($color, $amount)</code>：亮化指定顏色並返回</li><li><code>invert($color)</code>：反轉指定顏色並返回</li><li><code>fade-in($color, $amount)</code>：使指定顏色更加不透明並返回 (限 0 到 1 的 Alpha 值)</li><li><code>fade_out($color, $amount)</code>：使指定顏色更加透明並返回 (限 0 到 1 的 Alpha 值)</li></ul><p>以下為範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$primary</span>: <span class="number">#0084ff</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="variable">$primary</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="variable">$primary</span>;</span><br><span class="line"></span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: darken(<span class="variable">$primary</span>, <span class="number">10%</span>);</span><br><span class="line">    <span class="attribute">border-color</span>: darken(<span class="variable">$primary</span>, <span class="number">10%</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &amp;:active &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: lighten(<span class="variable">$primary</span>, <span class="number">10%</span>);</span><br><span class="line">    <span class="attribute">border</span>: lighten(<span class="variable">$primary</span>, <span class="number">10%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#0084ff</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#0084ff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn-primary</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#006acc</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#006acc</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn-primary</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#339dff</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">#339dff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是挺方便的？我們就不需要自己慢慢的調整，通通透過內建函式即可自動判斷其目標的顏色，相關的函式還有很多，由於篇幅問題，這邊就不做一一介紹，相關連結可參考上面。</p>]]></content>
    
    <summary type="html">
    
      先前我們就有提到 Sass / SCSS 真正意義上的將樣式表變為了一門程式語言，即 SassScript，而身為程式語言，想當然就會有所謂的變數可以使用，這也是我跳坑的其中一個原因，你能想像樣式表居然能夠使用變數做撰寫嗎？這指的變數與其他語言差不多，同樣有分為字串、陣列、物件等型態可做使用，大幅提高了代碼的重用性，以後如有更改的需求，也只需針對變數做處理即可，改善傳統樣式表不易維護問題。
    
    </summary>
    
    
      <category term="SCSS" scheme="https://awdr74100.github.io/categories/SCSS/"/>
    
    
      <category term="SCSS" scheme="https://awdr74100.github.io/tags/SCSS/"/>
    
      <category term="w3HexSchool" scheme="https://awdr74100.github.io/tags/w3HexSchool/"/>
    
  </entry>
  
  <entry>
    <title>Sass / SCSS 預處理器 - Nesting 巢狀結構與 Parent 父選擇器</title>
    <link href="https://awdr74100.github.io/2020-05-21-scss-nesting/"/>
    <id>https://awdr74100.github.io/2020-05-21-scss-nesting/</id>
    <published>2020-05-20T16:29:18.000Z</published>
    <updated>2020-05-21T16:03:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一次我們已經將 SCSS 的編譯環境給建立好了，接下來讓我們正式進入到語法的章節，首先介紹的是 nesting 巢狀結構與父選擇器，巢狀結構是 Sass / SCSS 最具特色的功能之一，之前我們有提到傳統 CSS 可能會發生父對象重複撰寫的問題，為了避免汙染到其他樣式，我們必須明確地寫出父子對象的關係，搞到最後才發現浪費了許多時間，如果改使用 Sass / SCSS 中的巢狀結構語法並搭配父選擇器，不僅可解決此類問題，同時也能改善傳統樣式表可讀性低落的問題。</p><h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul><li>巢狀結構</li><li>巢狀屬性</li><li>父選擇器</li></ul><h2 id="巢狀結構"><a href="#巢狀結構" class="headerlink" title="巢狀結構"></a>巢狀結構</h2><p>讓我們先來回顧一下先前提到的問題：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你不覺得這樣子很累嗎？不寫父元素又怕會汙染到其他樣式，且也不符合近年來推崇的 <strong>DRY (Don’t Repeat Your CSS)</strong> 與 <strong>KISS (Keep It Simple Stupid)</strong> 原則，何不我們嘗試使用 SCSS 來撰寫？改寫如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: black;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: white;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很酷？最後的結果與之前相同，但可讀性提高了不少，我們可以很明確的知道元素之間的依賴關係，日後如果更換了父元素的名稱，也不需要 <code>Ctrl + D</code> 累得半死做修改，直接更改父元素的名稱，之後再重新編譯一次即可，讓我們在試一次：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line"></span><br><span class="line">  &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>撰寫的關鍵就在於元素之間是否存有依賴關係，如果有，即把子樣式撰寫在父樣式內，就等同於子對象選擇器的撰寫目的，包含全部的 CSS 選擇器，都可以去做使用，<strong>你不用把它想得太複雜，就只是把子對象改成巢狀結構而已</strong>，這邊在做個補充，假設 <code>a</code> 元素內還有 <code>span</code> 元素的樣式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line"></span><br><span class="line">  &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: red;</span><br><span class="line"></span><br><span class="line">      <span class="selector-tag">span</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">a</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊就存在一個問題了，那就是階層數可能有點太多了，存在可讀性降低、可維護性降低、渲染效率變差等問題，並不是說 3 層結構就是極限，嚴格來講應該是盡量能避免階層數過多就避免，我們可針對上面做改寫：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line"></span><br><span class="line">  &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">span</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣的寫法也可以達到同樣的選染效果，前提是 <code>a</code> 元素的同層元素中並沒有 <code>span</code> 元素，在每次撰寫樣式時，盡量去思考撰寫對象真的存在必要的依賴關係嗎，避免樣式表存在不必要的需優化及效能問題。</p><h2 id="巢狀屬性"><a href="#巢狀屬性" class="headerlink" title="巢狀屬性"></a>巢狀屬性</h2><p>在上面我們都是針對 CSS 選擇器做巢狀結構，這邊再補充一點，假如我們正在撰寫關於 <code>background</code> 或 <code>font</code> 的樣式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bg-cover</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">'..'</span>);</span><br><span class="line">  <span class="attribute">background-position</span>: center center;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.font-weight-bold</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">font-family</span>: Arial, Helvetica, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣寫確實挺正常的，但假設你是個極度追求效率的人，懶得寫這麼多的重複字樣，可以改寫如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bg-cover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: &#123;</span><br><span class="line">    image: url(<span class="string">'..'</span>);</span><br><span class="line">    <span class="attribute">position</span>: center center;</span><br><span class="line">    repeat: no-repeat;</span><br><span class="line">    size: cover;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.font-weight-bold</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: &#123;</span><br><span class="line">    size: <span class="number">1em</span>;</span><br><span class="line">    weight: bold;</span><br><span class="line">    family: Arial, Helvetica, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bg-cover</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'..'</span>);</span><br><span class="line">  <span class="attribute">background-position</span>: center center;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.font-weight-bold</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">font-family</span>: Arial, Helvetica, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很酷？我們就只需要寫一次 <code>background</code> 或 <code>font</code> 等字樣，後面在撰寫其相關屬性即可，這邊要記得加入冒號，以告知編譯器此為子屬性並不是子對象。</p><p>雖然說這樣看似的確更方便了，但我一般不太會這樣寫，巢狀結構確實有其存在的必要，提高了其撰寫樣式表的效率，但巢狀屬性就見仁見智了，我認為可能會發生可閱讀性降低的問題，我自己是不太習慣，各位可以自己評估看看。</p><h2 id="父選擇器"><a href="#父選擇器" class="headerlink" title="父選擇器"></a>父選擇器</h2><p>最後我們針對巢狀結構在做個補充，前面已經提到巢狀結構所帶來的好處了，主要解決父對象名稱大量重複的問題，但在某些情況下似乎還是無可避免，如下範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line"></span><br><span class="line">  &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">a</span>:hover &#123;</span><br><span class="line">      <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>發現問題了嗎？<code>a</code> 元素還是發生名稱重複的問題了，你可能會想，這一個 <code>:hover</code> 偽類為何不寫在 <code>a</code> 元素的下個階層呢？這樣即會導致 <code>:hover</code> 被當成子對象編譯，形成 <code>a :hover</code> 的無意義宣告，我們要的是 <code>a:hover</code> 的結果阿！此時我們就可使用 Sass / SCSS 名為父選擇器的 <code>&amp;</code> 符號解決此問題，如下範例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line"></span><br><span class="line">  &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: red;</span><br><span class="line"></span><br><span class="line">      &amp;:hover &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&amp;</code> 符號可把父對象連接在一起，類似字串相加的概念，被連接的對象編譯的階層就會與父對象同層，此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大功告成！看起來代碼的簡潔性又提升了不少，讓我們在試一次：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line"></span><br><span class="line">  &amp;__item &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line"></span><br><span class="line">    &amp;--active &#123;</span><br><span class="line">      <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這是一個基本的 <a href="http://getbem.com/" target="_blank" rel="external nofollow noopener noreferrer">BEM</a> 結構，這邊先不用理解 BEM 是什麼，之後會有單獨的文章做介紹，此時的編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list__item</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list__item--active</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由於 <code>&amp;__item</code> 與 <code>&amp;--active</code> 都使用了父選擇器，故最後的編譯結果就都與 <code>.list</code> 同階層，這應該蠻好理解的，在實務中，我也很常使用此技法來撰寫樣式，可有效提升其閱讀性，這邊要注意，前面都是將 <code>&amp;</code> 放置在 CSS 選擇器之前，你也可以把它放在 CSS 選擇器之後：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.menu</span> &#123;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">0px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.open</span> &amp; &#123;</span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">300px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>編譯結果為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.menu</span> &#123;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.open</span> <span class="selector-class">.menu</span> &#123;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是覺得很熟悉？這不就是 hamburger menu 的手法嗎？以往我們都得在額外區塊撰寫樣式，現在利用 <code>&amp;</code> 即可輕鬆完成任務，且很明顯的可以看出兩者是有其關聯性的，並不像之前散落在各自的區塊上。</p>]]></content>
    
    <summary type="html">
    
      上一次我們已經將 SCSS 的編譯環境給建立好了，接下來讓我們正式進入到語法的章節，首先介紹的是 nesting 巢狀結構與父選擇器，巢狀結構是 Sass / SCSS 最具特色的功能之一，之前我們有提到傳統 CSS 可能會發生父對象重複撰寫的問題，為了避免汙染到其他樣式，我們必須明確地寫出父子對象的關係，搞到最後才發現浪費了許多時間，如果改使用 Sass / SCSS 中的巢狀結構語法並搭配父選擇器，不僅可解決此類問題，同時也能改善傳統樣式表可讀性低落的問題。
    
    </summary>
    
    
      <category term="SCSS" scheme="https://awdr74100.github.io/categories/SCSS/"/>
    
    
      <category term="SCSS" scheme="https://awdr74100.github.io/tags/SCSS/"/>
    
  </entry>
  
  <entry>
    <title>Sass / SCSS 預處理器 - 基本介紹與編譯環境建立</title>
    <link href="https://awdr74100.github.io/2020-05-18-scss-install/"/>
    <id>https://awdr74100.github.io/2020-05-18-scss-install/</id>
    <published>2020-05-18T12:56:33.000Z</published>
    <updated>2020-05-20T10:53:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前介紹的各種前端工具中，都是使用 SCSS 最為樣式表的開發對象，原因很簡單，那就是它大幅加強了 CSS 對各種操作的支持，以往我們會認為 CSS 語法很單調，但也因為太單調，導致存在許多操作上的不便，現在我們有了 Sass / SCSS 等 CSS 預處理器可以選擇，真正意義上的將樣式表變為一門程式語言，可使用變數、函式、迴圈等程式語言基本就具備的功能達到撰寫樣式表的目的。此篇將從何謂 CSS 預處理器開始介紹，接著說明 Sass / SCSS 該如何透過相關工具使之編譯成 CSS 跑在瀏覽器上。</p><h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul><li>什麼是 CSS 預處理器？</li><li>Sass 和 SCSS 有什麼區別？</li><li>編譯環境建立 - 使用官方 sass 套件</li><li>編譯環境建立 - 使用 VSCode 的 Live Sass Compiler 套件</li><li>編譯環境建立 - 使用 gulp-sass 套件</li><li>編譯環境建立 - 使用 sass-loader 套件</li></ul><h2 id="什麼是-CSS-預處理器？"><a href="#什麼是-CSS-預處理器？" class="headerlink" title="什麼是 CSS 預處理器？"></a>什麼是 CSS 預處理器？</h2><p>讓我們先來看傳統的 CSS 樣式表：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.menu</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.menu</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.menu</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.menu</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是都有過類似的經驗？有時候為了避免樣式汙染到全域環境，我們會藉由 CSS 的子對象選擇器來完成指定，但此時你會發現大部分的時間都耗費在了父對象的撰寫上，不覺得這樣很浪費時間嗎？如果能在不修改 CSS 選擇器達到樣式名稱不重複效果該有多好呢？讓我們來看下個例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#2e2ecf</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#2e2ecf</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#2e2ecf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這也是很常見的案例，在多個元素中套用了相同的樣式，假入我們今天要修改網站統一的樣式呢？我以前的做法是先選取 <code>#2e2ecf</code> 對象，之後 <code>Ctrl + D</code> 一路給他按下去，最後統一做修改，但這時會遇到的問題是，有些 <code>#2e2ecf</code> 對象我可不想做修改阿！如果不小心修改到，還得使用 <code>Ctrl + Z</code> 進行回復，想想就覺得麻煩，如果能像一般程式語言設置一個變數，之後只需要針對這個變數做修改，該有多好呢？讓我們來看下個例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-danger</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-warning</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有時為了符合 <a href="http://oocss.org/" target="_blank" rel="external nofollow noopener noreferrer">OOCSS</a> 的概念，我們會撰寫專門用於外觀的樣式，達到結構與樣式分離的效果，但單純用 CSS 來完成的話，真的是挺累人的，結構的名稱你都必須自己手打出來，如果能使用類似迴圈的語法將歸納在陣列的樣式給讀取出來，這該有多好呢？</p><p>經過了以上種種的問題，我們可以歸咎出一個結論，那就是 CSS 的撰寫方式實在是太單調了，單調對於初學者來說確實是好事，只需要記住幾個原則，即可快樂的進行開發，但相對的隨著你的程度提升，當你開發較有規模的專案時，就會顯得 CSS 綁手綁腳，永遠都只有那一套規則，缺少了程式語言那靈活的操作，此時 CSS 預處理器因此而誕生。</p><p>簡單來講，CSS 預處理器是一個須透過編譯器使之編譯成 CSS 的程式語言，有沒有發現到關鍵字？程式語言！CSS 預處理器就是一門程式語言，我們可以使用程式語言的特性來完成撰寫樣式表的目的，簡直完美，且最後編譯出來的檔案就是 CSS，也不存在所謂 Browser 不支援此語言的問題，</p><p>到這邊，你只需要對 CSS 預處理器有一個基本認知就是它是程式語言，這樣就好，讓我們繼續看下去。</p><h2 id="Sass-和-SCSS-有什麼區別？"><a href="#Sass-和-SCSS-有什麼區別？" class="headerlink" title="Sass 和 SCSS 有什麼區別？"></a>Sass 和 SCSS 有什麼區別？</h2><p>目前我們已經知道 CSS 預處理器是什麼東西了，但它總該有個對象名稱吧？沒錯，CSS 預處理器只是個統稱，目前常見的 Sass / SCSS、Less、Stylus 等，這些都是所謂的 CSS 預處理器，那這時你可能就會問了，我該選擇哪一個 CSS 預處理器？你可以反問你自己，你看過哪一個 CSS 預處理器？是不是只有 Sass / SCSS 這個選項？目前 Sass / SCSS 也是最紅的，比例非常的懸殊，我也推薦你直接學 Sass / SCSS，那這邊就又有一個問題了，Sass 與 SCSS 是一樣的東西嗎？感覺他們好像常常被混為一談？</p><p>Sass / SCSS 本質上是一樣的東西，差別在於其兩者語法結構的不同，讓我們直接來看範例：</p><ul><li>SCSS 語法結構：</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Sass 語法結構：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.list</span><br><span class="line">  display: flex</span><br></pre></td></tr></table></figure><p>SCSS 是較新的版本 (<code>Sassy CSS</code>、<code>Sass 3</code>、副檔名為 <code>*.scss</code>)，Sass 是較舊的版本 (如同 <code>HTML</code> 的 <code>Pug</code> 預處理器，具備不使用大括弧格式、使用縮排，副檔名為 <code>*.sass</code>)，如果你問我要選擇哪個，我會毫不猶豫推薦你 SCSS，原因很簡單，它的學習曲線相對較緩，從上面的範例可以看出，你甚至將原本的 <code>*.css</code> 檔案更改為 <code>*.scss</code> 也不會有任何問題，兩者的語法是一模一樣的，SCSS 就是在原本的 CSS 增加程式語言的基礎形成的預處理器，故之後的介紹都會是以 SCSS 為主。</p><p>目前我們已經了解何謂 CSS 預處理器，也了解 Sass 與 SCSS 的差別，這邊還有一個重點是，所有的 CSS 預處理器都得透過編譯器使之編譯成 CSS 才能供 HTML 引入，不然 Browser 是無法識別這個東西的，接下來我們就來建立預處理器的編譯環境吧！</p><h2 id="編譯環境建立-使用官方-sass-套件"><a href="#編譯環境建立-使用官方-sass-套件" class="headerlink" title="編譯環境建立 - 使用官方 sass 套件"></a>編譯環境建立 - 使用官方 sass 套件</h2><p>新增基本的專案環境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">project&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── scss&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── all.scss</span><br><span class="line">│</span><br><span class="line">└─── index.html</span><br></pre></td></tr></table></figure><p>我們先來測試 SCSS 是否能正確被 HTML 識別：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"scss/all.scss"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此時會跳出：</p><p><img src="https://i.imgur.com/qeMvDOK.png" alt="HTML 無法解析 .scss 的文件"></p><p>如同我們之前所說，HTML 是無法解析 <code>*.scss</code> 文件的，任何的 CSS 預處理器都得透過編譯器使之編譯成 CSS 才能被正確解析，接著使用以下指令安裝官方的 Sass / SCSS 編譯器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install sass -g</span><br></pre></td></tr></table></figure><p>檢查是否成功安裝：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass --version</span><br></pre></td></tr></table></figure><p>此篇文章並不會介紹 SCSS 的相關語法，這會等到之後再做專門的介紹，請先複製以下代碼至 <code>all.scss</code> 內：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$primary</span>: blue;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用以下指令編譯 <code>all.scss</code> 檔案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass .\scss\all.scss .\css\all.css</span><br></pre></td></tr></table></figure><p>上面這道指令指的是編譯 <code>.\scss\all.scss</code> 檔案到 <code>.\css\all.css</code> 內，不存在及建立，此時就會生成編譯好的 <code>all.css</code> 檔案：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> project/</span><br><span class="line"> │</span><br><span class="line"><span class="addition">+├─── css/</span></span><br><span class="line"><span class="addition">+│   │</span></span><br><span class="line"><span class="addition">+│   ├─── all.css</span></span><br><span class="line"><span class="addition">+│   └─── all.css.map</span></span><br><span class="line"> │</span><br><span class="line"> ├─── scss/</span><br><span class="line"> │   │</span><br><span class="line"> │   └─── all.scss</span><br><span class="line"> │</span><br><span class="line"> └─── index.html</span><br></pre></td></tr></table></figure><p><code>all.css</code> 的檔案內容為：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恭喜你已經完成編譯環境的建立了，就是這麼簡單，我們可在 <code>all.scss</code> 任意撰寫 SCSS 的內容，最後透過指令編譯成實體的 CSS 檔案，如果你嫌每次都要輸入指令太麻煩，可以傳遞 <code>--watch</code> 參數：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass  --watch .\scss\all.scss .\css\all.css</span><br></pre></td></tr></table></figure><p>這樣它就會監聽指定的檔案，如有任何更動即自動編譯，達到自動化的目的。</p><p>預設的配置就會生成對應的 <code>.map</code> 檔，這個大家應該很熟悉了才對，你也可以開啟 <code>index.html</code> 檔案查看是否正確的映射原始的 SCSS 檔案。</p><p>關於官方套件的說明，差不多就到這邊，你可以自己去玩看看它每個參數的作用，基本上它的作用就只有將 Sass /SCSS 編譯成 CSS 而已。</p><h2 id="編譯環境建立-使用-VSCode-的-Live-Sass-Compiler-套件"><a href="#編譯環境建立-使用-VSCode-的-Live-Sass-Compiler-套件" class="headerlink" title="編譯環境建立 - 使用 VSCode 的 Live Sass Compiler 套件"></a>編譯環境建立 - 使用 VSCode 的 Live Sass Compiler 套件</h2><p>如果你跟我一樣，覺得單純的編譯 Sass / SCSS 還要另外下載 npm 的套件並透過命令行方式進行很麻煩，在這邊推薦你另一個方法，但這只限定於你的 IDE 是 Visual Studio Code，別的 IDE 可能也有類似套件，這點大家可以自行 Google 看看，以下示範如何使用 Live Sass Compiler 進行編譯。</p><p>安裝 Live Sass Compiler 延伸模組：</p><p><img src="https://i.imgur.com/Fx83gRG.png" alt="安裝 Live Sass Compiler"></p><p>檔案 &gt; 喜好設定 &gt; 設定 &gt; 開啟設定 (JSON)：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"liveSassCompile.settings.formats"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"format"</span>: <span class="string">"expanded"</span>,</span><br><span class="line">      <span class="attr">"extensionName"</span>: <span class="string">".css"</span>,</span><br><span class="line">      <span class="attr">"savePath"</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是此模組的預設配置，在這邊我們先不管它，直接進行編譯看看：</p><p><img src="https://i.imgur.com/REtKY29.png" alt="Watch Sass"></p><p>要啟用編譯很簡單，只需要點擊狀態列的 <code>Watch Sass</code> 或是 <code>F1</code> 搜尋 <code>Live Sass</code> 選擇 <code>Watch Sass</code> 也能達到同樣效果，編譯完成後會再 <code>*.scss</code> 的同層目錄生成相關的 CSS 檔案：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> project/</span><br><span class="line"> │</span><br><span class="line"> ├─── scss/</span><br><span class="line"> │   │</span><br><span class="line"><span class="addition">+│   ├─── all.css</span></span><br><span class="line"><span class="addition">+│   └─── all.css.map</span></span><br><span class="line"> │   └─── all.scss</span><br><span class="line"> │</span><br><span class="line"> └─── index.html</span><br></pre></td></tr></table></figure><p>預設的生成路徑就是在同層目錄下，這顯然不是我們要的結果，我們想要把它放置在獨立的 CSS 資料夾內，此時可以更改 <code>savePath</code> 這個選項：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"liveSassCompile.settings.formats"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"format"</span>: <span class="string">"expanded"</span>,</span><br><span class="line">      <span class="attr">"extensionName"</span>: <span class="string">".css"</span>,</span><br><span class="line">      <span class="attr">"savePath"</span>: <span class="string">"~/../css"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>savePath</code> 的選項中，有以下關鍵字可做使用：</p><ul><li><code>null</code>：在 <code>*.sass</code> / <code>*.scss</code> 同層的位置生成檔案</li><li><code>/</code>：相對於根目錄</li><li><code>~</code>：相對於每個 <code>*.sass</code> / <code>*.scss</code> 檔案的同層位置</li></ul><p>而我們上面這樣配置的意思是，在 <code>*.scss</code> 同層目錄的上層目錄名為 CSS 的資料夾生成檔案，這樣就可以達到預期的位置了，此時的編譯結果為：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> project/</span><br><span class="line"> │</span><br><span class="line"><span class="addition">+├─── css/</span></span><br><span class="line"><span class="addition">+│   │</span></span><br><span class="line"><span class="addition">+│   ├─── all.css</span></span><br><span class="line"><span class="addition">+│   └─── all.css.map</span></span><br><span class="line"> │</span><br><span class="line"> ├─── scss/</span><br><span class="line"> │   │</span><br><span class="line"> │   └─── all.scss</span><br><span class="line"> │</span><br><span class="line"> └─── index.html</span><br></pre></td></tr></table></figure><p>這邊我們補充介紹 <code>format</code> 與 <code>extensionName</code> 這兩個選項，修改為以下配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"liveSassCompile.settings.formats"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"format"</span>: <span class="string">"expanded"</span>,</span><br><span class="line">      <span class="attr">"extensionName"</span>: <span class="string">".css"</span>,</span><br><span class="line">      <span class="attr">"savePath"</span>: <span class="string">"~/../css"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"format"</span>: <span class="string">"compressed"</span>,</span><br><span class="line">      <span class="attr">"extensionName"</span>: <span class="string">".min.css"</span>,</span><br><span class="line">      <span class="attr">"savePath"</span>: <span class="string">"~/../css"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>format</code> 代表的是輸出的格式 (樣式)，以下模式可做使用：</p><ul><li><code>expanded</code>：預設模式，即不做任何壓縮處理</li><li><code>nested</code>：類似 <code>expanded</code> 模式，但會處理縮排</li><li><code>compressed</code>：最小化處理，即常見的程式碼壓縮</li><li><code>compact</code>：類似 <code>compressed</code> 模式，但不處理空白字元</li></ul><p><code>extensionName</code> 代表的是附檔名的名稱，通常都會設為 <code>.css</code> 或 <code>.min.css</code>。每一個物件即代表生成一個檔案，上面的配置會生成兩個檔案，分別為 <code>expanded</code> 模式的 <code>*.css</code> 檔案，與 <code>compressed</code> 模式的 <code>*.min.css</code> 檔案：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> project/</span><br><span class="line"> │</span><br><span class="line"><span class="addition">+├─── css/</span></span><br><span class="line"><span class="addition">+│   │</span></span><br><span class="line"><span class="addition">+│   ├─── all.css</span></span><br><span class="line"><span class="addition">+│   ├─── all.css.map</span></span><br><span class="line"><span class="addition">+│   ├─── all.min.css</span></span><br><span class="line"><span class="addition">+│   └─── all.min.css.map</span></span><br><span class="line"> │</span><br><span class="line"> ├─── scss/</span><br><span class="line"> │   │</span><br><span class="line"> │   └─── all.scss</span><br><span class="line"> │</span><br><span class="line"> └─── index.html</span><br></pre></td></tr></table></figure><p>是不是挺方便的？如果你有嘗試去觀察編譯的結果，你會發現它連同 Prefix 也幫我們加入了：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">display</span>: -ms-flexbox;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就如同 PostCSS 使用 Autoprefixer 一般，以往我們都是使用 <code>.browserslist</code> 或 <code>&quot;browserslist&quot;</code> 去配置想要的版本，這邊一樣也可以，只不過得換在 <code>autoprefix</code> 做配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"liveSassCompile.settings.autoprefix"</span>: [<span class="string">"last 1 version"</span>, <span class="string">"&gt; 1%"</span>, <span class="string">"IE 10"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Live Sass Compiler 的配置差不多就這樣，還有其他比較冷門的配置，你可以到它的 <a href="https://github.com/ritwickdey/vscode-live-sass-compiler/blob/master/docs/settings.md" target="_blank" rel="external nofollow noopener noreferrer">文檔</a> 去做查看。</p><h2 id="編譯環境建立-使用-gulp-sass-套件"><a href="#編譯環境建立-使用-gulp-sass-套件" class="headerlink" title="編譯環境建立 - 使用 gulp-sass 套件"></a>編譯環境建立 - 使用 gulp-sass 套件</h2><p>由於篇幅較長，可至相關文章進行閱讀：</p><ul><li><a href="https://awdr74100.github.io/2019-12-31-gulp-gulpsass/">Gulp 前端自動化 - 編譯 Sass/SCSS</a></li></ul><h2 id="編譯環境建立-使用-sass-loader-套件"><a href="#編譯環境建立-使用-sass-loader-套件" class="headerlink" title="編譯環境建立 - 使用 sass-loader 套件"></a>編譯環境建立 - 使用 sass-loader 套件</h2><p>由於篇幅較長，可至相關文章進行閱讀：</p><ul><li><a href="https://awdr74100.github.io/2020-03-04-webpack-sassloader/">Webpack 前端打包工具 - 使用 sass-loader 編譯 Sass/SCSS 預處理器</a></li></ul>]]></content>
    
    <summary type="html">
    
      在之前介紹的各種前端工具中，都是使用 SCSS 最為樣式表的開發對象，原因很簡單，那就是它大幅加強了 CSS 對各種操作的支持，以往我們會認為 CSS 語法很單調，但也因為太單調，導致存在許多操作上的不便，現在我們有了 Sass / SCSS 等 CSS 預處理器可以選擇，真正意義上的將樣式表變為一門程式語言，可使用變數、函式、迴圈等程式語言基本就具備的功能達到撰寫樣式表的目的。此篇將從何謂 CSS 預處理器開始介紹，接著說明 Sass / SCSS 該如何透過相關工具使之編譯成 CSS 跑在瀏覽器上。
    
    </summary>
    
    
      <category term="SCSS" scheme="https://awdr74100.github.io/categories/SCSS/"/>
    
    
      <category term="SCSS" scheme="https://awdr74100.github.io/tags/SCSS/"/>
    
      <category term="w3HexSchool" scheme="https://awdr74100.github.io/tags/w3HexSchool/"/>
    
      <category term="VSCode" scheme="https://awdr74100.github.io/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>Git 版本控制系統 - GitHub Flow 工作流程與實際演練</title>
    <link href="https://awdr74100.github.io/2020-05-11-git-githubflow/"/>
    <id>https://awdr74100.github.io/2020-05-11-git-githubflow/</id>
    <published>2020-05-10T16:36:48.000Z</published>
    <updated>2020-05-11T16:12:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>隨著專案越來越大，協作人員越來越多，衝突發生的機率也越來越高，訂定良好的團隊規範就顯得更為重要，Workflow 因此而誕生，常見的對象有 Git Flow、GitHub Flow 或 GitLab flow 等，主要都是被用來解決團隊間無規範可遵循造成衝突的問題，透過共同遵循的處理流程，達到有條理的進行團隊協作開發。此篇將介紹目前主流的 GitHub Flow 工作流程是如何運作，並透過實際演練說明它所能帶給團隊的好處。</p><h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul><li>GitHub Flow 介紹</li><li>建立 Organization 組織</li><li>GitHub Flow 實際演練</li><li>Heroku 自動部屬</li></ul><h2 id="GitHub-Flow-介紹"><a href="#GitHub-Flow-介紹" class="headerlink" title="GitHub Flow 介紹"></a>GitHub Flow 介紹</h2><p>讓我們先來看 <a href="https://guides.github.com/introduction/flow/" target="_blank" rel="external nofollow noopener noreferrer">官方</a> 的介紹：</p><blockquote><p>GitHub flow is a lightweight, branch-based workflow that supports teams and projects where deployments are made regularly.</p></blockquote><p>你現在一定很困惑，沒關係，我當時看到也是滿臉問號，簡單來講呢，GitHub Flow 是基於創建分支所運作，最大的特點在於其流程非常簡單，你不需要像 Git Flow 一樣創建多達 5 種的分支，有新功能需求時在創建對應的 <code>feature</code> 分支即可，其中的主要流程為：</p><ul><li>創建分支 (Create a branch)</li><li>提交修改 (Add commits)</li><li>開啟 PR (Open a Pull Request)</li><li>代碼審核 (Discuss and review your code)</li><li>部屬 (Deploy)</li><li>合併 (Merge)</li></ul><p>剛剛我們提到了創建 <code>feature</code> 分支的部分，當你的功能開發完成後，即透過 PR (Pull Request) 與負責人做溝通，如果有看過我上一篇文章的人應該很熟悉了才對，接著負責人收到你的 PR 後會與你討論相關的內容，確認沒問題即合併到 <code>master</code> 分支，而 <code>master</code> 分支上的每個版本都是可以進行部屬的，這點在我們實際演練時會再做討論，最後即完成了此次的 GitHub Flow 流程，日後有新功能需求時，就只是再重跑一次流程而已。</p><p>你可能還是聽得霧煞煞，簡單來講呢，就是我們只會接觸到對應的 <code>feature</code> 分支，當我們的 <code>feature</code> 分支開發完成後，即發送 PR 給負責人，如果確認沒問題負責人就會將這個 PR (<code>feature</code> 分支) 合併到 <code>master</code> 分支，在合併完成後即自動部屬至伺服器，因為放在 <code>master</code> 分支上的每個版本都是可以直接部屬的。</p><p>現在你可能就有點頭緒了，為了加強對 GitHub Flow 的了解，讓我們來實際演練一番吧！</p><h2 id="建立-Organization-組織"><a href="#建立-Organization-組織" class="headerlink" title="建立 Organization 組織"></a>建立 Organization 組織</h2><p>這邊要強調，GitHub Flow 只是一種工作流程，你可以把它用在開源專案或私有專案上，並沒有說一定要用在哪裡，它更像是一種共識，下面我們會以 GitHub 中的組織 (Organization) 為對象做介紹，說明團隊間是如何使用 GitHub Flow 做運作的，讓我們先在 GitHub 建立一個組織：</p><p><img src="https://i.imgur.com/xjHMkOR.png" alt="建立組織"></p><p>在 GitHub 建立組織相當簡單，就如同新增遠端數據庫一般，透過點選即可完成，之後會跳出邀請成員的畫面：</p><p><img src="https://i.imgur.com/DPpflYE.png" alt="邀請成員"></p><p>這邊我們一樣使用兩支帳號來做示範，被邀請的成員需透過 Email 接收邀請才會正式加入組織，最後的結果為：</p><p><img src="https://i.imgur.com/b8R9FAb.png" alt="組織畫面"></p><p>由於是示範用的，其他細項我們就不做討論，到這邊就已經完成創建組織的動作了，接下來讓我們正式進入到 GitHub Flow 的實際演練章節吧！</p><h2 id="GitHub-Flow-實際演練"><a href="#GitHub-Flow-實際演練" class="headerlink" title="GitHub Flow 實際演練"></a>GitHub Flow 實際演練</h2><p>目前我們登入的帳號為 lanroya，也就是組織的管理者，你可以把它當作專案的負責人，他使用了 express-generator 生成專案的初始環境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">express -e express-project</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> express-project</span><br><span class="line"></span><br><span class="line">npm i</span><br></pre></td></tr></table></figure><p>新增 <code>.gitignore</code> 檔案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch .gitignore</span><br></pre></td></tr></table></figure><p>忽略 <code>node_modules</code> 資料夾：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; .gitignore</span><br><span class="line"></span><br><span class="line">node_modules&#x2F;</span><br></pre></td></tr></table></figure><p>初始化 Git 環境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'建立環境'</span></span><br></pre></td></tr></table></figure><p>此時的線路圖狀態為：</p><p><img src="https://i.imgur.com/WScL3cV.png" alt="查看目前 commit 紀錄-1"></p><p>目前初始環境已經建立完成，你總不可能要求成員使用 USB 來 copy 你的檔案吧？如同新增帳號底下的遠端數據庫一般，在組織新增一個遠端數據庫：</p><p><img src="https://i.imgur.com/o8xQyJ0.png" alt="在組織新增遠端數據庫"></p><p>我們選擇將組織的遠端數據庫設為公開狀態，當然你也可以設為私有的，但要注意，以預設來說，成員是無法 Fork 私有遠端數據庫的，你必須到組織的設定將其選項打開，成員才可以進行 Fork，組織的遠端數據庫與帳號底下的遠端數據庫基本上沒啥差別，一個是掛在組織底下，一個是掛在帳號底下而已：</p><p><img src="https://i.imgur.com/blOjpEv.png" alt="遠端數據庫成功建立"></p><p>添加組織的遠端數據庫位址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/roxog/express-project.git</span><br></pre></td></tr></table></figure><p>將專案推至遠端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>專案已成功推至遠端：</p><p><img src="https://i.imgur.com/wcd7EAH.png" alt="成功推至遠端數據庫"></p><p>到這邊負責人的操作就先告一段落了，接下來換成員建立 <code>feature</code> 分支並開發新功能的部分，我們採用 GitHub Flow 來運作，登入 awdr74100 帳號並 Fork 組織的專案：</p><p><img src="https://i.imgur.com/kEOSyF1.png" alt="fork 組織的專案"></p><p>此時會跳出選擇 Fork 至哪一個帳號的提示，選擇成員 (awdr74100)，之後就會 Fork 至帳號底下：</p><p><img src="https://i.imgur.com/7SJKkug.png" alt="成功 fork 專案"></p><p>在來的操作就如同帳號底下的遠端數據庫一般，由於我們本地還未有這個資料，這邊先克隆回本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/awdr74100/express-project.git project</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> project</span><br></pre></td></tr></table></figure><p>查看線路圖狀態：</p><p><img src="https://i.imgur.com/6U2F8t3.png" alt="查看目前 commit 紀錄-2"></p><p>本文重點來了，GitHub Flow 的第一步是在 <code>master</code> 分支建立 <code>feature</code> 的分支，假設我今天要開發的功能是修改路由，可以這樣做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature/edit_router</span><br><span class="line"></span><br><span class="line">... edit /routes/index.js</span><br><span class="line"></span><br><span class="line">git commit -am <span class="string">'修改 router 標題'</span></span><br></pre></td></tr></table></figure><p>分支的名稱是可隨意命名的，但必須具備其描述性，目前我們已經完成 GitHub Flow 的第一與第二個步驟了，線路圖狀態為：</p><p><img src="https://i.imgur.com/q76yMKN.png" alt="查看目前 commit 紀錄-3"></p><p>假設新功能已經開發完成了，先將新提交推至帳號底下的遠端數據庫：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin --all</span><br></pre></td></tr></table></figure><p>接著進行 GitHub Flow 的第三步驟，開啟 PR (Pull Request)：</p><p><img src="https://i.imgur.com/ZFiRooC.png" alt="開啟 PR"></p><p>這邊要注意來源與目的的選擇，你是將 <code>feature/edit_router</code> 推到專案的 <code>master</code> 分支，並不是 <code>master</code> 推 <code>master</code>，如果確認沒問題，就發送 RP 吧，此時 GitHub Flow 的第三步驟也就完成了。</p><p>這邊做一個補充，其實也不算補充，如果你有看過上一篇文章的人應該都知道該怎麼做了，如果未來要同步組織的遠端資料庫時，必須添加數據庫的位址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add <span class="built_in">source</span> https://github.com/roxog/express-project.git</span><br></pre></td></tr></table></figure><p>這樣之後就可以使用 <code>fetch</code> 或 <code>pull</code> 將負責人合併後的資料給拉下來，達到同步更新的作用，接下來切換到負責人的帳號 (lanroya) 來處理 PR 吧：</p><p><img src="https://i.imgur.com/gro36Go.png" alt="處理 PR"></p><p>目前來到了 GitHub Flow 的第四個步驟，也就是代碼審核的部分，這邊介紹一個蠻有趣的功能，切換到 <code>Files changed</code> 選項：</p><p><img src="https://i.imgur.com/e2vijFv.png" alt="files changed 功能"></p><p>你可以點擊更動代碼旁邊的 <code>+</code> 按鈕，或是直接將更動代碼整個選起來以進行討論，看起來會像這樣個樣子：</p><p><img src="https://i.imgur.com/sFVSx2r.png" alt="代碼審核"></p><p>點擊 <code>Add single comment</code> 即可添加討論，此時有關的人員都會收到此次的評論通知，現在的 <code>Conversation</code> 看起來會像這樣：</p><p><img src="https://i.imgur.com/P1KQp2O.png" alt="add single comment"></p><p>假設此次的討論已經完成，可以點擊 <code>Resolve conversation</code> 關閉對話，最後確認沒問題的話，點擊 <code>Merge pull request</code> 合併 PR：</p><p><img src="https://i.imgur.com/rJg3ywT.png" alt="合併 PR"></p><p>到這邊我們就跑完 GitHub Flow 的全部步驟了，此時你可能會想，第五個步驟怎麼沒有說明呢？在前面我們有一直強調 <code>master</code> 分支的每個版本都是可以直接部屬至伺服器的，這也就代表說當我們合併這一個 PR 時，進而生成的提交就等於 production 的版本，在這邊你先理解大概的概念就好，下面我們會介紹如何使用 heroku 自動完成部署動作。</p><p>現在你已經會使用 GitHub Flow 運作整個提交流程了，其實就是一直圍繞在 <code>master</code> 開 <code>feature</code> 分支，將 <code>feature</code> 分支推上 fork 的遠端數據庫，之後開啟 PR 發送 <code>feature</code> 分支合併 <code>master</code> 分支的請求，之後又有新功能要開發時，先將本地數據庫與組織數據庫做同步：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="built_in">source</span> master</span><br><span class="line"></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>此時的線路圖狀態為：</p><p><img src="https://i.imgur.com/OtLgsKR.png" alt="查看目前 commit 紀錄-4"></p><p>要開發新功能就在開一個 <code>feature</code> 分支，之後再重跑一次 GitHub Flow 的流程，這邊要養成一個好習慣先 <code>pull</code> 在 <code>push</code>，也就是先拉在推，你沒辦法保證在過程中是否會有其他成員提交 PR 並審核通過，如同我們之前所說，歷史紀錄不同，肯定會發生衝突，這邊要特別注意。</p><h2 id="Heroku-自動部屬"><a href="#Heroku-自動部屬" class="headerlink" title="Heroku 自動部屬"></a>Heroku 自動部屬</h2><p>這邊我們來補充何謂 <code>master</code> 分支上的每個版本都是可部屬狀態的，通常這個動作會在初始化專案時進行，但為了避免大家混淆，剛剛沒有操作到這一部分，回到 lanroya 帳號操作 Git：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heroku login</span><br><span class="line"></span><br><span class="line">heroku create</span><br></pre></td></tr></table></figure><p>上面操作主要用來在 heroku 開一個伺服器，這邊我們並不會強調 heroku 的使用方式，在之後的 express 章節會再做說明，目前主要用來示範何謂自動部屬，此時的專案會新增 heroku 的遠端位址：</p><p><img src="https://i.imgur.com/E57QN7r.png" alt="查看所有遠端數據庫"></p><p>將專案推至 heroku 並查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push heroku origin master</span><br><span class="line"></span><br><span class="line">heroku open</span><br></pre></td></tr></table></figure><p>此時會跳出以下畫面：</p><p><img src="https://i.imgur.com/lWGK47s.png" alt="查看 heroku 部屬畫面-5"></p><p>我們的 express 專案已成功部屬在 heroku，你可以把它想像成 GitHub Page 的感覺，目前的線路圖狀態為：</p><p><img src="https://i.imgur.com/2qH9EL3.png" alt="查看目前 commit 紀錄"></p><p><code>master</code> 分支新增了 <code>heroku/master</code> 的參考，接著到剛剛新增的 heroku 伺服器設定介面：</p><p><img src="https://i.imgur.com/7bcH581.png" alt="heroku 啟用自動部屬功能"></p><p>點擊 <code>Enable Automatic Deploys</code> 啟用自動部屬功能，這樣就完成了，此後組織專案中的 <code>master</code> 分支只要有變動，heroku 都會自動幫你完成部屬的動作，讓我們來測試一次：</p><blockquote><p>當前為成員 (awdr74100) 的操作</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature/change_router_title</span><br><span class="line"></span><br><span class="line">... edit router title</span><br><span class="line"></span><br><span class="line">git commit -am <span class="string">'再次修改標題'</span></span><br><span class="line"></span><br><span class="line">git push origin --all</span><br></pre></td></tr></table></figure><p>開啟 PR：</p><p><img src="https://i.imgur.com/MLB56GZ.png" alt="再次開啟 PR"></p><p>負責人通過 PR：</p><p><img src="https://i.imgur.com/O4nJ1yJ.png" alt="通過 PR"></p><p>當你按下 <code>Merge pull request</code> 合併 PR 時，因為 <code>master</code> 分支移動了，heroku 就會開始自動部屬的動作：</p><p><img src="https://i.imgur.com/iRXVQ03.png" alt="heroku 自動部屬"></p><p>結果頁面：</p><p><img src="https://i.imgur.com/QPrM9cr.png" alt="結果頁面"></p><p>是不是很酷？我們就再也不需要手動 Push 至 heroku 了，事實上，類似的 PaaS 都有這個功能，比如說我自己非常喜歡的 <a href="https://vercel.com/" target="_blank" rel="external nofollow noopener noreferrer">ZEIT Now</a> 也有這個功能，之後有機會再做示範。</p><p>到這邊我們的 Git 學習路程就告一段落囉。</p>]]></content>
    
    <summary type="html">
    
      隨著專案越來越大，協作人員越來越多，衝突發生的機率也越來越高，訂定良好的團隊規範就顯得更為重要，Workflow 因此而誕生，常見的對象有 Git Flow、GitHub Flow 或 GitLab flow 等，主要都是被用來解決團隊間無規範可遵循造成衝突的問題，透過共同遵循的處理流程，達到有條理的進行團隊協作開發。此篇將介紹目前主流的 GitHub Flow 工作流程是如何運作，並透過實際演練說明它所能帶給團隊的好處。
    
    </summary>
    
    
      <category term="Git" scheme="https://awdr74100.github.io/categories/Git/"/>
    
    
      <category term="w3HexSchool" scheme="https://awdr74100.github.io/tags/w3HexSchool/"/>
    
      <category term="Git" scheme="https://awdr74100.github.io/tags/Git/"/>
    
      <category term="GitHub" scheme="https://awdr74100.github.io/tags/GitHub/"/>
    
      <category term="GitHub Flow" scheme="https://awdr74100.github.io/tags/GitHub-Flow/"/>
    
      <category term="Heroku" scheme="https://awdr74100.github.io/tags/Heroku/"/>
    
  </entry>
  
  <entry>
    <title>Git 版本控制系統 - Fork 複製倉庫與 Pull Request 請求合併</title>
    <link href="https://awdr74100.github.io/2020-05-07-git-fork-pullrequest/"/>
    <id>https://awdr74100.github.io/2020-05-07-git-fork-pullrequest/</id>
    <published>2020-05-07T08:32:16.000Z</published>
    <updated>2020-05-08T15:06:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前我們都是在自己的遠端數據庫做操作，由於是自己的並不會遇到所謂的權限問題，但假如我們也想操作其他開發者的遠端數據庫呢？比如你正在使用的套件存在 Bug，而你剛好有能力修復，將專案克隆並修復後，你想把最新提交推至原作的遠端數據庫，這時就會遇到權限不足的問題，你可能透過 Email 請作者開權限給你，但你覺得他會理你嗎？通常這個過程我們都會使用 Fork 與 Pull Request 來完成，先將原作的數據庫 Fork 至帳號底下，待我們克隆並修復完成後，再透過 Pull Request 請求作者合併更新。</p><h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul><li>推至遠端時所遇權限不足問題</li><li>Fork 其他開發者專案</li><li>發送 Pull Request 請求合併</li><li>處理 Pull Request 檢查是否合併</li><li>同步 Pull Request 後的專案進度</li><li>Pull Request 衝突解決辦法</li></ul><h2 id="推至遠端時所遇權限不足問題"><a href="#推至遠端時所遇權限不足問題" class="headerlink" title="推至遠端時所遇權限不足問題"></a>推至遠端時所遇權限不足問題</h2><p>這邊我們來模擬推至遠端時所遇權限不足問題，假設我們的專案使用了 Vue 進行開發，但發現存在一處 Bug 須修復，我們可能會這樣做：</p><p><img src="https://i.imgur.com/mTLV1iZ.png" alt="Vue.js"></p><p>如同處理自己的遠端數據庫一般，可使用 HTTPS 或 SSH 方式克隆回本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b dev git@github.com:vuejs/vue.git vue</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> vue</span><br></pre></td></tr></table></figure><p>這邊要注意，並不是說操作其他開發者的遠端數據庫時，都會遇到身分驗證的提示，你想想看，我只是單純克隆別人的數據庫，為什麼需要身分驗證呢？如果你不想把數據庫給公開，你可以設置為 <code>Private</code> 屬性，此時陌生人就看不到你的遠端數據庫囉，上面提到的都是屬於克隆操作，那假設我們要進行推至遠端的動作呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">touch test123.txt</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add test123.txt'</span></span><br><span class="line"></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>此時會跳出無訪問權限的提示：</p><p><img src="https://i.imgur.com/aV3GRpO.png" alt="git push 權限不足"></p><p>這蠻合理的嗎，克隆並不會影響原作者的數據庫，但 Push 就會了，你敢想像自己的遠端數據庫突然被陌生人 <code>git push -f</code> 嗎？一般來說我們只能操作自己的遠端數據庫，並不能操作別人的數據庫，但可透過 Fork 與 PR (為 Pull Request 縮寫) 與原作者做交流，了解了原由，接下來讓我們進入到主要的章節吧！</p><h2 id="Fork-其他開發者專案"><a href="#Fork-其他開發者專案" class="headerlink" title="Fork 其他開發者專案"></a>Fork 其他開發者專案</h2><p>為了示範原作者與陌生開發者各自的操作，這邊我開了兩支帳號來示範，角色如下：</p><ul><li>原作者：<a href="https://github.com/lanroya" target="_blank" rel="external nofollow noopener noreferrer">lanroya</a></li><li>陌生開發者：<a href="https://github.com/awdr74100" target="_blank" rel="external nofollow noopener noreferrer">awdr74100</a></li></ul><p>目前我們登入的帳號是 lanroya，建立一個專案並提交兩次 commit 紀錄：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mkdir pr-demo</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> pr-demo</span><br><span class="line"></span><br><span class="line">touch all.css</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add all.css'</span></span><br><span class="line"></span><br><span class="line">... edit all.css</span><br><span class="line"></span><br><span class="line">git commit -am <span class="string">'edit all.css &gt; .a'</span></span><br></pre></td></tr></table></figure><p>假設初步的操作已經完成，在 GitHub 新增一個遠端數據庫並 Push：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/lanroya/pr-demo.git</span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>此時 lanroya 帳號底下就會有自己的 pr-demo 專案：</p><p><img src="https://i.imgur.com/cm8V25n.png" alt="lanroya 帳號底下的專案"></p><p>接著 awdr74100 開發者發現這個專案蠻有趣的但存在些 Bug，他想要幫忙修復，先執行 Fork：</p><p><img src="https://i.imgur.com/6JPxfh8.png" alt="fork 專案"></p><p>這邊要注意，fork 並不屬於 Git 的指令，它是 GitHub 等遠端伺服器相當特別的功能，主要能將指定專案複製一份到你的帳號底下，當你按下了 fork 按鈕，會跳出以下畫面：</p><p><img src="https://i.imgur.com/CT2AO0V.png" alt="fork 轉場畫面"></p><p>代表正在 fork 此專案到你的帳號底下，完成後會跳轉到你帳號底下的這個專案：</p><p><img src="https://i.imgur.com/uUvMGAc.png" alt="fork 完成後跳轉"></p><p>到這邊就已經完成 fork 的動作了，可以到帳號底下查看是否有這一個目標專案。</p><p>你可能會好奇，這樣有什麼作用？還記得上面提到的權限不足問題嗎？當我們去存取帳號底下除外的專案時，會遇到 Push 操作無訪問權限的提示，而 fork 的用意就是將陌生專案拷貝一份到你的帳號底下，之後我們就可以如同帳號底下專案操作一般，針對此專案進行 Fetch、Pull、Push 的操作，接著我們來修復這個 Bug 吧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/awdr74100/pr-demo.git pr-demo</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> pr-demo</span><br><span class="line"></span><br><span class="line">... edit all.css</span><br><span class="line"></span><br><span class="line">git commit -am <span class="string">'edit all.css &gt; b'</span></span><br></pre></td></tr></table></figure><p>當我們修復完成後，由於是自己帳號底下的數據庫，並不會造成所謂的 Push 無訪問權限問題：</p><p><img src="https://i.imgur.com/T1FnyUf.png" alt="-3-(https://i.imgur.com/sbp2WfH.png)1"></p><p>目前 Bug 就已經被 awdr74100 修復了，但這邊所謂的修復是指在 awdr74100 拷貝的專案下進行修復，原作者的專案是不受任何影響的，如果要告知原作者 Bug 已被修復，可以使用 Pull Request 功能，直接進入下個章節。</p><h2 id="發送-Pull-Request-請求合併"><a href="#發送-Pull-Request-請求合併" class="headerlink" title="發送 Pull Request 請求合併"></a>發送 Pull Request 請求合併</h2><p>目前 awdr74100 已經把 Bug 給修復完成了，但 lanroya 還不知道，這過程可透過 PR (Pull Request) 來完成：</p><p><img src="https://i.imgur.com/yyrLP8m.png" alt="New Pull Request"></p><p>在 awdr74100 拷貝的專案底下有 Pull request 的區塊可做選擇，點擊後的畫面如上圖，接者點擊 <code>New pull request</code> 按鈕，此時會跳出以下畫面：</p><p><img src="https://i.imgur.com/Q8QKJUz.png" alt="發送 Pull Request"></p><p>畫面跳轉到了 lanroya 的頁面，這邊我們就可選擇剛剛修復完成的分支進行請求合併，在之前的文章我們有說過 GitHub 等遠端伺服器是採用「合併」的方式來更新內容，Pull Request 你可以把它理解為將最新的 commit 提交丟給原作者，讓原作者判斷是否要合併這一個 commit 提交。</p><p>這邊還有一個重點是關於 <code>Able to merge</code> 字樣，它能夠告訴你這一個 PR 如果作者接受的話是否會發生衝突，畢竟 PR 不太可能只有一個人發，如果你的專案很知名，像 React、Vue 等等，作者接受了第一個 PR，但要接受第二個 PR 時，就有可能發生錯誤，因為提交紀錄被改變了阿，從原本的兩個 commit，變成了三個 commit，假如你的 PR 還是處於兩個 commit 的狀態，就會跳衝突，這我們之後再說，確認 PR 沒問題後，就可以點擊 <code>Create pull request</code> 按鈕囉，此時會切換為以下畫面：</p><p><img src="https://i.imgur.com/Bn1GUbB.png" alt="PR 訊息"></p><p>預設的標題為當時提交的 commit 訊息，你可以隨意做修改，如果要進行補充，也可以寫在下方的空白區域內，此區域是支援 Markdown 語法的喔，確認沒問題就可以點擊 <code>Create pull request</code> 發送 PR 囉，結果畫面為：</p><p><img src="https://i.imgur.com/WMvvX3P.png" alt="PR 發送成功"></p><p>到這邊我們的 PR 就已經發送成功，你可以在下方繼續進行補充，接下來就等作者 (lanroya) 檢查並判斷是否接受合併囉。</p><h2 id="處理-Pull-Request-檢查是否合併"><a href="#處理-Pull-Request-檢查是否合併" class="headerlink" title="處理 Pull Request 檢查是否合併"></a>處理 Pull Request 檢查是否合併</h2><p>接著我們換原作者 (lanroya) 的部分，登入 lanroya 帳號後並切換到指定數據庫會看到以下畫面：</p><blockquote><p>當有 PR 請求時，作者也會收到 Email 的通知</p></blockquote><p><img src="https://i.imgur.com/Yx7XR6c.png" alt="原作者 GitHub 畫面"></p><p>有發現不一樣的地方嗎？沒錯，有人發送了 Pull Request 給我們，讓我們點擊進去看看：</p><p><img src="https://i.imgur.com/uQvJqEE.png" alt="Pull Request 清單"></p><p>在這邊你可以看到所有的 PR 紀錄，正好第一筆不就是剛剛 awdr74100 發送給我們的 PR 嗎？點擊進入：</p><p><img src="https://i.imgur.com/6qrEbrY.png" alt="PR 詳細頁面"></p><p>你可以看到有關這個 PR 的各種資訊，比如說提交幾次 commit 阿，代碼哪裡做了更動阿，這些都看的到，你也可以在下方的互動區塊與提交者 (awdr74100) 做互動，這邊最重要的是檢查此 PR 是否會發生衝突，你可以直接從它的提示去得知，如果確認都沒問題，就直接按下 <code>Merge pull request</code> 按鈕吧！</p><p>此時會要求你輸入此次提交的 commit 紀錄訊息，就如同 <code>non-fast-forward</code> 處理一般，這邊我們採用預設訊息即可，按下 <code>Confirm merge</code> 確認合併吧！</p><p><img src="https://i.imgur.com/6qrEbrY.png" alt="Confirm merge"></p><p>此時 PR 狀態會從 <code>Open</code> 更改為 <code>Merged</code>，代表合併成功囉。</p><p>那要怎麼確認 PR 是否真的合併成功呢？你可以切換到主頁面並點選 <code>commits</code> 查看所有提交紀錄：</p><p><img src="https://i.imgur.com/VbpUVlz.png" alt="commits 查看所有提交紀錄"></p><p>或是直接在 lanroya 的 bash 輸入以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>因為遠端數據庫有了新的提交紀錄，我們可以把它 Fetch 回來並查看：</p><p><img src="https://i.imgur.com/Ug6kmvm.png" alt="fetch PR 提交"></p><p>看到我們剛剛 merge 的 PR 提交囉，此時一樣使用 merge 即可同步遠端的提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure><p>以上就是整個發送 PR 的流程，是不是很有趣？發送 PR 不只可以應用在開源專案上，企業內部也很常使用此方式來處理夥伴間的提交，達到流程化的效果。</p><h2 id="同步-Pull-Request-後的專案進度"><a href="#同步-Pull-Request-後的專案進度" class="headerlink" title="同步 Pull Request 後的專案進度"></a>同步 Pull Request 後的專案進度</h2><p>這邊我們做一個補充，原作者要同步遠端數據庫的內容相對簡單，上面就已經有示範，但陌生開發者 (awdr74100) 可能就需要點技巧了，發送的 PR 就算已被原作者合併，fork 過來的專案也不會有任何變化，帳號底下的這個專案看起來雖然是個克隆體，但本質上與原作者的數據庫是完全不一樣的東西，如果想要完成同步，有以下方法可做選擇：</p><ul><li>把克隆專案改掉，重新 fork 專案</li><li>新增原作遠端數據庫位址，並手動同步專案</li></ul><p>砍掉重練方法相對簡單，你不需要輸入任何指令，每次 fork 的狀態一定就是最新的，各位可自行試試，這邊就不做示範，我自己是比較習慣新增原作的遠端數據庫位址並手動同步專案，以下為示範：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add lanroya https://github.com/lanroya/pr-demo.git</span><br></pre></td></tr></table></figure><p>檢查是否成功新增遠端數據庫位址：</p><p><img src="https://i.imgur.com/SEFwBYP.png" alt="新增遠端數據庫位址"></p><p>在前面我們有提到使用 clone 或 fetch 等方式是不會跳出無訪問權限提示的，因為又不影響原作者的數據庫，這邊我們就可以用同樣方式來處理 PR 後的提交紀錄，上面新增了原作者的遠端數據庫位址，接下來進行 fetch 動作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch lanroya mastr</span><br></pre></td></tr></table></figure><p>此時的線路圖狀態為：</p><p><img src="https://i.imgur.com/W6c7Con.png" alt="-3-(https://i.imgur.com/sbp2WfH.png)2"></p><p>你會發現原作者的遠端數據庫就被我們拉下來了，接著直接合併即可完成同步動作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge lanroya/master</span><br></pre></td></tr></table></figure><p>說真的這也沒多複雜，我比較推薦使用此方式來完成同步操作，某方面來講可能會比較簡單。</p><h2 id="Pull-Request-衝突解決辦法"><a href="#Pull-Request-衝突解決辦法" class="headerlink" title="Pull Request 衝突解決辦法"></a>Pull Request 衝突解決辦法</h2><p>在上面我們有提到 PR 也是會發生衝突的，且機率還挺高的，我們來模擬這一狀況：。</p><p>假設原作者 (lanroya) 更新的專案進度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">... edit all.css</span><br><span class="line"></span><br><span class="line">git commit -am <span class="string">'edit all.css &gt; .c'</span></span><br></pre></td></tr></table></figure><p>很自然的將它推上遠端數據庫：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><p>此時陌生開發者 (awdr74100) 忘記先同步原作者專案就直接發 PR：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">... edit all.css</span><br><span class="line"></span><br><span class="line">git commit -am <span class="string">'edit all.css .c'</span></span><br><span class="line"></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>在這邊我們刻意模擬同步的衝突以及代碼的衝突，此時 PR 的畫面為：</p><p><img src="https://i.imgur.com/r7gkfAH.png" alt="PR 發生衝突"></p><p>你會發現它顯示了 <code>Can&#39;t automatically merge</code> 字樣，代表此 PR 會發生合併衝突，雖然你還是能把此 PR 發出去，但我建議在未發送前就解決這個衝突，你現在不解決，最後原作者還是得解決，但它合併的意願可能就不大了，解決辦法很簡單，如同我們自己的遠端數據庫合併衝突辦法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch lanroya master</span><br></pre></td></tr></table></figure><p>此時的線路圖狀態為：</p><p><img src="https://i.imgur.com/sbp2WfH.png" alt="查看目前 commit 紀錄-3"></p><p>原來是未同步提交紀錄所發生的衝突阿，此時我們可以這樣做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase lanroya/master</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge lanroya/master</span><br></pre></td></tr></table></figure><p>由於我不想要提交額外的 commit 紀錄，這邊我使用 rebase 來合併分支，如果順利的話分支就會被合併，但剛剛我也刻意模仿代碼發生的衝突，此時也就會跳出衝突的錯誤：</p><p><img src="https://i.imgur.com/mlQvYgH.png" alt="rebase 發生衝突"></p><p>關於 rebase 如何解決衝突，之前在 <a href="https://awdr74100.github.io/2020-05-04-git-rebase/">rebase 文章</a> 就有完整的解說，有興趣的可以過去看看，這邊就快速帶過：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">... resolve conflict</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p>此時的線路圖狀態為：</p><p><img src="https://i.imgur.com/O3Lcd4S.png" alt="查看目前 commit 紀錄-4"></p><p>這邊要注意，如果你是使用 merge 來合併分支，等等 Push 時就不會發生衝突，而如果你是使用 rebase 來合併分支，由於遠端指向的 <code>38a67a3</code> 提交已被拋棄 (隱藏)，本地改而指向剛剛 rebase 新生成的 <code>eddd006</code> 節點，歷史紀錄不同就會導致衝突，這邊很適合使用以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure><p>你可能會想，不是盡量不要使用這個命令嗎？沒錯，但此提交也只有我一個人在運作，何況我們沒有修改到原作者的紀錄阿，這種情況就比較沒關係，讓我們來看目前發 PR 還會不會有衝突：</p><p><img src="https://i.imgur.com/57BVALN.png" alt="PR 衝突以解決"></p><p>這一次的 PR 就不會有合併衝突囉，後面的流程就如同前面所介紹，各位可以自己跑一次看看。</p>]]></content>
    
    <summary type="html">
    
      目前我們都是在自己的遠端數據庫做操作，由於是自己的並不會遇到所謂的權限問題，但假如我們也想操作其他開發者的遠端數據庫呢？比如你正在使用的套件存在 Bug，而你剛好有能力修復，將專案克隆並修復後，你想把最新提交推至原作的遠端數據庫，這時就會遇到權限不足的問題，你可能透過 Email 請作者開權限給你，但你覺得他會理你嗎？通常這個過程我們都會使用 Fork 與 Pull Request 來完成，先將原作的數據庫 Fork 至帳號底下，待我們克隆並修復完成後，再透過 Pull Request 請求作者合併更新。
    
    </summary>
    
    
      <category term="Git" scheme="https://awdr74100.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://awdr74100.github.io/tags/Git/"/>
    
      <category term="GitHub" scheme="https://awdr74100.github.io/tags/GitHub/"/>
    
  </entry>
  
</feed>
