<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript 淺拷貝 (Shallow Copy) 與深拷貝 (Deep Copy)</title>
    <url>/2019-10-24-javascript-deepcopy/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在開發 Vue 項目時，需要利用 Props 與 Emit 使元件互相溝通，當時沒注意到物件有 Shallow Copy 與 Deep Copy 等特性，導致複製後的新物件影響原物件問題，特別深入學習此觀念。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>何謂傳值 ？</li>
<li>何謂傳址 ？</li>
<li>淺拷貝物件方式</li>
<li>深拷貝物件方式</li>
</ul>
<h2 id="基本型別與物件型別差異"><a href="#基本型別與物件型別差異" class="headerlink" title="基本型別與物件型別差異"></a>基本型別與物件型別差異</h2><img src="https://i.imgur.com/VS93ysP.png" alt="JavaScript型別參考" width="70%">

<p>在 JavaScript 的世界裡有基本型別與物件型別兩種定義。</p>
<p>基本型別為：<code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Null</code>、<code>Undefined</code>、<code>Symbol</code><br>其餘像是 <code>Array</code>、<code>Object</code> 這些都屬於物件型別，兩種資料型別最大的差異就在於傳值方式</p>
<p>基本型別在賦值時，是採用 <strong>pass by value</strong> 方式，也就是<strong>傳值</strong>，如下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'blue'</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">b = <span class="string">'red'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// red</span></span><br></pre></td></tr></table></figure>

<p>而物件型別在賦值時，是採用 <strong>pass by reference</strong> 方式，也就是<strong>傳址</strong>，如下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'yellow'</span>];</span><br><span class="line"><span class="keyword">let</span> object = &#123; <span class="attr">p1</span>: <span class="string">'111'</span>, <span class="attr">p2</span>: <span class="string">'222'</span>, <span class="attr">p3</span>: <span class="string">'333'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayCP = array;</span><br><span class="line">arrayCP[<span class="number">0</span>] = <span class="string">'black'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objectCP = object;</span><br><span class="line">objectCP.p2 = <span class="string">'444'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [ 'black', 'blue', 'yellow' ]  &lt;= 原陣列被影響，因為是傳址</span></span><br><span class="line"><span class="built_in">console</span>.log(arrayCP); <span class="comment">// [ 'black', 'blue', 'yellow' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(object); <span class="comment">// &#123; p1: '111', p2: '444', p3: '333' &#125;  &lt;= 原物件被影響，因為是傳址</span></span><br><span class="line"><span class="built_in">console</span>.log(objectCP); <span class="comment">// &#123; p1: '111', p2: '444', p3: '333' &#125;</span></span><br></pre></td></tr></table></figure>

<p>看出兩者的差別了嗎！當你使用等號賦值時，會間接的影響原物件，因為都是指向<strong>原物件記憶體位址</strong>，並不會創造新的拷貝物件，這種方法是很不切實際的，牽一髮動全身的概念，所以當我們在<strong>複製</strong>物件或陣列時，基本上都是使用函式的方式去做處理。</p>
<h2 id="淺拷貝-Shallow-Copy-vs-深拷貝-Deep-Copy"><a href="#淺拷貝-Shallow-Copy-vs-深拷貝-Deep-Copy" class="headerlink" title="淺拷貝(Shallow Copy) vs 深拷貝(Deep Copy)"></a>淺拷貝(Shallow Copy) vs 深拷貝(Deep Copy)</h2><img src="https://i.imgur.com/lLTlgI2.png" alt="淺拷貝(Shallow Copy) vs 深拷貝(Deep Copy)">

<p>當我們要進行<strong>複製</strong>動作時，最好先理解一下何謂淺拷貝與深拷貝：</p>
<ul>
<li><p>淺拷貝：<br>只能完成第一層的淺層複製，若有第二層結構時，還是<strong>依據參考特性</strong>作處理，<br>也就代表指向<strong>記憶體位址還是一樣</strong>的。</p>
</li>
<li><p>深拷貝：<br>深度複製指定物件，操作新物件不影響原物件，<strong>兩者指向不同記憶體位址</strong>。</p>
</li>
</ul>
<h2 id="淺拷貝方法-Object-assign"><a href="#淺拷貝方法-Object-assign" class="headerlink" title="淺拷貝方法 - Object.assign"></a>淺拷貝方法 - Object.assign</h2><p><code>Object.assign</code> 是 ES6 新增的函式，可用來複製一個或多個物件自身所有可數的屬性到另一個目標物件。回傳的值為該目標物件，如下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'yellow'</span>];</span><br><span class="line"><span class="keyword">let</span> object = &#123; <span class="attr">p1</span>: <span class="string">'111'</span>, <span class="attr">p2</span>: <span class="string">'222'</span>, <span class="attr">p3</span>: <span class="string">'333'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayCP = <span class="built_in">Object</span>.assign([], array);</span><br><span class="line">arrayCP[<span class="number">0</span>] = <span class="string">'black'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objectCP = <span class="built_in">Object</span>.assign(&#123;&#125;, object);</span><br><span class="line">objectCP.p2 = <span class="string">'444'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [ 'red', 'blue', 'yellow' ]  &lt;= 原陣列沒有影響</span></span><br><span class="line"><span class="built_in">console</span>.log(arrayCP); <span class="comment">// [ 'black', 'blue', 'yellow' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(object); <span class="comment">// &#123; p1: '111', p2: '222', p3: '333' &#125;  &lt;= 原物件沒有影響</span></span><br><span class="line"><span class="built_in">console</span>.log(objectCP); <span class="comment">// &#123; p1: '111', p2: '444', p3: '333' &#125;</span></span><br></pre></td></tr></table></figure>

<p>但夢是美好的，第二層還是會有<strong>參考特性影響原物件問題</strong>，如下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Eric'</span>,</span><br><span class="line">    weight: <span class="number">60</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dataCP = <span class="built_in">Object</span>.assign([], data);</span><br><span class="line"><span class="comment">// 操作第一層 ： 不影響原物件</span></span><br><span class="line">dataCP.push(&#123;</span><br><span class="line">  name: <span class="string">'Alice'</span>,</span><br><span class="line">  weight: <span class="number">50</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 操作第二層 ： 影響原物件</span></span><br><span class="line">dataCP[<span class="number">0</span>].name = <span class="string">'Emma'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data); <span class="comment">// [ &#123; name: 'Emma', weight: 60 &#125; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(dataCP); <span class="comment">// [ &#123; name: 'Emma', weight: 60 &#125;, &#123; name: 'Alice', weight: 50 &#125; ]</span></span><br></pre></td></tr></table></figure>

<h2 id="淺拷貝方法-展開運算符"><a href="#淺拷貝方法-展開運算符" class="headerlink" title="淺拷貝方法 - 展開運算符"></a>淺拷貝方法 - 展開運算符</h2><p>展開運算符也是 ES6 新增的特性，主要功能是把一個陣列展開(expand)成個別值，在依序放入指定物件或陣列，也可用做淺層複製，如下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'yellow'</span>];</span><br><span class="line"><span class="keyword">let</span> object = &#123; <span class="attr">p1</span>: <span class="string">'111'</span>, <span class="attr">p2</span>: <span class="string">'222'</span>, <span class="attr">p3</span>: <span class="string">'333'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayCP = [...array];</span><br><span class="line">arrayCP[<span class="number">0</span>] = <span class="string">'black'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objectCP = &#123; ...object &#125;;</span><br><span class="line">objectCP.p2 = <span class="string">'444'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [ 'red', 'blue', 'yellow' ]  &lt;= 原陣列沒有影響</span></span><br><span class="line"><span class="built_in">console</span>.log(arrayCP); <span class="comment">// [ 'black', 'blue', 'yellow' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(object); <span class="comment">// &#123; p1: '111', p2: '222', p3: '333' &#125;  &lt;= 原物件沒有影響</span></span><br><span class="line"><span class="built_in">console</span>.log(objectCP); <span class="comment">// &#123; p1: '111', p2: '444', p3: '333' &#125;</span></span><br></pre></td></tr></table></figure>

<p>如同 Object.assign，第二層還是會有<strong>參考特性影響原物件問題</strong></p>
<h2 id="深拷貝方法-JSON-stringify"><a href="#深拷貝方法-JSON-stringify" class="headerlink" title="深拷貝方法 - JSON.stringify"></a>深拷貝方法 - JSON.stringify</h2><p><code>JSON.stringify</code> 常見應用為 Local Storge 等存儲操作，他也可以使用在深拷貝應用！<br>主要利用 <code>JSON.stringify</code> 把物件轉成字串，再用 <code>JSON.parse</code> 把字串轉為物件，如下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Eric'</span>,</span><br><span class="line">    weight: <span class="number">60</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dataCP = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line"><span class="comment">// 操作第一層 ： 不影響原物件</span></span><br><span class="line">dataCP.push(&#123;</span><br><span class="line">  name: <span class="string">'Alice'</span>,</span><br><span class="line">  weight: <span class="number">50</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 操作第二層 ： 不影響原物件</span></span><br><span class="line">dataCP[<span class="number">0</span>].name = <span class="string">'Emma'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data); <span class="comment">// [ &#123; name: 'Eric', weight: 60 &#125; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(dataCP); <span class="comment">// [ &#123; name: 'Emma', weight: 60 &#125;, &#123; name: 'Alice', weight: 50 &#125; ]</span></span><br></pre></td></tr></table></figure>

<p>這種方式可以達到真正的 Deep Copy，但只限於 JSON 格式，像物件中的 function 就會顯示 undefined，不過也夠用拉~</p>
<h2 id="深拷貝方法-extend"><a href="#深拷貝方法-extend" class="headerlink" title="深拷貝方法 - $.extend"></a>深拷貝方法 - $.extend</h2><p>jQuery 也有提供一個方法可以完成深拷貝，利用 <code>$.extend</code> 指定強制深拷貝，如下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Eric'</span>,</span><br><span class="line">    weight: <span class="number">60</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dataCP = $.extend(<span class="literal">true</span>, [], data);</span><br><span class="line"><span class="comment">// 操作第一層 ： 不影響原物件</span></span><br><span class="line">dataCP.push(&#123;</span><br><span class="line">  name: <span class="string">'Alice'</span>,</span><br><span class="line">  weight: <span class="number">50</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 操作第二層 ： 不影響原物件</span></span><br><span class="line">dataCP[<span class="number">0</span>].name = <span class="string">'Emma'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data); <span class="comment">// [ &#123; name: 'Eric', weight: 60 &#125; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(dataCP); <span class="comment">// [ &#123; name: 'Emma', weight: 60 &#125;, &#123; name: 'Alice', weight: 50 &#125; ]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Deep Copy</tag>
      </tags>
  </entry>
  <entry>
    <title>解析 CSS Flexbox 佈局模型</title>
    <url>/2019-11-07-css-flexbox/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前我一直都是使用 float、position 來排版，但當網頁元素越來越多，相對的結構也會越來越複雜，且 float 還需要搭配 clearfix 來解決塌陷等麻煩問題；到了 CSS3 時代，推出了新型的 Flexbox 佈局模式，徹底改善傳統排版繁瑣等問題，就連 Bootstrap4 都引進了，好東西！不學嗎？</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>Flexbox 佈局模型原理</li>
<li>Flexbox 外容器相關屬性</li>
<li>Flexbox 內元件相關屬性</li>
<li>Flexbox 實際應用</li>
</ul>
<h2 id="Flexbox-佈局模型原理"><a href="#Flexbox-佈局模型原理" class="headerlink" title="Flexbox 佈局模型原理"></a>Flexbox 佈局模型原理</h2><img src="https://i.imgur.com/X1bETh4.png" alt="Flexbox 佈局模型原理">

<p>Flexbox 主要由<strong>外容器</strong>與<strong>內元件</strong>組成，外容器可利用相關屬性<strong>操作軸線以控制內元件位置</strong>，內元件也可利用相關屬性<strong>操作自身對於容器的響應變化</strong>。</p>
<h2 id="Flexbox-外容器相關屬性"><a href="#Flexbox-外容器相關屬性" class="headerlink" title="Flexbox 外容器相關屬性"></a>Flexbox 外容器相關屬性</h2><p>接下來開始使用 Flex 來做排版，在任何元素下將 display 設為 flex 即可包裝成 flex 容器，相對的元素下第一層項目也會包裝成 flex 子元件，而容器可配置的相關屬性如下：</p>
<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
<h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p>執行操作：<strong>控制軸線排列方向</strong><br>相關可配置屬性：</p>
<ul>
<li>row：預設值，從左到右，從上到下</li>
<li>row-reverse：與 row 相反</li>
<li>column：從上到下，從左到右</li>
<li>column-reverse：與 column 相反</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row; <span class="comment">// row-reverse 、 column 、 column-reverse</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://i.imgur.com/kesyCMp.jpg" alt="flex-direction">

<h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p>執行操作：<strong>控制元件超出範圍是否換行</strong><br>注意事項：<strong>元件總寬度 &gt; 100% = 平均分配寬度 = 不會換行</strong><br>相關可配置屬性：</p>
<ul>
<li>nowrap：預設值，不換行</li>
<li>wrap：換行</li>
<li>wrap-reverse：換行並相反排列</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap; <span class="comment">// wrap 、 wrap-reverse</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://i.imgur.com/F4YdUGb.png" alt="flex-wrap">

<h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p>執行操作：<strong>flex-direction 與 flex-wrap 縮寫</strong><br>相關可配置屬性：</p>
<ul>
<li>flex-direction 配置屬性</li>
<li>flex-wrap 配置屬性</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-flow</span>: row wrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p>執行操作：<strong>控制內元件在主軸對齊的位置</strong><br>相關可配置屬性：</p>
<ul>
<li>flex-start：預設值，對齊主軸起始位置</li>
<li>flex-end：對齊主軸終點位置</li>
<li>center：水平置中對齊</li>
<li>space-between：平均分配內元件，左右元件將會與主軸起始和主軸終點貼齊</li>
<li>space-around：平均分配內元件，間距也是平均分配</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start; <span class="comment">// flex-end 、 center 、 space-between 、 space-around</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://i.imgur.com/2zKnf4Q.png" alt="justify-content" width="90%">

<h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p>執行操作：<strong>控制內元件在交錯軸對齊的位置</strong><br>相關可配置屬性：</p>
<ul>
<li>flex-start：對齊交錯軸起始位置</li>
<li>flex-end：對齊交錯軸終點位置</li>
<li>center：垂直置中對齊</li>
<li>stretch：預設值，將內元件全部撐開至容器的高度</li>
<li>baseline：以所有內元件的基線為對齊標準</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start; <span class="comment">// flex-end 、 center 、 stretch 、 baseline</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://i.imgur.com/BRBsPMf.png" alt="align-items">

<h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p>執行操作：<strong>控制內元件存在多行時在交錯軸對齊的位置</strong><br>注意事項：<strong>與 align-items 有相同功能，align-content 只適用於控制多行的 flex 容器</strong><br>相關可配置屬性：</p>
<ul>
<li>flex-start：對齊交錯軸起始位置</li>
<li>flex-end：對齊交錯軸終點位置</li>
<li>center：垂直置中對齊</li>
<li>space-between：將第一行與最後一行分別對齊最上方與最下方</li>
<li>space-around：每行平均分配間距</li>
<li>stretch：預設值，將內元件全部撐開至容器的高度</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-flow</span>: row wrap;</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start; <span class="comment">// flex-sne 、 center 、 space-between 、 space-around 、 stretch</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://i.imgur.com/H2n2ZpQ.png" alt="align-content">

<h2 id="Flexbox-內元件相關屬性"><a href="#Flexbox-內元件相關屬性" class="headerlink" title="Flexbox 內元件相關屬性"></a>Flexbox 內元件相關屬性</h2><p>在一般開發中，善加利用外容器的相關屬性，差不多就可以解決一般常見的網頁排版問題，如有需要更為細節的處理，就可以利用內元件的相關屬性，進行個別元件調試，內元件可配置的相關屬性如下：</p>
<ul>
<li>align-self</li>
<li>order</li>
<li>flex</li>
</ul>
<h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p>執行操作：<strong>控制個別元件在交錯軸對齊的位置</strong><br>注意事項：<strong>用法如同 align-items ，可針對個別元件設置交錯軸位置，並覆蓋容器原有設置</strong><br>相關可配置屬性：</p>
<ul>
<li>flex-start：對齊交錯軸起始位置</li>
<li>flex-end：對齊交錯軸終點位置</li>
<li>center：垂直置中對齊</li>
<li>stretch：預設值，將內元件全部撐開至容器的高度</li>
<li>baseline：以所有內元件的基線為對齊標準</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.item2</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: flex-start; <span class="comment">// flex-end 、 center 、 stretch 、 baseline</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://i.imgur.com/ihCjyki.png" alt="align-self">

<h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>執行操作：<strong>指定個別元件排列順序</strong><br>注意事項：<strong>數字越小排序越前面，可為負數，元件預設值為 0</strong><br>相關可配置屬性：</p>
<ul>
<li>number：預設為 0，可為負數</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.order-1</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.order2</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.order3</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://i.imgur.com/YcVLKhk.jpg" alt="order">

<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>執行操作：<strong>指定個別元件利用剩餘空間進行收縮放大應用</strong><br>注意事項：<strong>flex 是縮寫，主要由 flex-grow、flex-shrink、flex-basis 組成，如果只設定單個屬性，預設為 flex-grow</strong><br>相關可配置屬性：</p>
<ul>
<li>flex-grow：當外容器將總空間分配給所有內元件後，如果有剩餘空間，則依造比例將原有自身空間加上分配空間，預設值為 0</li>
<li>flex-shrink：當外容器總空間小於所需分配內元件空間，指定內元件將進行收縮應用，預設值為 1</li>
<li>flex-basis：元件的基準值，可使用不同的單位值，預設值為 auto</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  &amp;--red &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://i.imgur.com/nAB5Ooe.jpg" alt="flex-grow-1">

<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">900px</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  &amp;--red &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;--purple &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://i.imgur.com/A9gyBOt.png" alt="flex-grow-2">

<h2 id="Flexbox-實際應用"><a href="#Flexbox-實際應用" class="headerlink" title="Flexbox 實際應用"></a>Flexbox 實際應用</h2><p>開發應用：<strong>navbar 導覽列</strong><br>額外說明：</p>
<ul>
<li>flex 子元件推擠：可使用 mr-auto 使自身右方元件向軸終點推擠</li>
<li>flex 子元件換行：可使用 w-100 使元件強迫換行，前提是容器需要有設定 wrap</li>
</ul>
<iframe height="265" style="width: 100%;" scrolling="no" title="Flex Hamburger Menu" src="https://codepen.io/awdr74100/embed/zVJmqx?height=265&theme-id=dark&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/awdr74100/pen/zVJmqx" target="_blank" rel="external nofollow noopener noreferrer">Flex Hamburger Menu</a> by awdr74100
  (<a href="https://codepen.io/awdr74100" target="_blank" rel="external nofollow noopener noreferrer">@awdr74100</a>) on <a href="https://codepen.io" target="_blank" rel="external nofollow noopener noreferrer">CodePen</a>.
</iframe>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript ES6 陣列處理方法</title>
    <url>/2019-10-26-javascript-arrayfunction/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在大部分語言，第一次接觸到的陣列處理方法不外乎是 for、while 等等，但現代開發講求效率以及可讀性，當有其他判斷需求，整個處理的結構就會變得很複雜，這次來紀錄一下 ES6 新增的幾種陣列處理方法，包括 filter、map 等方法，在實戰中，可大幅的幫助開發，自己使用下來，效果顯卓！</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>forEach()</li>
<li>filter()</li>
<li>find()</li>
<li>map()</li>
<li>every()</li>
<li>some()</li>
<li>reduce()</li>
</ul>
<h2 id="傳統陣列處理方法"><a href="#傳統陣列處理方法" class="headerlink" title="傳統陣列處理方法"></a>傳統陣列處理方法</h2><p>一般人對於陣列的處理方式大多都是使用 for 迴圈就可以滿足基本應用，主要利用<strong>迴圈變數</strong>取出<strong>陣列中的項目</strong>，再依序做處理，如下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> object = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Eric'</span>,</span><br><span class="line">    pay: <span class="number">23000</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Alice'</span>,</span><br><span class="line">    pay: <span class="number">26800</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> payTotal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; jsonData.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(jsonData[i].name); <span class="comment">// Eric、Alice</span></span><br><span class="line">  payTotal += jsonData[i].pay;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(payTotal); <span class="comment">// 49800</span></span><br></pre></td></tr></table></figure>

<p>雖然說傳統方法也不錯，不過當<strong>程序複雜時</strong>，難免會有<strong>可讀性較差</strong>等問題，如果要搭配其他方法做應用，整個程序只會變得更加複雜，ES6 新增的陣列處理方法就是為了解決這一個問題。</p>
<h2 id="初始作用陣列"><a href="#初始作用陣列" class="headerlink" title="初始作用陣列"></a>初始作用陣列</h2><p>在下面陳述 ES6 的陣列方法時，都會直接以實例的方式做紀錄，針對所作用的陣列，就直接記錄在這邊，可再自行比對。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> object = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Eric'</span>,</span><br><span class="line">    weight: <span class="number">60</span>,</span><br><span class="line">    age: <span class="number">28</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Alice'</span>,</span><br><span class="line">    weight: <span class="number">42</span>,</span><br><span class="line">    age: <span class="number">24</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Emma'</span>,</span><br><span class="line">    weight: <span class="number">46</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Owen'</span>,</span><br><span class="line">    weight: <span class="number">52</span>,</span><br><span class="line">    age: <span class="number">32</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h2 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach()"></a>Array.prototype.forEach()</h2><p><code>forEach()</code> 是陣列方法中最單純的一個，他也是最好理解的一個，用法類似於 for 迴圈，相比之下，更讓人容易理解，應用。如下範例：</p>
<ul>
<li>特性：可直接利用參數操作陣列內容</li>
<li>callback 參數：currentItem、index、array</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">object.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item.weight); <span class="comment">// 項目：60、42、46、52</span></span><br><span class="line">  <span class="built_in">console</span>.log(index); <span class="comment">// 索引：0,1,2,3</span></span><br><span class="line">  <span class="built_in">console</span>.log(array); <span class="comment">// 陣列：指向所作用陣列</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">object.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item.age &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item); <span class="comment">// &#123; name: 'Emma', weight: 46, age: 18 &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> people = object.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item.weight == <span class="number">46</span>; <span class="comment">// forEach 無法 return，所以這寫法是無效的</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(people); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter()"></a>Array.prototype.filter()</h2><p><code>filter()</code> 是我最愛使用的一個方法！傳統過濾陣列都是使用 for 迴圈加上許多判斷式， <code>filter()</code> 結合了兩者功能，配合箭頭函式，大幅提高效率與可讀性。如下範例：</p>
<ul>
<li>特性：依序判斷項目內容，如果為 True 即放入新陣列，最後回傳新陣列</li>
<li>callback 參數：currentItem、index、array</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data1 = object.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 所有項目都為false，新陣列為空</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data2 = object.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.weight &gt;= <span class="number">60</span>; <span class="comment">// 體重大於等於60放入新陣列</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data3 = object.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item.age &lt;= <span class="number">20</span>); <span class="comment">// 配合箭頭函式</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data1); <span class="comment">// []空陣列</span></span><br><span class="line"><span class="built_in">console</span>.log(data2); <span class="comment">// [ &#123; name: 'Eric', weight: 60, age: 28 &#125; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(data3); <span class="comment">// [ &#123; name: 'Emma', weight: 46, age: 18 &#125; ]</span></span><br></pre></td></tr></table></figure>

<h2 id="Array-prototype-find"><a href="#Array-prototype-find" class="headerlink" title="Array.prototype.find()"></a>Array.prototype.find()</h2><p><code>find()</code> 類似於 <code>filter()</code> ，不過其處理為回傳首個符合的項目，還有一個類似方法叫 <code>findIndex()</code> ，處理方式與 <code>find()</code> 相同，不過是回傳索引值。如下範例：</p>
<ul>
<li>特性：依序判斷項目內容，回傳第一次判斷為 True 的項目</li>
<li>callback 參數：currentItem、index、array</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data1 = object.find(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 所有項目都為False，回傳undefined</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data2 = object.find(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.weight &lt; <span class="number">50</span>; <span class="comment">// 體重大於等於60，回傳項目</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data3 = object.find(<span class="function">(<span class="params">item</span>) =&gt;</span> item.age &gt;= <span class="number">18</span>); <span class="comment">// 配合箭頭函式</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data1); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(data2); <span class="comment">// &#123; name: 'Alice', weight: 42, age: 24 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(data3); <span class="comment">// &#123; name: 'Eric', weight: 60, age: 28 &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map()"></a>Array.prototype.map()</h2><p><code>map()</code> 主要用來做陣列的修改，或是整體項目的判斷，通常可搭配<strong>展開</strong>做內容新增。如下範例：</p>
<ul>
<li>特性：依序處理項目內容，回傳陣列長度等於作用陣列長度</li>
<li>callback 參數：currentItem、index、array</li>
<li>注意：預設項目內容為 undefined</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data1 = object.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data2 = object.map(<span class="function">(<span class="params">item</span>) =&gt;</span> item.age &gt; <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data3 = object.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...item,</span><br><span class="line">    overweight: item.weight &gt; <span class="number">50</span> ? <span class="string">'過重'</span> : <span class="string">'正常'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data1); <span class="comment">// [ undefined, undefined, undefined, undefined ]</span></span><br><span class="line"><span class="built_in">console</span>.log(data2); <span class="comment">// [ true, true, false, true ]</span></span><br><span class="line"><span class="built_in">console</span>.log(data3); <span class="comment">// [ &#123; name: 'Eric', weight: 60, age: 28, overweight: '過重' &#125;...]</span></span><br></pre></td></tr></table></figure>

<h2 id="Array-prototype-every"><a href="#Array-prototype-every" class="headerlink" title="Array.prototype.every()"></a>Array.prototype.every()</h2><p><code>every()</code> 可用來檢查陣列項目是否符合條件，類似於 AND 處理，<strong>全部項目都符合</strong>，回傳 True。如下範例：</p>
<ul>
<li>特性：判斷全部項目是否都符合條件，否則回傳 False</li>
<li>callback 參數：currentItem、index、array</li>
<li>注意：回傳內容只有 True 和 Flase</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data1 = object.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.age &gt;= <span class="number">18</span>; <span class="comment">// 全部符合條件</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data2 = object.every(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.weight &lt; <span class="number">50</span>; <span class="comment">// 部分符合條件</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data1); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(data2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="Array-prototype-some"><a href="#Array-prototype-some" class="headerlink" title="Array.prototype.some()"></a>Array.prototype.some()</h2><p><code>some()</code> 類似於 <code>every()</code> ，等同 OR 處理，<strong>部分項目符合</strong>，回傳 True，如下範例：</p>
<ul>
<li>特性：一個(含)以上項目符合條件，回傳 True</li>
<li>callback 參數：currentItem、index、array</li>
<li>注意：回傳內容只有 True 和 Flase</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data1 = object.some(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.age &gt;= <span class="number">24</span>; <span class="comment">// 部分符合條件</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data2 = object.some(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.weight &lt; <span class="number">40</span>; <span class="comment">// 全部項目都不符合</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data1); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(data2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce()"></a>Array.prototype.reduce()</h2><p><code>reduce()</code> 主要用來做<strong>累加應用</strong>或者是<strong>項目間的判斷</strong>，如下範例：</p>
<ul>
<li>特性：初始化數值(前一個數值)，可由後方傳入</li>
<li>callback 參數：accumulator、currentItem、index、array</li>
<li>注意：全部操作皆由初始數值與當前項目做應用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data1 = object.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, currentValue, currentIndex, array</span>) </span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data2 = object.reduce(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue.weight; <span class="comment">// 累加所有項目數值</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data3 = object.reduce(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(accumulator, currentValue.age); <span class="comment">// 與前一個比大小</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data1); <span class="comment">// 沒有回傳，會是undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(data2); <span class="comment">// 200</span></span><br><span class="line"><span class="built_in">console</span>.log(data3); <span class="comment">// 32</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 容易混淆的遍歷方法</title>
    <url>/2019-11-28-javascript-traverse/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前開發 Python 時，最常使用 for in 去遍歷物件；仔細想想，自己好像被 forEach 寵壞了，都忘記 JavaScript 也有相關的語法，實際使用下來，發現有部分觀念需要釐清，且某些情境可能不是這麼好用，需要搭配其他方法才能完成目的。此篇重點圍繞在 for、for/in、for/of、forEach 的使用情境與差別。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>遍歷物件基本操作</li>
<li>使用情境 - 非數值屬性</li>
<li>使用情境 - 陣列的空元素</li>
<li>使用情境 - this 的指向</li>
<li>結論</li>
</ul>
<h2 id="遍歷物件基本操作"><a href="#遍歷物件基本操作" class="headerlink" title="遍歷物件基本操作"></a>遍歷物件基本操作</h2><p>此篇文章將會針對下列 4 種迴圈語法做介紹，讓我們先來看看各語法的基本操作：</p>
<ul>
<li><strong>for</strong> (let index = 0; index &lt; array.length; index += 1) {}</li>
<li><strong>for</strong> (const key <strong>in</strong> object) {}</li>
<li><strong>for</strong> (const interator <strong>of</strong> object) {}</li>
<li>array.<strong>forEach</strong>((item, index, array) =&gt; {} )</li>
</ul>
<blockquote>
<p><strong>處理陣列：</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'Eric'</span>, <span class="string">'Allen'</span>, <span class="string">'Owen'</span>];</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>處理物件：</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Danny'</span>,</span><br><span class="line">  age: <span class="number">26</span>,</span><br><span class="line">  height: <span class="number">180</span>,</span><br><span class="line">  weight: <span class="number">72</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>作用對象：陣列<br>遍歷對象：無</p>
<blockquote>
<p><strong>遍歷陣列</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i]); <span class="comment">// Eric 、 Allen 、 Owen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h3><p>作用對象：陣列、物件<br>遍歷對象：鍵(key)</p>
<blockquote>
<p><strong>遍歷陣列</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// 0 、 1 、 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>遍歷物件</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj[key]); <span class="comment">// Danny 、 26 、 180 、 72</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>繼承屬性物件問題：hasOwnProperty</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.newType = <span class="string">'newValue'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[key]); <span class="comment">// Eric 、 Allen 、 Owen 、 newValue</span></span><br><span class="line">  <span class="keyword">if</span> (arr.hasOwnProperty(key)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[key]); <span class="comment">// Eric 、 Allen 、 Owen</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h3><p>作用對象：陣列<br>遍歷對象：值(value)</p>
<blockquote>
<p><strong>遍歷陣列</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// Eric 、 Allen 、 Owen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>遍歷物件：搭配 Object.values() - ES8 新增</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> <span class="built_in">Object</span>.values(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// Danny 、 26 、 180 、 72</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>遍歷物件：搭配 Object.entries() - ES8 新增</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// name 、 age 、 height 、 weight</span></span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// Danny 、 26 、 180 、 72</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>遍歷陣列：搭配 Array.prototype.entries() - ES6 新增</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> iterator <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(iterator); <span class="comment">// [ 0, 'Eric' ] 、 [ 1, 'Allen' ] 、 [ 2, 'Owen' ]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>作用對象：陣列<br>遍歷對象：鍵(key)、值(value)、作用對象(array)</p>
<blockquote>
<p><strong>遍歷陣列</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.forEach(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">// Eric 、 Allen 、 Owen</span></span><br><span class="line">  <span class="built_in">console</span>.log(index); <span class="comment">// 0 、 1 、 2</span></span><br><span class="line">  <span class="built_in">console</span>.log(array); <span class="comment">// [ 'Eric', 'Allen', 'Owen' ]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>遍歷物件：搭配 Object.entries() - ES8 新增</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.entries(obj).forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> [key, value] = item;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// name 、 age 、 height 、 weight</span></span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// Danny 、 26 、 180 、 72</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="使用情境-非數值屬性"><a href="#使用情境-非數值屬性" class="headerlink" title="使用情境 - 非數值屬性"></a>使用情境 - 非數值屬性</h2><p>事實上 JavaScript 的陣列是類似列表的物件，這就意味著我們可以直接給陣列新增屬性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'yellow'</span>];</span><br><span class="line"></span><br><span class="line">arr.newPrototype = <span class="string">'value'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 'red', 'blue', 'yellow', newPrototype: 'value' ]</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，遍歷相關語法對於非數值屬性的處理方式是不一樣的，主要分為兩種：</p>
<blockquote>
<p><strong>不會忽略非數字屬性：for in</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'yellow'</span>];</span><br><span class="line"></span><br><span class="line">arr.newPrototype = <span class="string">'value'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[key]); <span class="comment">// red 、 blue 、 yellow 、 value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>會忽略非數字屬性：for、for of、forEach</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'yellow'</span>];</span><br><span class="line"></span><br><span class="line">arr.newPrototype = <span class="string">'value'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- for --- */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i]); <span class="comment">// red 、 blue 、 yellow</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- for of --- */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// red 、 blue 、 yellow</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- forEach --- */</span></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">// red 、 blue 、 yellow</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>由上面測試可得知，使用 for in 時，會連同非數字屬性也一起遍歷，其他 3 種則不會，正常來講，不應該連同非數字屬性一起遍歷才對，<strong>遍歷陣列時，應該避免使用 for in</strong>，轉而使用其他三種遍歷語法。</p>
<h2 id="使用情境-陣列的空元素"><a href="#使用情境-陣列的空元素" class="headerlink" title="使用情境 - 陣列的空元素"></a>使用情境 - 陣列的空元素</h2><p>JavaScript 中的陣列是允許有空元素的，如下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'red'</span>, , <span class="string">'blue'</span>];</span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">'black'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>奇怪的地方在於，遍歷相關語法對於空元素的處理方式卻是不一樣的，主要分為兩種：</p>
<blockquote>
<p><strong>跳過空元素：for in、forEach</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'red'</span>, , <span class="string">'blue'</span>];</span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">'black'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- for in --- */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[key]); <span class="comment">// red 、 blue 、 black</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- forEach --- */</span></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">// red 、 blue 、 black</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>不會跳過空元素：for、for of</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'red'</span>, , <span class="string">'blue'</span>];</span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">'black'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- for --- */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i]); <span class="comment">// red 、 undefined 、 blue 、 undefined 、 black</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- for of --- */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// red 、 undefined 、 blue 、 undefined 、 black</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>額外補充：JSON 也不支援空元素</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* --- JSON.stringify --- */</span></span><br><span class="line"><span class="keyword">let</span> arrString1 = [<span class="string">'red'</span>, , <span class="string">'blue'</span>, <span class="string">'black'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(arrString1)); <span class="comment">// ["red",null,"blue","black"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- JSON.parse --- */</span></span><br><span class="line"><span class="keyword">let</span> arrString2 = <span class="string">`["red", , "blue", "black"]`</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(arrString2)); <span class="comment">// SyntaxError: Unexpected token</span></span><br></pre></td></tr></table></figure>

<p>由上面測試可得知，for in、forEach 遇到空元素會直接跳過，for、for of 則不會，<strong>取決於你遍歷的目的是什麼，選擇相對應的方法</strong>，同時也得注意 JSON 是否支援等問題。</p>
<h2 id="使用情境-this-的指向"><a href="#使用情境-this-的指向" class="headerlink" title="使用情境 - this 的指向"></a>使用情境 - this 的指向</h2><p>在 JavaScript 中各遍歷語法對於 this 的指向都是大同小異的，基本上都是指向外部的 window 物件，唯獨 forEach 最特別，如下範例：</p>
<blockquote>
<p><strong>保留外部作用域：for、for in、for of</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'red'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- for --- */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- fpr in --- */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- for of --- */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>指向特定的對象：forEach</strong></p>
</blockquote>
<ul>
<li>非嚴謹模式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'red'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 定義 thisArg 參數 --- */</span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 30</span></span><br><span class="line">&#125;, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 未定義 thisArg 參數 --- */</span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 箭頭函式 --- */</span></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>嚴謹模式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>; <span class="comment">// JavaScript 嚴謹模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'red'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 定義 thisArg 參數 --- */</span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 30</span></span><br><span class="line">&#125;, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 未定義 thisArg 參數 --- */</span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// undefined</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 箭頭函式 --- */</span></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>由上例可看出，forEach 所指向的 this 是根據第 2 個 thisArg 參數所提供，相反的，<strong>如果 thisArg 參數未定義或為 null，this 將根據設定模式指向對應的對象，嚴謹模式下為 undefined，非嚴謹模式下為 window</strong>，盡可能的要求所有 callback function 必須使用箭頭函式。</p>
<h2 id="使用情境-中斷迴圈"><a href="#使用情境-中斷迴圈" class="headerlink" title="使用情境 - 中斷迴圈"></a>使用情境 - 中斷迴圈</h2><p>在一般遍歷語法中，使用 break、return 中斷迴圈是再正常不過的事情，但這兩個語法使用在 forEach 上是行不通的，相關範例如下：</p>
<blockquote>
<p><strong>中斷迴圈成功：for、for in、for of</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'black'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- for --- */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr[i] === <span class="string">'blue'</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- for in --- */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr[key] === <span class="string">'blue'</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- for of --- */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [index, value] <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (value === <span class="string">'blue'</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(index); <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>中斷迴圈失敗：forEach</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'black'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- break --- */</span></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="string">'blue'</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(index); <span class="comment">// SyntaxError: Illegal break statement</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- return --- */</span></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="string">'blue'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(index); <span class="comment">// 0 、 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>其他遍歷方法：every、some</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'black'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- every --- */</span></span><br><span class="line">arr.every(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="string">'blue'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(index); <span class="comment">// 0</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- some --- */</span></span><br><span class="line">arr.some(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="string">'blue'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(index); <span class="comment">// 0</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>由上例可看出，forEach 使用 break 會發生錯誤，使用 return 最多只能中斷當前遍歷項目，最後依然會遍歷後面的項目，個人建議，<strong>如果有中斷迴圈需求，請使用 for、for in、for of 方法，或者利用 every、some 依序判斷項目特性來完成操作</strong>。</p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>經過上面的討論，你會發現 for of 是遍歷陣列最可靠的方式，它比 for 語法簡潔，並且沒有 for in 與 forEach 那麼多奇怪的特例，唯二的缺點是取得索引值需要搭配其他方法才能完成，以及無法像 forEach 一樣鏈式操作物件；在 Airbnb 的 Style Guide 中，禁止使用 for 相關的遍歷方法，推薦使用 forEach 高階函數來完成遍歷，其主要原因為較容易推論結果，其實也蠻有道理的，除非遇到上述所講的特殊情境，使用 for of 較為容易，不然在一般情境中 forEach 或許是你更好的選擇。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>ES8</tag>
      </tags>
  </entry>
  <entry>
    <title>Gulp 前端自動化 - 編譯 Sass/SCSS</title>
    <url>/2019-12-31-gulp-gulpsass/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Sass/SCSS 是 CSS 的預處理器，擴充了既有 CSS 的語法、規則及功能，目前已經算是前端必備的工具，但 .sass/.scss 檔案是無法再 Browser 運行的，需要透過編譯器使之編譯成 CSS 檔案才能成功運行，這一次將介紹如何使用 gulp-sass 套件將 .sass/.scss 檔案編譯成 .css 檔案。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>gulp-sass 安裝</li>
<li>gulp-sass 基本使用</li>
<li>gulp-sass 可傳遞選項</li>
<li>補充：Dart Sass 與 Node Sass</li>
</ul>
<h2 id="gulp-sass-安裝"><a href="#gulp-sass-安裝" class="headerlink" title="gulp-sass 安裝"></a>gulp-sass 安裝</h2><blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/gulp-sass" target="_blank" rel="external nofollow noopener noreferrer">gulp-sass</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp-sass</span><br></pre></td></tr></table></figure>

<p>node-sass 為 gulp-sass 的相依套件，安裝 gulp-sass 的同時會連同 node-sass 一起安裝，代表本地端只須執行安裝 gulp-sass 的指令即可。</p>
<h2 id="gulp-sass-基本使用"><a href="#gulp-sass-基本使用" class="headerlink" title="gulp-sass 基本使用"></a>gulp-sass 基本使用</h2><p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── source&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── scss&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.scss     # SCSS 主檔案</span><br><span class="line">│</span><br><span class="line">├─── gulpfile.js          # Gulp 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json         # 安裝 gulp、gulp-sass</span><br></pre></td></tr></table></figure>

<p>撰寫 SCSS 範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$color-primary</span>: blue;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$color-primary</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>載入並使用 gulp-sass：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>); <span class="comment">// 載入 gulp-sass 套件</span></span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./source/scss/*.scss'</span>) <span class="comment">// SCSS 主檔案路徑</span></span><br><span class="line">    .pipe(sass().on(<span class="string">'error'</span>, sass.logError)) <span class="comment">// 使用 gulp-sass 進行編譯</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/css'</span>)); <span class="comment">// 編譯完成輸出路徑</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>執行指定任務：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gulp sass</span><br></pre></td></tr></table></figure>

<p>生成 <code>./public/css/all.css</code> 檔案，此時專案結構如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── public&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.css      # 編譯完成的 CSS 檔案</span><br><span class="line">│</span><br><span class="line">├─── source&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── scss&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.scss     # SCSS 主檔案</span><br><span class="line">│</span><br><span class="line">&#x2F;&#x2F; 以下省略</span><br></pre></td></tr></table></figure>

<p>執行 gulp sass 指令後便會將 <code>./source/scss/all.scss</code> 編譯到 <code>./public/css/all.css</code>，如果有即時編譯的需求，可使用 gulp.watch() 監控檔案變化，如下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'watch'</span>, () =&gt; &#123;</span><br><span class="line">  gulp.watch(<span class="string">'./source/**/*.scss'</span>, gulp.series(<span class="string">'sass'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="gulp-sass-可傳遞選項"><a href="#gulp-sass-可傳遞選項" class="headerlink" title="gulp-sass 可傳遞選項"></a>gulp-sass 可傳遞選項</h2><p>可參考 <a href="https://github.com/sass/node-sass#options" target="_blank" rel="external nofollow noopener noreferrer">Node Sass Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li>outputStyle：<code>nested</code> | <code>expanded</code> | <code>compact</code> | <code>compressed</code><br>指定輸出型態，默認為 <code>nested</code></li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'sass'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./source/**/*.scss'</span>)</span><br><span class="line">    .pipe(sass(&#123; <span class="attr">outputStyle</span>: <span class="string">'compressed'</span> &#125;).on(<span class="string">'error'</span>, sass.logError))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/css'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="補充：Dart-Sass-與-Node-Sass"><a href="#補充：Dart-Sass-與-Node-Sass" class="headerlink" title="補充：Dart Sass 與 Node Sass"></a>補充：Dart Sass 與 Node Sass</h2><div class="note warning">Dart Sass 與 Node Sass 都屬於 Sass 的編譯器，Dart Sass 具備編譯輸出為 JavaScript 的能力，目前為 Sass 的主要開發對象，這也代表各種新功能將優先引入；Node Sass 底層使用的是 LibSass，基於 C/C++ 編寫，這使其編譯速度快過 Dart Sass；對於一般開發建議使用 Node Sass，如有新功能的需求，可使用 Dart Sass。</div>

<p>在 gulp-sass 中，預設是使用 Node Sass，如果想將編譯器調整成 Dart Sass，可做以下動作：</p>
<blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/dart-sass" target="_blank" rel="external nofollow noopener noreferrer">dart-sass</a></p>
</blockquote>
<p>安裝 Dart Sass：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install dart-sass</span><br></pre></td></tr></table></figure>

<p>更改編譯器為 Dart Sass：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>);</span><br><span class="line"></span><br><span class="line">sass.compiler = <span class="built_in">require</span>(<span class="string">'dart-sass'</span>); <span class="comment">// 將編譯器調整為 Dart Sass</span></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./source/**/*.scss'</span>)</span><br><span class="line">    .pipe(sass(&#123; <span class="attr">outputStyle</span>: <span class="string">'compressed'</span> &#125;).on(<span class="string">'error'</span>, sass.logError))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/css'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp 4</tag>
        <tag>Node.js</tag>
        <tag>SCSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Gulp 前端自動化 - 環境安裝與執行</title>
    <url>/2019-12-24-gulp-install/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信大多數人多少都有聽過 Gulp 這個工具，但卻沒有實際的去使用過它，Gulp 是一個自動化工具，基於串流(Stream)的方式來完成所設立的任務(Task)，擁有豐富的套件可供使用，可滿足前端開發者大部分的需求。此篇將介紹 Gulp 的環境要如何安裝以及建立第一個 Task，關於套件的部分將會獨立在做介紹。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>Gulp 簡介</li>
<li>Gulp 安裝</li>
<li>Gulp 初始化專案</li>
<li>開發第一個 Gulp Task</li>
</ul>
<h2 id="Gulp-簡介"><a href="#Gulp-簡介" class="headerlink" title="Gulp 簡介"></a>Gulp 簡介</h2><img src="https://i.imgur.com/h4dIXip.png" alt="Gulp 介紹">

<p>在之前為了加強對於網頁元素的應用，我很常去觀看各大網站的原始碼，但有時會發現某些網站的代碼全部都擠在一起，非常難以閱讀，當時的我以為他們是故意的，到了後來才發現這個應用叫做壓縮代碼，通常在將要正式上線的網站都會有壓縮代碼的步驟，原因很簡單，以網站效能來說，大小的控管是非常重要的，多餘的空間就足以造成整體效能的低落，而壓縮代碼這個服務就是依靠 Gulp、Webpack 等相關工具來完成的，在這邊我們不討論 Webpack，以後有時間再作介紹，Gulp 不只可以幫助我們完成壓縮代碼服務，其中也包含以下功能：</p>
<ul>
<li>編譯 Sass、Pug、CoffeeScript 等預處理器</li>
<li>壓縮 HTML、CSS、JavaScript 代碼以及各類圖檔</li>
<li>建立具有 Livereload 的 Web Server</li>
<li>一鍵將專案部屬到 GitHub Page</li>
<li>other…</li>
</ul>
<p>事實上，前面所提到的功能都是依靠 Gulp 的套件來完成，Gulp 更像是一個水管，當水龍頭打開時也就代表任務開始，而水管中流的水就是我們的原始檔，在水流經過管道的節點處，我們可以截獲水源並利用套件做一些處理，當水源從出口流出，同時也代表任務結束，如同上圖所示，讓我們先從安裝開始說起。</p>
<h2 id="Gulp-安裝"><a href="#Gulp-安裝" class="headerlink" title="Gulp 安裝"></a>Gulp 安裝</h2><div class="note warning">本篇教學都是採用 Gulp 4，關於 Gulp 4 與 Gulp 3 的差異，之後將會再做介紹</div>

<p>Gulp 依賴 Node.js 環境，需先進行安裝。推薦使用 LTS 版本：</p>
<ul>
<li>LTS：長期維護版(較穩定)</li>
<li>Current：目前最新版(較為不穩定)</li>
</ul>
<p>安裝過程就不加以贅述，可使用以下指令查看是否正確安裝：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node -v</span><br></pre></td></tr></table></figure>

<img src="https://i.imgur.com/gVhAOaV.jpg" alt="node.js 查看是否正確安裝">

<p>在 Gulp 3 版，需要再全域與區域環境分別安裝 Gulp，關於全域與區域環境的差別，可參考下面：</p>
<ul>
<li>Window：代表全域環境或是本機環境</li>
<li>Local：代表區域環境或是專案環境</li>
</ul>
<p>通常需要再全域環境連同安裝的套件，都是打算使用套件在全域環境內的相關指令，如 Gulp、Vue、ESLint 等等。</p>
<p>在 Gulp 4 版，一樣都需要分別在全域與區域環境安裝 Gulp，不同的地方在於，Gulp 4 版的全域套件名稱為 <code>gulp-cli</code>，相關指令如下：</p>
<p>Gulp 3 版本，全域安裝指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp -g</span><br></pre></td></tr></table></figure>

<p>Gulp 4 版本，全域安裝指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp-cli -g</span><br></pre></td></tr></table></figure>

<p>在這邊我們使用 Gulp 4 為主要開發版本，當 Gulp 在全域環境安裝完成時，可以使用以下指令來檢查：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp -v</span><br></pre></td></tr></table></figure>

<img src="https://i.imgur.com/zG66E9x.jpg" alt="Gulp 查看是否正確安裝">

<p>從上面可以發現，我們全域環境的 CLI 工具已經安裝完成，版本為 2.2.0，但專案環境的 Gulp 卻是顯示 Unknown，因為我們尚未在專案環境安裝 Gulp，關於專案環境的安裝步驟，我們從初始化專案段落開始做介紹。</p>
<h2 id="Gulp-初始化專案"><a href="#Gulp-初始化專案" class="headerlink" title="Gulp 初始化專案"></a>Gulp 初始化專案</h2><p>接下來我們進行初始化專案的動作，使用以下指令生成 <code>package.json</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm init</span><br></pre></td></tr></table></figure>

<p>剛剛有提到專案環境尚未安裝 Gulp，使用以下指令安裝：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp</span><br></pre></td></tr></table></figure>

<p>在 npm 5 版本 <code>--save</code> 已成為預設指令，這也代表上面這道指令等同於下面這道指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp --save</span><br></pre></td></tr></table></figure>

<p>使用前面所提到的 <code>gulp -v</code> 檢查 Gulp 是否正確安裝，此時專案結構如下：</p>
<img src="https://i.imgur.com/7q8lF8h.jpg" alt="Gulp 目前狀態">

<p>觀察專案環境下是否成功安裝 Gulp，如果有版本號的顯示，就代表成功安裝囉(當前版本為 4.0.2)。接下來開始編寫第一個 Gulp Task 吧！</p>
<h2 id="開發第一個-Gulp-Task"><a href="#開發第一個-Gulp-Task" class="headerlink" title="開發第一個 Gulp Task"></a>開發第一個 Gulp Task</h2><p>接續上面範例，請先新增 <code>index.html</code> 與 <code>gulpfile.js</code> 這兩個檔案，此時專案結構如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── index.html           # HTML 主檔案(複製用)</span><br><span class="line">├─── gulpfile.js          # Gulp 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json         # 安裝 gulp</span><br></pre></td></tr></table></figure>

<p><code>gulpfile.js</code> 是 Gulp 專屬的配置檔案，所有的 Task 任務都是在這邊編寫完成，我們可以嘗試輸入以下內容到 <code>gulpfile.js</code> 檔案內：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gulpDemo/gulpfile.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'copyFile'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 'copyFile' 是任務名稱，可自行定義</span></span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./index.html'</span>).pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在前面我們有講解到關於 Gulp 運行的概念，如果以上面程式做為參考，可做出以下統整：</p>
<ul>
<li><code>gulp.task()</code>：創建名為 copyFile 的任務(水管名稱)</li>
<li><code>gulp.src()</code>：導入 index.html 這一個檔案(水的來源)</li>
<li><code>.pipe()</code>：以 <code>gulp.src()</code> 導入的檔案需做的處理(截獲水源所做的處理)</li>
<li><code>gulp.dest()</code>：檔案輸出的目錄(水該從何處流出)</li>
</ul>
<p>此時輸入以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp copyFile</span><br></pre></td></tr></table></figure>

<p>你會發現 Gulp 複製了 index.html 這一個檔案到新創建的 public 目錄裏頭，此時專案結構如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── public&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── index.html       # HTML 副本 (完成編譯)</span><br><span class="line">│</span><br><span class="line">├─── index.html           # HTML 主檔案(等待編譯)</span><br><span class="line">├─── gulpfile.js          # Gulp 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json         # 安裝 gulp</span><br></pre></td></tr></table></figure>

<p>相信你們已經猜到上面這道指令的功能，在任何的 Gulp 任務名稱下，我們都可以使用 <code>gulp + 任務名稱</code> 執行指定的任務，就像剛剛這一個 copyFile 任務，我們使用 <code>gulp copyFile</code> 執行這一個任務，而這一個任務內容為，從<code>./index.html</code> 載入原始檔，當我們遇到第一個 <code>pipe()</code> 建構的節點，需要針對內容作處裡，剛好處理內容為使用 <code>gulp.dest()</code> 輸出到目錄，這也是 public/index.html 被創建得原因。</p>
<p>恭喜你已經開發了第一個 Gulp Task，同時也學會開發 Gulp 大部分應用的能力，剩下的應用我們等到載入套件章節再做說明，基本上整個 Gulp 的流程差不多就是這個樣子，後面的教學都會以結合套件的方式作介紹，如果你等不及了，可以直接觀看下一篇文章。</p>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp 4</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Gulp 前端自動化 - 使用 Babel 編譯 ES6</title>
    <url>/2020-01-08-gulp-gulpbabel/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Babel 是一款 JavaScript 的編譯器，你可能會有疑問，JavaScript 不是可以直接在 Browser 上運行嗎？為何還需要編譯？事實上 JavaScript 從發行到現在，經過了許多版本的更新，常見的 ES6、ES7 都屬於較新的版本，最為穩定的版本為 ES5，兼容性也是最高的， Babel 的用意就是將較新版本的 JavaScript 編譯成穩定版本，以提高兼容性。此篇將介紹如何透過 gulp-babel 這個套件編譯我們的 JavaScript，後面也會補充介紹 @babel/runtime 與 @babel/polyfill 組件的使用。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>gulp-babel 安裝</li>
<li>gulp-babel 基本使用</li>
<li>gulp-babel 可傳遞選項</li>
<li>補充：@babel/runtime 與 @babel/polyfill 組件使用的必要</li>
<li>補充：@babel/runtime 使用方式</li>
<li>補充：@babel/polyfill 使用方式</li>
</ul>
<h2 id="gulp-babel-安裝"><a href="#gulp-babel-安裝" class="headerlink" title="gulp-babel 安裝"></a>gulp-babel 安裝</h2><blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/gulp-babel" target="_blank" rel="external nofollow noopener noreferrer">gulp-babel</a></p>
</blockquote>
<p>Babel 7：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp-babel @babel/core @babel/preset-env</span><br></pre></td></tr></table></figure>

<p>Babel 6：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp-babel@7 babel-core babel-preset-env</span><br></pre></td></tr></table></figure>

<p>在這邊我們使用 Babel 7 版本做示範，要注意的是 @babel/core 與 @babel/preset-env 並不是 gulp-babel 的相依套件，但我們還是必須依賴在此環境才能成功運行，所以必須連同這兩個套件一起安裝。與 gulp-sass 不同，安裝時會連同 node-sass 的環境一起幫你安裝。</p>
<h2 id="gulp-babel-基本使用"><a href="#gulp-babel-基本使用" class="headerlink" title="gulp-babel 基本使用"></a>gulp-babel 基本使用</h2><p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── source&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── js&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.js       # JavaScript 主檔案</span><br><span class="line">│</span><br><span class="line">├─── gulpfile.js          # Gulp 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json         # 安裝 gulp、gulp-babel</span><br></pre></td></tr></table></figure>

<p>撰寫 JavaScript ES6+ 版本代碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> people = &#123;</span><br><span class="line">  name: <span class="string">'Roya'</span>,</span><br><span class="line">  height: <span class="number">170</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(people)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>載入並使用 gulp-babel：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>); <span class="comment">// 載入 gulp-babel 套件</span></span><br><span class="line"></span><br><span class="line">gulp.task(</span><br><span class="line">  <span class="string">'babel'</span>,</span><br><span class="line">  () =&gt;</span><br><span class="line">    gulp</span><br><span class="line">      .src(<span class="string">'./source/js/*.js'</span>) <span class="comment">// javascript 檔案路徑</span></span><br><span class="line">      .pipe(</span><br><span class="line">        babel(&#123;</span><br><span class="line">          presets: [<span class="string">'@babel/env'</span>], <span class="comment">// 使用預設環境編譯</span></span><br><span class="line">        &#125;)</span><br><span class="line">      )</span><br><span class="line">      .pipe(gulp.dest(<span class="string">'./public/js/'</span>)) <span class="comment">// 編譯完成輸出路徑</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>執行指定任務：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp babel</span><br></pre></td></tr></table></figure>

<p>生成 <code>./public/js/all.js</code> 檔案，此時專案結構如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── public&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── js&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.js       # 編譯完成的 JavaScript 檔案(ES5 版本)</span><br><span class="line">│</span><br><span class="line">├─── source&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── js&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.js       # JavaScript 主檔案(包含 ES6+ 版本)</span><br><span class="line">│</span><br><span class="line">&#x2F;&#x2F; 以下省略</span><br></pre></td></tr></table></figure>

<p>讓我們打開編譯完成的 JavaScript 檔案，看看 Babel 究竟做了什麼處理：</p>
<!-- prettier-ignore-start -->
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_slicedToArray</span>(<span class="params">arr, i</span>) </span>&#123; <span class="keyword">return</span> _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_nonIterableRest</span>(<span class="params"></span>) </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Invalid attempt to destructure non-iterable instance"</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_iterableToArrayLimit</span>(<span class="params">arr, i</span>) </span>&#123; <span class="keyword">if</span> (!(<span class="built_in">Symbol</span>.iterator <span class="keyword">in</span> <span class="built_in">Object</span>(arr) || <span class="built_in">Object</span>.prototype.toString.call(arr) === <span class="string">"[object Arguments]"</span>)) &#123; <span class="keyword">return</span>; &#125; <span class="keyword">var</span> _arr = []; <span class="keyword">var</span> _n = <span class="literal">true</span>; <span class="keyword">var</span> _d = <span class="literal">false</span>; <span class="keyword">var</span> _e = <span class="literal">undefined</span>; <span class="keyword">try</span> &#123; <span class="keyword">for</span> (<span class="keyword">var</span> _i = arr[<span class="built_in">Symbol</span>.iterator](), _s; !(_n = (_s = _i.next()).done); _n = <span class="literal">true</span>) &#123; _arr.push(_s.value); <span class="keyword">if</span> (i &amp;&amp; _arr.length === i) <span class="keyword">break</span>; &#125; &#125; <span class="keyword">catch</span> (err) &#123; _d = <span class="literal">true</span>; _e = err; &#125; <span class="keyword">finally</span> &#123; <span class="keyword">try</span> &#123; <span class="keyword">if</span> (!_n &amp;&amp; _i[<span class="string">"return"</span>] != <span class="literal">null</span>) _i[<span class="string">"return"</span>](); &#125; <span class="keyword">finally</span> &#123; <span class="keyword">if</span> (_d) <span class="keyword">throw</span> _e; &#125; &#125; <span class="keyword">return</span> _arr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_arrayWithHoles</span>(<span class="params">arr</span>) </span>&#123; <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr)) <span class="keyword">return</span> arr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people = &#123;</span><br><span class="line">  name: <span class="string">'Roya'</span>,</span><br><span class="line">  height: <span class="number">170</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> _i = <span class="number">0</span>, _Object$entries = <span class="built_in">Object</span>.entries(people); _i &lt; _Object$entries.length; _i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> _Object$entries$_i = _slicedToArray(_Object$entries[_i], <span class="number">2</span>),</span><br><span class="line">    key = _Object$entries$_i[<span class="number">0</span>],</span><br><span class="line">    value = _Object$entries$_i[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>看到編譯完成的代碼，你的第一個想法大概都是 WTF … 這是什麼鬼？不用擔心，Babel 只是將你的代碼優化為兼容性較高版本的代碼，你也不需要針對這一個檔案做任何修改，可以直接給 HTML 讀取，執行結果如同未編譯的 JavaScript 檔案，你只需要專注於目標的編程，不管你用多新版本的代碼來實現，Babel 都可以幫你改善兼容性等相關問題。</p>
<h2 id="gulp-babel-可傳遞選項"><a href="#gulp-babel-可傳遞選項" class="headerlink" title="gulp-babel 可傳遞選項"></a>gulp-babel 可傳遞選項</h2><p>可參考 <a href="https://babeljs.io/docs/en/options#presets" target="_blank" rel="external nofollow noopener noreferrer">Babel Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li>minified：<code>true</code> | <code>false</code><br>壓縮代碼，默認為 <code>false</code></li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'babel'</span>, () =&gt;</span><br><span class="line">  gulp</span><br><span class="line">    .src(<span class="string">'./source/js/*.js'</span>)</span><br><span class="line">    .pipe(</span><br><span class="line">      babel(&#123;</span><br><span class="line">        presets: [<span class="string">'@babel/env'</span>],</span><br><span class="line">        minified: <span class="literal">true</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/js/'</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="補充：-babel-runtime-與-babel-polyfill-組件使用的必要"><a href="#補充：-babel-runtime-與-babel-polyfill-組件使用的必要" class="headerlink" title="補充：@babel/runtime 與 @babel/polyfill 組件使用的必要"></a>補充：@babel/runtime 與 @babel/polyfill 組件使用的必要</h2><div class="note danger">Babel 默認只針對 Syntax 做轉換，例如：箭頭函式、ES6 變數、Class 語法糖等等，而自帶的 API 與原生內置的 methods 需要透過 polyfill 後才能在瀏覽器正常運行。</div>

<p>當前使用 Babel 版本：<code>v7.7.7</code></p>
<hr>
<p>有礙於網上的文章都是以較舊版本的 Babel 作討論，針對新版的 @babel/runtime 與 @babel/polyfill 這兩大 Babel 最重要的組件都沒有細項討論，導致使用 Babel 7 版本時，各種運行錯誤，官方 API 雖然完整，但各章節並沒有連貫性，操作下來也不知道問題在哪，在我們探討這兩個組件之前，我們先來解釋這兩個組件到底是要幫我們解決什麼問題。</p>
<p>將 <code>./source/js/all.js</code> 檔案，修改為如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* --- 箭頭函式、ES6 變數、ES6 陣列方法 --- */</span></span><br><span class="line"><span class="keyword">let</span> color = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> result = color.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- Class 語法糖 --- */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- Promise 物件 --- */</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve();</span><br></pre></td></tr></table></figure>

<p>針對上面這一個 JavaScript 檔案，我們使用之前配置好的 gulp-babel 來編譯他，編譯結果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Cannot call a class as a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 箭頭函式、ES6 變數、ES6 陣列方法 --- */</span></span><br><span class="line"><span class="keyword">var</span> color = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> result = color.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- Class 語法糖 --- */</span></span><br><span class="line"><span class="keyword">var</span> Circle = <span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  _classCallCheck(<span class="keyword">this</span>, Circle);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- Promise 物件 --- */</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve();</span><br></pre></td></tr></table></figure>

<p>聰明的你應該發現問題了，Babel 不是會幫我們處理兼容性的問題嗎？<code>Array.prototype.filter</code> 與 <code>Promise</code> 物件好像都沒有編譯到的感覺，不要懷疑！Babel 真的沒有幫我們編譯到；事實上，如果你採用預設的編譯環境，<strong>Babel 只會針對語法 (Syntax) 做編譯，底層的 API 與原型擴展都不會進行編譯</strong>，這也就代表兼容性的問題根本沒有解決，在 IE 11 等較舊瀏覽器上面，它還是不知道什麼是 Promise，運行時就會發生錯誤；在這邊還有一個問題，<strong>Babel 針對 Class 語法糖的處理，你會發現它新增了一個全域的 function 當作語法糖的呼叫，這樣子的處理會造成嚴重的全域汙染</strong>，如果你有多個 JavaScript 檔案，同時都進行編譯的動作，產生出來的 function 都會是一模一樣的，不僅造成檔案的肥大，也有可能發生全域汙染影響運行等問題；這時候就會需要 @babel/runtime 與 @babel/polyfill 的幫忙，在介紹這兩個組件時，我們先將 Babel 的設定移置專屬的設定檔，如下所示：</p>
<p>路徑：<code>./gulpfile.js</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'babel'</span>, () =&gt;</span><br><span class="line">  gulp</span><br><span class="line">    .src(<span class="string">'./source/js/*.js'</span>)</span><br><span class="line">    .pipe(babel()) <span class="comment">// 將可傳遞選項移至 .babelrc</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/js/'</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>將原有的可傳遞選項移除，並新增 Babel 的專屬設定檔：</p>
<p>路徑：<code>./.babelrc</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"@babel/preset-env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時運行 gulp babel 指令，結果會是一模一樣的，在之後針對 Babel 所作的處理，我們都會使用 <code>.babelrc</code> 這一個檔案做修改，接下來讓我們開始正式介紹 @babel/runtime 與 @babel/polyfill。</p>
<h2 id="補充：-babel-runtime-使用方式"><a href="#補充：-babel-runtime-使用方式" class="headerlink" title="補充：@babel/runtime 使用方式"></a>補充：@babel/runtime 使用方式</h2><p>@babel/runtime 是由 Babel 提供的 polyfill 套件，由 core-js 和 regenerator 組成，core-js 是用於 JavaScript 的組合式標準化庫，它包含各種版本的 polyfills 實現；而 regenerator 是來自 facebook 的一個函式庫，主要用於實現 generator/yeild，async/await 等特性，我們先從安裝開始講起。</p>
<blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/@babel/runtime" target="_blank" rel="external nofollow noopener noreferrer">@babel/runtime</a>、<a href="https://www.npmjs.com/package/@babel/plugin-transform-runtime" target="_blank" rel="external nofollow noopener noreferrer">@babel/plugin-transform-runtime</a></p>
</blockquote>
<p>@babel/runtime：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install @babel/runtime</span><br></pre></td></tr></table></figure>

<p>@babel/plugin-transform-runtime：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install @babel/plugin-transform-runtime --save-dev</span><br></pre></td></tr></table></figure>

<p>在安裝 @babel/runtime 時，記得不要安裝錯誤，新版的是帶有 <code>@</code> 開頭的；同時也必須安裝 @babel/plugin-transform-runtime 這個套件，babel 在運行時是依賴 plugin 去做取用，這兩個套件雖然不是相依套件，但實際使用時缺一不可，在後面會有相關說明，在這邊我們先把這兩個套件裝好就可以了。</p>
<p>修改 <code>./.babelrc</code> 內容為下面範例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"@babel/preset-env"</span>],</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/plugin-transform-runtime"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"corejs"</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我們以之前 JavaScript 檔案進行示範，執行 gulp babel 指令進行編譯，結果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _interopRequireDefault = <span class="built_in">require</span>(<span class="string">'@babel/runtime/helpers/interopRequireDefault'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _classCallCheck2 = _interopRequireDefault(<span class="built_in">require</span>(<span class="string">'@babel/runtime/helpers/classCallCheck'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 箭頭函式、ES6 變數、ES6 陣列方法--- */</span></span><br><span class="line"><span class="keyword">var</span> color = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> result = color.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- class 語法糖 --- */</span></span><br><span class="line"><span class="keyword">var</span> Circle = <span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  (<span class="number">0</span>, _classCallCheck2[<span class="string">'default'</span>])(<span class="keyword">this</span>, Circle);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- Promise 物件 --- */</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve();</span><br></pre></td></tr></table></figure>

<p>從編譯後的結果可以得知，之前提到的 Class 語法糖全域汙染問題已經解決了，透過 @babel/plugin-transform-runtime 這個套件，它會幫我們分析是否有 polyfill 的需求，並自動透過 require 的方式，向 @babel/runtime 拿取 polyfill，簡單來講，<strong>@babel/runtime 提供了豐富的 polyfill 供組件使用，開發者可以自行 require，但自行 require 太慢了，使用 @babel/plugin-transform-runtime 可以自動分析並拿取 @babel/runtime 的 polyfill</strong>，這也是為什麼這兩個套件缺一不可的原因。</p>
<p>可能有些人還是有疑問，透過 require 的方式為什麼就能避免全域污染的問題？事實上，當初我也很困惑，結果恍然大悟，終於理解了，簡單來講，當初是因為 babel 會在全域環境宣告 function，只要同時有 1 個檔案以上需要編譯時，這些 function 就會相遇干擾，實際運行就會發生錯誤，透過 @babel/runtime 直接 require 的方式進行取用，最後編譯出來的檔案就不會汙染到全域環境，而是生成許多的 require 指令，<strong>Node.js 默認是從緩存中載入模組，一個模組被加載一次之後，就會在緩存中維持一個副本，如果遇到重複取用問題，會直接向緩存拿取副本，這也就代表每個模組在緩存中止存在一個實例</strong>。</p>
<p>仔細觀察，Babel 還是沒有幫我們編譯 Promise 物件，那是因為我們還沒有解放 @babel/runtime 這一個套件全部力量，由上面範例，你會發現我在 plugin 中傳遞了一個 corejs 選項，預設是關閉的，可傳遞的選項為：</p>
<table>
<thead>
<tr>
<th align="left">corejs 選項</th>
<th align="left">安裝指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">false</td>
<td align="left">npm install <span>-<span><span>-save<span> @babel/runtime</span></span></span></span></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">npm install <span>-<span><span>-save<span> @babel/runtime-corejs2</span></span></span></span></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">npm install <span>-<span><span>-save<span> @babel/runtime-corejs3</span></span></span></span></td>
</tr>
</tbody></table>
<p>事實上 @babel/runtime 有許多的擴展版本，在之前的範例中，我們都是將 corejs 給關閉，這也就導致它並沒有幫我們編譯底層的 API 與相關的方法，這次我們就來使用各版本進行編譯，記得要執行相對應的安裝指令喔！</p>
<p>修改 <code>./.babelrc</code> 內容為下面範例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"@babel/preset-env"</span>],</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/plugin-transform-runtime"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"corejs"</span>: <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>corejs2 版本編譯結果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _interopRequireDefault = <span class="built_in">require</span>(<span class="string">'@babel/runtime-corejs2/helpers/interopRequireDefault'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _promise = _interopRequireDefault(<span class="built_in">require</span>(<span class="string">'@babel/runtime-corejs2/core-js/promise'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _classCallCheck2 = _interopRequireDefault(<span class="built_in">require</span>(<span class="string">'@babel/runtime-corejs2/helpers/classCallCheck'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 箭頭函式、ES6 變數、ES6 陣列方法--- */</span></span><br><span class="line"><span class="keyword">var</span> color = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> result = color.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- class 語法糖 --- */</span></span><br><span class="line"><span class="keyword">var</span> Circle = <span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  (<span class="number">0</span>, _classCallCheck2[<span class="string">'default'</span>])(<span class="keyword">this</span>, Circle);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- Promise 物件 --- */</span></span><br><span class="line"><span class="keyword">var</span> promise = _promise[<span class="string">'default'</span>].resolve();</span><br></pre></td></tr></table></figure>

<p>corejs3 版本編譯結果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _interopRequireDefault = <span class="built_in">require</span>(<span class="string">'@babel/runtime-corejs3/helpers/interopRequireDefault'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _promise = _interopRequireDefault(<span class="built_in">require</span>(<span class="string">'@babel/runtime-corejs3/core-js-stable/promise'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _classCallCheck2 = _interopRequireDefault(<span class="built_in">require</span>(<span class="string">'@babel/runtime-corejs3/helpers/classCallCheck'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _filter = _interopRequireDefault(<span class="built_in">require</span>(<span class="string">'@babel/runtime-corejs3/core-js-stable/instance/filter'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 箭頭函式、ES6 變數、ES6 陣列方法--- */</span></span><br><span class="line"><span class="keyword">var</span> color = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> result = (<span class="number">0</span>, _filter[<span class="string">'default'</span>])(color).call(color, <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- class 語法糖 --- */</span></span><br><span class="line"><span class="keyword">var</span> Circle = <span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  (<span class="number">0</span>, _classCallCheck2[<span class="string">'default'</span>])(<span class="keyword">this</span>, Circle);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- Promise 物件 --- */</span></span><br><span class="line"><span class="keyword">var</span> promise = _promise[<span class="string">'default'</span>].resolve();</span><br></pre></td></tr></table></figure>

<p>從上面結果可以得知，<strong>corejs2 版本主要針對底層 API 做編譯，如 Promise、Fetch 等等；corejs3 版本主要針對底層 API 和相關實例方法，如 Array.pototype.filter，Array.pototype.map 等等</strong>，簡單來講，如果你要將兼容性的問題徹底解決，就得使用 corejs3 版本，到了這邊，我們之前所提到 Babel 的種種問題都已經獲得解決。</p>
<div class="note warning">使用 @babel/runtime 能夠在不汙染全域環境下提供相對應的 polyfill，擁有自動識別功能，在某些情況下，編譯出來的檔案大小可能比使用 @babel/polyfill 來的小，適合開發組件庫或對環境較為嚴格的專案</div>

<h2 id="補充：-babel-polyfill-使用方式"><a href="#補充：-babel-polyfill-使用方式" class="headerlink" title="補充：@babel/polyfill 使用方式"></a>補充：@babel/polyfill 使用方式</h2><p>@babel/polyfill 與 @babel/runtime 一直以來這兩者的差別都很模糊，網上的文章大多也都是複製官方的說明文檔，並沒有實際去使用，造成開發者一知半解的疑慮，這一次我們就來討論 @babel/polyfill 究竟要如何使用。先從安裝開始說起：</p>
<p>Babel 版本 &lt; <code>v7.4.0</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install @babel/polyfill</span><br></pre></td></tr></table></figure>

<p>Babel 版本 &gt;= <code>v7.4.0</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install core-js regenerator-runtime/runtime</span><br></pre></td></tr></table></figure>

<p>從 Babel &gt;= 7.4.0 後，@babel/polyfill 組件庫已被棄用，事實上 @babel/polyfill 本身就是由 stable 版本的 core-js 和 regenerator-runtime 組成，我們可以直接下載這兩個組件庫當作 @babel/polyfill 來使用，官方也推薦此做法，這邊要注意的是 regenerator-runtime 為 @babel/runtime 的相依套件，可以自行檢查是否有正確安裝。</p>
<p>修改 <code>./.babelrc</code> 內容為下面範例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"useBuiltIns"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"corejs"</span>: <span class="number">3</span> // 當前 core-js 版本</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我們使用之前 JavaScript 檔案進行示範，執行 gulp-babel 指令進行編譯，結果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Cannot call a class as a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 箭頭函式、ES6 變數、ES6 陣列方法 --- */</span></span><br><span class="line"><span class="keyword">var</span> color = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> result = color.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- class 語法糖 --- */</span></span><br><span class="line"><span class="keyword">var</span> Circle = <span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  _classCallCheck(<span class="keyword">this</span>, Circle);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- Promise 物件 --- */</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve();</span><br></pre></td></tr></table></figure>

<p>編譯結果就如同單純使用 Babel 一樣，只有針對語法 (Syntax) 做編譯，那是因為我們尚未開啟 polyfill 的功能，可通過更改 <code>useBuiltIns</code> 來變更模式，可選模式為 <code>false</code>、<code>usage</code>、<code>entry</code>，以下為各模式的編譯結果：</p>
<p>useBuiltIns：<code>usage</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'core-js/modules/es.array.filter'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'core-js/modules/es.object.to-string'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'core-js/modules/es.promise'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Cannot call a class as a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 箭頭函式、ES6 變數、ES6 陣列方法 --- */</span></span><br><span class="line"><span class="keyword">var</span> color = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> result = color.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- class 語法糖 --- */</span></span><br><span class="line"><span class="keyword">var</span> Circle = <span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  _classCallCheck(<span class="keyword">this</span>, Circle);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- Promise 物件 --- */</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve();</span><br></pre></td></tr></table></figure>

<p>很明顯的將 useBuiltIns 更改為 <code>usage</code>，就如同使用 @babel/runtime-corejs3 一樣，自動識別需要 require 的新語法，將兼容性問題徹底解決，不同的地方在於，@babel/runtime 在不汙染全域環境下提供 polyfill，而 @babel/polyfill 則是將需要兼容的新語法掛載到全局對象，這樣子的做法即會造成所謂的全局汙染，讓我們來看最後一個 useBuiltIns 選項。</p>
<p>useBuiltIns：<code>entry</code>：</p>
<div class="note warning">使用 entry 選項記得在前面 import core-js/stable 和 regenerator-runtime/runtime 組件庫</div>

<blockquote>
<p>待編譯檔案：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'core-js/stable'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'regenerator-runtime/runtime'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 箭頭函式、ES6 變數、ES6 陣列方法 --- */</span></span><br><span class="line"><span class="keyword">let</span> color = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> result = color.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- class 語法糖 --- */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- Promise 物件 --- */</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>完成編譯檔案：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'core-js/modules/es.symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'core-js/modules/es.symbol.description'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'core-js/modules/es.symbol.async-iterator'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...省略 500 多個包</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Cannot call a class as a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 箭頭函式、ES6 變數、ES6 陣列方法 --- */</span></span><br><span class="line"><span class="keyword">var</span> color = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> result = color.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- class 語法糖 --- */</span></span><br><span class="line"><span class="keyword">var</span> Circle = <span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  _classCallCheck(<span class="keyword">this</span>, Circle);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- Promise 物件 --- */</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve();</span><br></pre></td></tr></table></figure>

<p><code>entry</code> 這一個選項就簡單多了，沒有做任何的識別，直接將整個 ES 環境掛載到全局對象，確保瀏覽器可以兼容所有的新特性，但這樣子做的缺點也顯而易見，整個專案環境會較為肥大，你可能會好奇 <code>entry</code> 選項的必要，事實上 Babel 默認不會檢測第三方依賴組件，所以使用 <code>usage</code> 選項時，可能會出現引入第三方的代碼包未載入模組而引發的 Bug，這時就有使用 <code>entry</code> 的必要。</p>
<div class="note warning">@babel/polyfill 提供一次性載入或自動識別載入 polyfill 的功能，使用掛載全局對象的方法，達到兼容新特性目的，適合開發在專案環境，較不適合開發組件庫或工具包，存在汙染全局對象疑慮。</div>

<p>經過了一番對於 @babel/runtime 與 @babel/polyfill 的討論，相信各位已經了解兩者的差別，在這邊做一個總結：</p>
<ol>
<li><p>Babel 版本 &lt; <code>7.4.0</code>：</p>
<ul>
<li>開發組件庫、工具包，選擇 @babel/runtime</li>
<li>開發本地專案，選擇 @babel/polyfill</li>
</ul>
</li>
<li><p>Babel 版本 &gt;= <code>7.4.0</code></p>
<ul>
<li>配置較簡單，會汙染全域環境，選擇 @babel/polyfill</li>
<li>配置較繁瑣，不會汙染全域環境，選擇 @babel/runtime</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp 4</tag>
        <tag>Node.js</tag>
        <tag>Babel</tag>
      </tags>
  </entry>
  <entry>
    <title>Gulp 前端自動化 - 編譯 Pug</title>
    <url>/2020-01-02-gulp-gulppug/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Pug 原來的名稱為 Jade，是一套 HTML 的模板語言，你可以把它想像成 CSS 與 SCSS 的關係，Pug 可以幫助開發者簡化語法和模組化開發，一樣需要透過編譯器使之編譯成 HTML 才能正常運行，這次我們會使用 gulp-pug 來完成我們的編譯動作，在後面也會簡單介紹 Pug 的語法。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>gulp-pug 安裝</li>
<li>gulp-pug 基本使用</li>
<li>gulp-pug 可傳遞選項</li>
<li>補充：Pug 語法介紹</li>
</ul>
<h2 id="gulp-pug-安裝"><a href="#gulp-pug-安裝" class="headerlink" title="gulp-pug 安裝"></a>gulp-pug 安裝</h2><blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/gulp-pug" target="_blank" rel="external nofollow noopener noreferrer">gulp-pug</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp-pug</span><br></pre></td></tr></table></figure>

<p>舊版套件名稱為 gulp-jade，目前已棄用，原作者建議改使用 gulp-pug 來完成開發，基本上兩者是一樣的東西，由於商標的問題，名稱才由原本的 Jade 改成 Pug 。</p>
<h2 id="gulp-pug-基本使用"><a href="#gulp-pug-基本使用" class="headerlink" title="gulp-pug 基本使用"></a>gulp-pug 基本使用</h2><p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── source&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── index.pug        # Pug 主檔案</span><br><span class="line">│</span><br><span class="line">├─── gulpfile.js          # Gulp 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json         # 安裝 gulp、gulp-pug</span><br></pre></td></tr></table></figure>

<p>撰寫 Pug 範例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">html(lang&#x3D;&quot;en&quot;)</span><br><span class="line">    head</span><br><span class="line">        meta(charset&#x3D;&quot;UTF-8&quot;)</span><br><span class="line">        meta(name&#x3D;&quot;viewport&quot;, content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;)</span><br><span class="line">        meta(http-equiv&#x3D;&quot;X-UA-Compatible&quot;, content&#x3D;&quot;ie&#x3D;edge&quot;)</span><br><span class="line">        title Document</span><br><span class="line">    body</span><br><span class="line">        .container</span><br><span class="line">            .title 測試 Pug</span><br></pre></td></tr></table></figure>

<p>載入並使用 gulp-pug：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> pug = <span class="built_in">require</span>(<span class="string">'gulp-pug'</span>); <span class="comment">// 載入 gulp-pug 套件</span></span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'pug'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'source/**/*.pug'</span>) <span class="comment">// Pug 主檔案路徑</span></span><br><span class="line">    .pipe(pug()) <span class="comment">// 使用 gulp-pug 進行編譯</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/'</span>)); <span class="comment">// 編譯完成輸出路徑</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>執行指定任務：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp pug</span><br></pre></td></tr></table></figure>

<p>生成 <code>./public/index.html</code> 檔案，此時專案結構如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── public&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── index.html       # 編譯完成的 HTML 檔案</span><br><span class="line">│</span><br><span class="line">├─── source&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── index.pug        # Pug 主檔案</span><br><span class="line">│</span><br><span class="line">&#x2F;&#x2F; 以下省略</span><br></pre></td></tr></table></figure>

<p>執行 gulp pug 指令後便會將 <code>./source/index.pug</code> 編譯到 <code>./public/index.html</code>，如果有即時編譯的需求，可使用 gulp.watch() 監控檔案變化，如下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'watch'</span>, () =&gt; &#123;</span><br><span class="line">  gulp.watch(<span class="string">'./source/**/*.pug'</span>, gulp.series(<span class="string">'pug'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="gulp-pug-可傳遞選項"><a href="#gulp-pug-可傳遞選項" class="headerlink" title="gulp-pug 可傳遞選項"></a>gulp-pug 可傳遞選項</h2><p>可參考 <a href="https://pugjs.org/api/reference.html" target="_blank" rel="external nofollow noopener noreferrer">Pug Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li>pretty：<code>true</code> | <code>false</code><br>增加代碼可讀性，默認為 <code>false</code></li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'pug'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'source/**/*.pug'</span>)</span><br><span class="line">    .pipe(</span><br><span class="line">      pug(&#123;</span><br><span class="line">        pretty: <span class="literal">true</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'public/'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="補充：Pug-語法介紹"><a href="#補充：Pug-語法介紹" class="headerlink" title="補充：Pug 語法介紹"></a>補充：Pug 語法介紹</h2><blockquote>
<p>官網介紹：<a href="https://pugjs.org/api/getting-started.html" target="_blank" rel="external nofollow noopener noreferrer">Pug</a></p>
</blockquote>
<p>在前面有提到 Pug 可以幫助我們簡化語法和模組化開發，在這補充單元我們就針對這兩個特點去做說明，未來會有 Pug 完整的單元介紹，讓我們先來打好一點基礎以便未來更能夠得心應手。</p>
<p>針對 Pug 簡化語法的特點，相信大多人在上面範例已經有稍微了解到了，先來看看下面這個範例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">html(lang&#x3D;&quot;en&quot;)</span><br><span class="line">    head</span><br><span class="line">        meta(charset&#x3D;&quot;UTF-8&quot;)</span><br><span class="line">        meta(name&#x3D;&quot;viewport&quot;, content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;)</span><br><span class="line">        meta(http-equiv&#x3D;&quot;X-UA-Compatible&quot;, content&#x3D;&quot;ie&#x3D;edge&quot;)</span><br><span class="line">        title Document</span><br><span class="line">    body</span><br><span class="line">        .container</span><br><span class="line">            .col-md-4.d-flex.justify-content-center</span><br><span class="line">                p textContent</span><br><span class="line">            .col-md-4.d-flex.align-items-center</span><br><span class="line">                p textContent</span><br><span class="line">            .col-md-4</span><br></pre></td></tr></table></figure>

<p>上面這段程式碼等同於：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-4 d-flex justify-content-center"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>textContent<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-4 d-flex align-items-center"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>textContent<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-4"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>很明顯的 Pug 在撰寫時不需加入起始標籤與結束標籤也就是<code>&lt;</code>和<code>&gt;</code>，區分父子階層的準則為縮排，透過縮排就能將元素定義為子階層，整體的版面變得非常簡潔，讓我們來繼續來看 Pug 是如何進行模組化應用的。</p>
<p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── source&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── modules&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       ├─── head.pug     # head 模組 - 供載入用</span><br><span class="line">│       └─── navbar.pug   # navbar 模組 - 供載入用</span><br><span class="line">│   │</span><br><span class="line">│   ├─── index.pug        # 主要渲染檔案</span><br><span class="line">│   └─── layout.pug       # template 模板</span><br><span class="line">│</span><br><span class="line">&#x2F;&#x2F; 以下省略</span><br></pre></td></tr></table></figure>

<p>路徑：<code>./source/modules/head.pug</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">meta(charset&#x3D;&quot;UTF-8&quot;)</span><br><span class="line">meta(name&#x3D;&quot;viewport&quot;, content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;)</span><br><span class="line">meta(http-equiv&#x3D;&quot;X-UA-Compatible&quot;, content&#x3D;&quot;ie&#x3D;edge&quot;)</span><br><span class="line">title Document</span><br></pre></td></tr></table></figure>

<p>路徑：<code>./source/modules/navbar.pug</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.navbar 這是 Navbar</span><br></pre></td></tr></table></figure>

<p>路徑：<code>./source/layout.pug</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">html(lang&#x3D;&quot;en&quot;)</span><br><span class="line">    head</span><br><span class="line">        include .&#x2F;modules&#x2F;head.pug</span><br><span class="line">    body</span><br><span class="line">        block navbar</span><br><span class="line">        block content</span><br></pre></td></tr></table></figure>

<p>路徑：<code>./source/index.pug</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extend .&#x2F;layout.pug</span><br><span class="line"></span><br><span class="line">block content</span><br><span class="line">    .content 這是內容</span><br><span class="line"></span><br><span class="line">block navbar</span><br><span class="line">    include .&#x2F;modules&#x2F;navbar</span><br></pre></td></tr></table></figure>

<p>說明：在 Pug 中我們可以使用 <code>include</code> 方式插入內容，如同上面的 <code>head.pug</code> 與 <code>navbar.pug</code> 模塊，接著我們在主要的渲染檔案 <code>extned</code> 我們的 <code>layout</code> 檔案，這一個 <code>layout</code> 檔案就類似於我們的模板，定義了兩個 <code>block</code> 區塊，分別是 <code>navbar</code> 和 <code>content</code>，我們在 <code>index.pug</code> 這個主要檔案插入 <code>block</code> 內容，透過編譯，最後就會形成下面的 HTML 檔案：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"navbar"</span>&gt;</span>這是 Navbar<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>這是內容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我們可以針對上面這一個範例做出以下統整：</p>
<ul>
<li><code>include</code>：在指定的位置插入其他 Pug 內容</li>
<li><code>extend</code>：指定檔案當作延伸依據，通常搭配 <code>block</code></li>
<li><code>block</code>：宣告區塊名稱，<code>extend</code> 區塊所屬檔案時，可在 <code>block</code> 位置插入內容</li>
</ul>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp 4</tag>
        <tag>Node.js</tag>
        <tag>Pug</tag>
      </tags>
  </entry>
  <entry>
    <title>Gulp 前端自動化 - PostCSS 與 Autoprefixer</title>
    <url>/2020-01-12-gulp-gulppostcss/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>PostCSS 是一套使用 JavaScript 轉換 CSS 的工具，有別於以往 Sass、Less 等預處理器將檔案編譯成 CSS，PostCSS 是針對 CSS 後續所作行為處理的後處理器，在某些情境也有可能為前處理器，透過載入並使用 Plugin 的方式來完成目的，常見的使用情境為 CSS Prefix、CSS Conpress 等等。此篇將結合 gulp-postcss 與 gulp-sass 來說明，途中也會補充常見的 PostCSS Plugin，像是 autoprefixer 和 cssnano。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>gulp-postcss 安裝</li>
<li>gulp-postcss 基本使用</li>
<li>gulp-postcss 可傳遞選項</li>
<li>補充：Autoprefixer 與 Browserslist</li>
<li>補充：使用 cssnano 優化代碼</li>
</ul>
<h2 id="gulp-postcss-安裝"><a href="#gulp-postcss-安裝" class="headerlink" title="gulp-postcss 安裝"></a>gulp-postcss 安裝</h2><blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/gulp-postcss" target="_blank" rel="external nofollow noopener noreferrer">gulp-postcss</a>、<a href="https://www.npmjs.com/package/autoprefixer" target="_blank" rel="external nofollow noopener noreferrer">autoprefixer</a></p>
</blockquote>
<p>gulp-postcss：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp-postcss</span><br></pre></td></tr></table></figure>

<p>autoprefixer：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install autoprefixer</span><br></pre></td></tr></table></figure>

<p>autoprefixer 為 PostCSS 最為著名的 CSS Prefix 插件，前面會先以它當作第一個範例，請務必安裝。</p>
<h2 id="gulp-postcss-基本使用"><a href="#gulp-postcss-基本使用" class="headerlink" title="gulp-postcss 基本使用"></a>gulp-postcss 基本使用</h2><div class="note warning">此次範例會搭配 gulp-sass 一起使用，相關文章連結：<a href="https://awdr74100.github.io/2019-12-31-gulp-gulpsass/" target="_blank">gulp-sass</a></div>

<p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── source&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── scss&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.scss     # SCSS 主檔案</span><br><span class="line">│</span><br><span class="line">├─── gulpfile.js          # Gulp 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json         # 安裝 gulp、gulp-sass、gulp-postcss、autoprefixer</span><br></pre></td></tr></table></figure>

<p>撰寫 SCSS 範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$color-primary</span>: blue;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d-flex</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">flex-flow</span>: row wrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$color-primary</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>載入並使用 gulp-postcss：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>); <span class="comment">// 載入 gulp-sass 套件</span></span><br><span class="line"><span class="keyword">const</span> postcss = <span class="built_in">require</span>(<span class="string">'gulp-postcss'</span>); <span class="comment">// 載入 gulp-postcss 套件</span></span><br><span class="line"><span class="keyword">const</span> autoprefixer = <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>); <span class="comment">// 載入 autoprefixer 套件</span></span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./source/scss/*.scss'</span>)</span><br><span class="line">    .pipe(sass().on(<span class="string">'error'</span>, sass.logError))</span><br><span class="line">    .pipe(postcss([autoprefixer()])) <span class="comment">// 將編譯完成的 CSS 做 PostCSS 處理</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/css'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>執行指定任務：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp sass</span><br></pre></td></tr></table></figure>

<p>生成 <code>./public/css/all.css</code> 檔案，此時專案結構如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── public&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.css      # 編譯完成的 CSS 檔案</span><br><span class="line">│</span><br><span class="line">├─── source&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── scss&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.scss     # SCSS 主檔案</span><br><span class="line">│</span><br><span class="line">&#x2F;&#x2F; 以下省略</span><br></pre></td></tr></table></figure>

<p>以下為經過 autoprefixer 處理後的 CSS 檔案內容：</p>
<!-- prettier-ignore-start -->
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.d-flex</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">-webkit-box-pack</span>: center;</span><br><span class="line">          <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">-webkit-box-align</span>: center;</span><br><span class="line">          <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">-webkit-box-orient</span>: horizontal;</span><br><span class="line">  <span class="attribute">-webkit-box-direction</span>: normal;</span><br><span class="line">          <span class="attribute">flex-flow</span>: row wrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>你會發現 autoprefixer 替我們增加了相關的 CSS Prefix，以往這些語法都需要手動增加，造成許多的不方便，使用此插件即可自動幫我們完成此操作，我認為 PostCSS 更像是一個平台，利用豐富的插件進行前或後處理，有沒有發現我說的是前或後處理？事實上，某些 PostCSS 插件是以預處理的方式進行，比如說：<a href="https://www.npmjs.com/package/postcss-each" target="_blank" rel="external nofollow noopener noreferrer">postcss-each</a>，所以我們並不能直接把 PostCSS 定義為後處理器，得看使用的性質而定。</p>
<h2 id="gulp-postcss-可傳遞選項"><a href="#gulp-postcss-可傳遞選項" class="headerlink" title="gulp-postcss 可傳遞選項"></a>gulp-postcss 可傳遞選項</h2><p>可參考 <a href="https://www.npmjs.com/package/postcss-load-config" target="_blank" rel="external nofollow noopener noreferrer">postcss.config.js</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li><p>plugins：<code>Array</code> | <code>Function</code><br>需要使用的插件，默認為 <code>none</code></p>
</li>
<li><p>parser：<code>Function</code><br>採用的解析器，默認為 <code>default</code></p>
</li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>);</span><br><span class="line"><span class="keyword">const</span> postcss = <span class="built_in">require</span>(<span class="string">'gulp-postcss'</span>);</span><br><span class="line"><span class="keyword">const</span> autoprefixer = <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>);</span><br><span class="line"><span class="keyword">const</span> sugarss = <span class="built_in">require</span>(<span class="string">'sugarss'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./source/scss/*.scss'</span>)</span><br><span class="line">    .pipe(sass().on(<span class="string">'error'</span>, sass.logError))</span><br><span class="line">    .pipe(postcss([autoprefixer()], &#123; <span class="attr">parser</span>: sugarss &#125;)) <span class="comment">// 更改預設解析器</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/css'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="補充：Autoprefixer-與-Browserslist"><a href="#補充：Autoprefixer-與-Browserslist" class="headerlink" title="補充：Autoprefixer 與 Browserslist"></a>補充：Autoprefixer 與 Browserslist</h2><p>Browserslist 是一款用於不同前端工具之間共享目標瀏覽器和 Node.js 版本的工具，在之前如果要配置 Babel、ESLint、Autoprefixer 等相關工具，需要再各自的配置文件依序設定，造成許多的麻煩，Browserslist 就是為了解決這一個麻煩而建構，只需配置 <code>.browserslistrc</code> 文件，上面所提到的工具即可共享專案配置，這次我們就來介紹如何使用 Browserslist 配置 Autoprefixer 吧！</p>
<p>Browserslist 為 Autoprefixer 的相依套件，可自行檢查是否已完成安裝，如需下載，可使用以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install browserslist</span><br></pre></td></tr></table></figure>

<p>Browserslist 可以在 <code>package.json</code> 中設定，也可以用單獨檔案 <code>.browserslistrc</code> 設定。</p>
<blockquote>
<p>參考 <a href="https://github.com/browserslist/browserslist#full-list" target="_blank" rel="external nofollow noopener noreferrer">Full List</a> 進行配置：</p>
</blockquote>
<p>使用 <code>package.json</code> 配置:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"browserslist"</span>: [<span class="string">"last 2 version"</span>, <span class="string">"&gt; 1%"</span>, <span class="string">"IE 10"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增並使用 <code>.browserslistrc</code> 單獨檔案配置：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> gulp-demo/</span><br><span class="line"> │</span><br><span class="line"><span class="addition">+└─── .browserslistrc</span></span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">last 2 version</span><br><span class="line">&gt; 1%</span><br><span class="line">IE 10</span><br></pre></td></tr></table></figure>

<p>執行 <code>gulp scss</code> 指令進行編譯，結果如下：</p>
<!-- prettier-ignore-start -->
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.d-flex</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">display</span>: -ms-flexbox;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">-webkit-box-pack</span>: center;</span><br><span class="line">      <span class="attribute">-ms-flex-pack</span>: center;</span><br><span class="line">          <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">-webkit-box-align</span>: center;</span><br><span class="line">      <span class="attribute">-ms-flex-align</span>: center;</span><br><span class="line">          <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">-webkit-box-orient</span>: horizontal;</span><br><span class="line">  <span class="attribute">-webkit-box-direction</span>: normal;</span><br><span class="line">      <span class="attribute">-ms-flex-flow</span>: row wrap;</span><br><span class="line">          <span class="attribute">flex-flow</span>: row wrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>觀察編譯後檔案可以發現 Autoprefixer 針對了我們的 <code>.browserslistrc</code> 配置進行編譯，大功告成！</p>
<h2 id="補充：使用-cssnano-優化代碼"><a href="#補充：使用-cssnano-優化代碼" class="headerlink" title="補充：使用 cssnano 優化代碼"></a>補充：使用 cssnano 優化代碼</h2><p>cssnano 是基於 PostCSS 所建構的插件，集合多個優化、壓縮代碼等應用插件，使用方式也非常簡單，讓我們先從安裝開始說起：</p>
<blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/cssnano" target="_blank" rel="external nofollow noopener noreferrer">cssnano</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install cssnano</span><br></pre></td></tr></table></figure>

<p>載入並使用 cssnano：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>);</span><br><span class="line"><span class="keyword">const</span> postcss = <span class="built_in">require</span>(<span class="string">'gulp-postcss'</span>);</span><br><span class="line"><span class="keyword">const</span> autoprefixer = <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>);</span><br><span class="line"><span class="keyword">const</span> cssnano = <span class="built_in">require</span>(<span class="string">'cssnano'</span>); <span class="comment">// 載入 cssnano 套件</span></span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./source/scss/*.scss'</span>)</span><br><span class="line">    .pipe(sass().on(<span class="string">'error'</span>, sass.logError))</span><br><span class="line">    .pipe(postcss([autoprefixer(), cssnano()])) <span class="comment">// 陣列方式啟用插件</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/css'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>執行 gulp sass 指令即可進行編譯及壓縮代碼應用，基本上大部分情境都只需要使用 cssnano 默認配置，如果有特殊場景需要單獨配置，可參考官方的說明：</p>
<blockquote>
<p>預設轉換 vs 高級轉換：<a href="https://cssnano.co/optimisations/" target="_blank" rel="external nofollow noopener noreferrer">optimisations</a></p>
</blockquote>
<p>以下示範高級轉換配置：</p>
<p>安裝高級轉換組件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install cssnano-preset-advanced</span><br></pre></td></tr></table></figure>

<p>更改 cssnano 的 preset 選項：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>);</span><br><span class="line"><span class="keyword">const</span> postcss = <span class="built_in">require</span>(<span class="string">'gulp-postcss'</span>);</span><br><span class="line"><span class="keyword">const</span> autoprefixer = <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>);</span><br><span class="line"><span class="keyword">const</span> cssnano = <span class="built_in">require</span>(<span class="string">'cssnano'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./source/scss/*.scss'</span>)</span><br><span class="line">    .pipe(sass().on(<span class="string">'error'</span>, sass.logError))</span><br><span class="line">    .pipe(postcss([autoprefixer(), cssnano(&#123; <span class="attr">preset</span>: <span class="string">'advanced'</span> &#125;)])) <span class="comment">// 更改 cssnano 預設 preset</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/css'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>編譯即可看到結果。</p>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp 4</tag>
        <tag>Node.js</tag>
        <tag>SCSS</tag>
        <tag>PostCSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Gulp 前端自動化 - Browsersync 瀏覽器同步測試工具</title>
    <url>/2020-01-14-gulp-browsersync/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在開發 Web 應用時，我們很常針對瀏覽器執行重新整理的指令，以便查看最新修改過後結果，從專案開始到結束，我們可能按了無數次的 F5，造成效率的低落，這時我們就可以使用 BrowserSync 這款工具，BrowserSync 能讓瀏覽器實現、快速響應你的文件修改(HTML、JavaScript、CSS、Sass、Less)並自動刷新頁面，啟動時會在本地端開啟一個虛擬伺服器，這也代表了不同裝置間能夠依靠伺服器位址同步更新並觀看頁面，無論你是前端還是後端工程師，都非常建議使用這款工具。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>BrowserSync 安裝</li>
<li>BrowserSync 基本使用</li>
<li>BrowserSync 可傳遞選項</li>
</ul>
<h2 id="BrowserSync-安裝"><a href="#BrowserSync-安裝" class="headerlink" title="BrowserSync 安裝"></a>BrowserSync 安裝</h2><blockquote>
<p>套件連結：<a href="https://browsersync.io/docs/gulp" target="_blank" rel="external nofollow noopener noreferrer">browser-sync</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install browser-sync</span><br></pre></td></tr></table></figure>

<p>npm 上有一款名為 browsersync 的套件，這個套件並不是 BrowserSync 官方的套件，正確的套件名稱為 browser-sync，請安裝正確的官方套件，以便後面的範例能夠順利進行。</p>
<h2 id="BrowserSync-基本使用"><a href="#BrowserSync-基本使用" class="headerlink" title="BrowserSync 基本使用"></a>BrowserSync 基本使用</h2><div class="note warning">此次範例會結合 gulp-sass 套件一起使用，相關文章連結：<a href="https://awdr74100.github.io/2019-12-31-gulp-gulpsass/" target="_blank">gulp-sass</a></div>

<p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── source&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── scss&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.scss     # SCSS 主檔案</span><br><span class="line">│   │</span><br><span class="line">│   └─── index.html       # HTML 主檔案</span><br><span class="line">│</span><br><span class="line">├─── gulpfile.js          # Gulp 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json         # 安裝 gulp、gulp-sass、browser-sync</span><br></pre></td></tr></table></figure>

<p>載入並使用 browser-sync：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>);</span><br><span class="line"><span class="keyword">const</span> browserSync = <span class="built_in">require</span>(<span class="string">'browser-sync'</span>).create();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 編譯 Sass/SCSS --- */</span></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./source/scss/*.scss'</span>)</span><br><span class="line">    .pipe(sass().on(<span class="string">'error'</span>, sass.logError))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/css'</span>))</span><br><span class="line">    .pipe(browserSync.stream()); <span class="comment">// &lt;= 注入更改內容</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 複製 HTML 主檔案 --- */</span></span><br><span class="line">gulp.task(<span class="string">'copyHTML'</span>, (done) =&gt; &#123;</span><br><span class="line">  gulp</span><br><span class="line">    .src(<span class="string">'./source/*.html'</span>)</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">    .pipe(browserSync.stream()); <span class="comment">// &lt;= 注入更改內容</span></span><br><span class="line">  done();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 監控指定目錄是否更改 --- */</span></span><br><span class="line">gulp.task(<span class="string">'watch'</span>, () =&gt; &#123;</span><br><span class="line">  browserSync.init(&#123;</span><br><span class="line">    server: &#123;</span><br><span class="line">      baseDir: <span class="string">'./public'</span>, <span class="comment">// &lt;= 指向虛擬伺服器需存取的資料夾</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  gulp.watch(<span class="string">'./source/*.html'</span>, gulp.series(<span class="string">'copyHTML'</span>));</span><br><span class="line">  gulp.watch(<span class="string">'./source/**/*.scss'</span>, gulp.series(<span class="string">'sass'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>執行指定任務：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp watch</span><br></pre></td></tr></table></figure>

<p>此時瀏覽器會開啟指向 <code>./public</code> 資料夾的虛擬伺服器(localhost:xxxx)，配合 <code>gulp.watch()</code> 的使用，能夠在編寫 <code>./source</code> 資料夾中的指定檔案時(檔案有更動時)，實現 LiveReload 的效果，從此之後都不需要在按 F5 重新整理囉。</p>
<p>可能有人已經發現上面這段代碼的 Bug 了，在執行 gulp watch 時，雖然會直接開啟 localhost 伺服器，但執行的代碼並不是最新的，需要觸發指定目錄的更改，才能夠執行編譯並渲染最新畫面，正確的流程應該為執行 gulp watch 指令時，我們需要再開啟 localhost 伺服器之前，執行 <code>sass</code> 與 <code>copyHTML</code> 任務，已讓虛擬伺服器渲染最新的畫面，針對上述所提到的問題，我們可以新增一個 Gulp Task：</p>
<div class="note warning">當任務名稱為 default 時，只須執行 gulp 指令即可執行任務，不需要執行完整的 gulp default 指令</div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'default'</span>, gulp.series(<span class="string">'copyHTML'</span>, <span class="string">'sass'</span>, <span class="string">'watch'</span>));</span><br></pre></td></tr></table></figure>

<p>這是一個名為 default 的 Task，主要利用了 <code>gulp.series()</code> 同步進行任務語法來完成，也就代表當執行 gulp 指令時，會依序執行 <code>copyHTML</code>、<code>sass</code>、<code>watch</code> 任務，此時的結果正好符合我們的預期，問題也就解決了。</p>
<h2 id="BrowserSync-可傳遞選項"><a href="#BrowserSync-可傳遞選項" class="headerlink" title="BrowserSync 可傳遞選項"></a>BrowserSync 可傳遞選項</h2><p>可參考 <a href="https://www.browsersync.io/docs/options" target="_blank" rel="external nofollow noopener noreferrer">BrowserSync Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li><p>port：<code>Number</code><br>端口號碼，默認為 <code>3000</code></p>
</li>
<li><p>reloadDelay：<code>Number</code><br>瀏覽器重新加載時間(以毫秒為單位)，默認為 <code>0</code></p>
</li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'watch'</span>, () =&gt; &#123;</span><br><span class="line">  browserSync.init(&#123;</span><br><span class="line">    server: &#123;</span><br><span class="line">      baseDir: <span class="string">'./public'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    port: <span class="number">6600</span>,</span><br><span class="line">    reloadDelay: <span class="number">2000</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  gulp.watch(<span class="string">'./source/*.html'</span>, gulp.series(<span class="string">'copyHTML'</span>));</span><br><span class="line">  gulp.watch(<span class="string">'./source/**/*.scss'</span>, gulp.series(<span class="string">'sass'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp 4</tag>
        <tag>Node.js</tag>
        <tag>SCSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Gulp 前端自動化 - 壓縮 HTML、CSS、JavaScript 代碼</title>
    <url>/2020-01-17-gulp-gulphtmlmin-gulpcleancss-gulpuglify/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在正式上線的網站中，壓縮代碼已經算是不可或缺的一個流程，具有節省空間和提高網頁整體效能等效益，這次來介紹如何使用 gulp-htmlmin、gulp-clean-css、gulp-uglify 三個套件幫助我們壓縮代碼。後面也會補充 gulp-uglify 無法處理 ES6+ 版本代碼，該如何解決等內容。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>gulp-htmlmin、gulp-clean-css、gulp-uglify 安裝</li>
<li>gulp-htmlmin、gulp-clean-css、gulp-uglify 基本使用</li>
<li>gulp-htmlmin、gulp-clean-css、gulp-uglify 可傳遞選項</li>
<li>補充：gulp-uglify 無法編譯 ES6+ 版本代碼</li>
</ul>
<h2 id="gulp-htmlmin、gulp-clean-css、gulp-uglify-安裝"><a href="#gulp-htmlmin、gulp-clean-css、gulp-uglify-安裝" class="headerlink" title="gulp-htmlmin、gulp-clean-css、gulp-uglify 安裝"></a>gulp-htmlmin、gulp-clean-css、gulp-uglify 安裝</h2><blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/gulp-htmlmin" target="_blank" rel="external nofollow noopener noreferrer">gulp-htmlmin</a>、<a href="https://www.npmjs.com/package/gulp-clean-css" target="_blank" rel="external nofollow noopener noreferrer">gulp-clean-css</a>、<a href="https://www.npmjs.com/package/gulp-uglify" target="_blank" rel="external nofollow noopener noreferrer">gulp-uglify</a></p>
</blockquote>
<p>用於 HTML 壓縮：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp-htmlmin</span><br></pre></td></tr></table></figure>

<p>用於 CSS 壓縮：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp-clean-css</span><br></pre></td></tr></table></figure>

<p>用於 JavaScript 壓縮：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp-uglify</span><br></pre></td></tr></table></figure>

<p>以上三個套件分別用於不同的語言，均無任何相依套件需下載。網上很多人是使用 gulp-minify-css 套件進行 CSS 壓縮處理，但目前這一個套件已被棄用，原作者推薦使用 gulp-clean-css，後面教學都會以這一個套件進行示範。</p>
<h2 id="gulp-htmlmin、gulp-clean-css、gulp-uglify-基本使用"><a href="#gulp-htmlmin、gulp-clean-css、gulp-uglify-基本使用" class="headerlink" title="gulp-htmlmin、gulp-clean-css、gulp-uglify 基本使用"></a>gulp-htmlmin、gulp-clean-css、gulp-uglify 基本使用</h2><p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── source&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── style.css    # CSS 主檔案</span><br><span class="line">│   │</span><br><span class="line">│   └─── js&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── main.js      # JavaScript 主檔案</span><br><span class="line">│   │</span><br><span class="line">│   └─── index.html       # HTML 主檔案</span><br><span class="line">│</span><br><span class="line">├─── gulpfile.js          # Gulp 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json         # 安裝 gulp、gulp-htmlmin、gulp-clean-css、gulp-uglify</span><br></pre></td></tr></table></figure>

<p>載入並使用 gulp-htmlmin、gulp-clean-css、gulp-uglify：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>); <span class="comment">// 載入 gulp-htmlmin 套件</span></span><br><span class="line"><span class="keyword">const</span> cleanCSS = <span class="built_in">require</span>(<span class="string">'gulp-clean-css'</span>); <span class="comment">// 載入 gulp-clean-css 套件</span></span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>); <span class="comment">// 載入 gulp-uglify 套件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 壓縮 HTML --- */</span></span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'source/*.html'</span>)</span><br><span class="line">    .pipe(htmlmin(&#123; <span class="attr">collapseWhitespace</span>: <span class="literal">true</span> &#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'public/'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 壓縮 CSS --- */</span></span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'source/css/*.css'</span>)</span><br><span class="line">    .pipe(cleanCSS(&#123; <span class="attr">compatibility</span>: <span class="string">'ie8'</span> &#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'public/css'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 壓縮 JavaScript --- */</span></span><br><span class="line">gulp.task(<span class="string">'minify-js'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'source/js/*.js'</span>)</span><br><span class="line">    .pipe(uglify())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'public/js'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 同步執行全部任務 --- */</span></span><br><span class="line">gulp.task(<span class="string">'minify'</span>, gulp.parallel(<span class="string">'minify-html'</span>, <span class="string">'minify-css'</span>, <span class="string">'minify-js'</span>));</span><br></pre></td></tr></table></figure>

<p>執行指定任務：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp minify</span><br></pre></td></tr></table></figure>

<p>在 <code>./public</code> 資料夾下，會自動生成壓縮過後的 <code>index.html</code>、<code>style.css</code>、<code>main.js</code> 檔案，此後如果有壓縮代碼的需求，就都不需要依賴線上的工具了，本地端即可完成操作，非常的方便；可能會有人問，壓縮類型只限代碼相關嗎？當然不只！包含各類型圖片都可以進行壓縮，我們就不需要再依靠類似 <a href="https://tinypng.com/" target="_blank" rel="external nofollow noopener noreferrer">tinypng</a> 等服務完成了，相關內容將在下一篇文章在做介紹。</p>
<h2 id="gulp-htmlmin、gulp-clean-css、gulp-uglify-可傳遞選項"><a href="#gulp-htmlmin、gulp-clean-css、gulp-uglify-可傳遞選項" class="headerlink" title="gulp-htmlmin、gulp-clean-css、gulp-uglify 可傳遞選項"></a>gulp-htmlmin、gulp-clean-css、gulp-uglify 可傳遞選項</h2><p>可參考 <a href="https://github.com/kangax/html-minifier#options-quick-reference" target="_blank" rel="external nofollow noopener noreferrer">gulp-htmlmin Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li><p>collapseWhitespace：<code>true</code> | <code>false</code><br>折疊空白字元，默認為 <code>false</code></p>
</li>
<li><p>removeComments：<code>true</code> | <code>false</code><br>刪除 HTML 註釋，默認為 <code>false</code></p>
</li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'minify-html'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'source/*.html'</span>)</span><br><span class="line">    .pipe(htmlmin(&#123; <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>, <span class="attr">removeComments</span>: <span class="literal">true</span> &#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'public/'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<p>可參考 <a href="https://github.com/jakubpawlowicz/clean-css#compatibility-modes" target="_blank" rel="external nofollow noopener noreferrer">gulp-clean-css Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li><p>compatibility：<code>*</code>、<code>ie9</code>、<code>ie8</code>、<code>ie7</code><br>兼容模式，默認為 <code>*</code> = Internet Explorer 10+ 兼容模式</p>
</li>
<li><p>level：<code>0</code>、<code>1</code>、<code>2</code><br>優化級別，默認為 <code>1</code></p>
</li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'minify-css'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'source/css/*.css'</span>)</span><br><span class="line">    .pipe(cleanCSS(&#123; <span class="attr">compatibility</span>: <span class="string">'ie8'</span>, <span class="attr">level</span>: <span class="number">2</span> &#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'public/css'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<p>可參考 <a href="https://github.com/mishoo/UglifyJS2#minify-options" target="_blank" rel="external nofollow noopener noreferrer">gulp-uglify Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li>compress：參考 <a href="https://github.com/mishoo/UglifyJS2#compress-options" target="_blank" rel="external nofollow noopener noreferrer">Compress options</a><br>傳遞一個對象以指定自定義壓縮選項，默認為 <code>{}</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'minify-js'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'source/js/*.js'</span>)</span><br><span class="line">    .pipe(</span><br><span class="line">      uglify(&#123;</span><br><span class="line">        compress: &#123;</span><br><span class="line">          drop_console: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'public/js'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="補充：gulp-uglify-無法編譯-ES6-版本代碼"><a href="#補充：gulp-uglify-無法編譯-ES6-版本代碼" class="headerlink" title="補充：gulp-uglify 無法編譯 ES6+ 版本代碼"></a>補充：gulp-uglify 無法編譯 ES6+ 版本代碼</h2><p>相信大家都已經意識到前面 gulp-uglify 套件使用範例所引發的問題，如果你只是單純的使用 ES5 版本 JavaScript 代碼撰寫，是不會有任何問題的，重點在於，大部分人在撰寫專案時，多少都會使用 ES6+ 版本的代碼做撰寫，這時候如果使用 gulp-uglify 套件壓縮代碼是會跳出錯誤的，gulp-uglify 無法支援 ES6+ 代碼，如果要解決這個問題，我們可以使用 Babel 將 ES6+ 版本代碼編譯成 ES5 代碼，之後再進行 gulp-uglify 的處理，讓我們來嘗試看看是否能夠成功。</p>
<p>安裝 Babel 7：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp-babel @babel/core @babel/preset-env</span><br></pre></td></tr></table></figure>

<p>載入並使用 gulp-babel：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>); <span class="comment">// 載入 gulp-babel 套件</span></span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>); <span class="comment">// 載入 gulp-uglify 套件</span></span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'minify-js'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'source/js/*.js'</span>)</span><br><span class="line">    .pipe(</span><br><span class="line">      babel(&#123;</span><br><span class="line">        presets: [<span class="string">'@babel/env'</span>], <span class="comment">// 使用 Babel 編譯</span></span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .pipe(uglify()) <span class="comment">// 壓縮並優化 JavaScript</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'public/js'</span>)); <span class="comment">//</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>執行指定任務：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp minify-js</span><br></pre></td></tr></table></figure>

<p>成功編譯！搭配 Babel 確實可以順利完成編譯，但這也代表了此後如果需要使用 gulp-uglify 套件，都得搭配 Babel 才能順利編譯，仔細想想，單純的使用 gulp-uglify 就得引入 Babel，會不會有點大材小用？是否有其他方法呢？當然有！我們可以改使用 gulp-uglify-es 這一個套件，它是官方針對 ES6+ 版本釋出的套件，使用方式與 gulp-uglify 幾乎一樣，下面是相關的說明，由於操作幾乎一樣，就不在多做介紹。</p>
<blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/gulp-uglify-es" target="_blank" rel="external nofollow noopener noreferrer">gulp-uglify-es</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>CSS</tag>
        <tag>Gulp 4</tag>
        <tag>Node.js</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Gulp 前端自動化 - 生成 SourceMap 映射文件</title>
    <url>/2020-01-13-gulp-gulpsourcemaps/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前端發展越來越複雜，各種預處理器的使用，導致實際運行代碼不同於開發代碼，除錯(debug)變得困難重重，常見的例子為 Sass/SCSS、CoffeeScript 等預處理器，通常代碼出錯時，編譯器只會告訴你第幾行第幾列出現錯誤，但這對於編譯後的代碼是毫無作用的，我們需要得知的是尚未編譯代碼片段的錯誤，並不是以編譯代碼片段的錯誤；此篇將利用 gulp-sourcemaps 套件生成 SourceMap 文件改善此問題。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>gulp-sourcemaps 安裝</li>
<li>gulp-sourcemaps 基本使用</li>
<li>gulp-sourcemaps 可傳遞選項</li>
<li>補充：gulp-concat 生成 sourcemap</li>
</ul>
<h2 id="gulp-sourcemaps-安裝"><a href="#gulp-sourcemaps-安裝" class="headerlink" title="gulp-sourcemaps 安裝"></a>gulp-sourcemaps 安裝</h2><blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/gulp-sourcemaps" target="_blank" rel="external nofollow noopener noreferrer">gulp-sourcemaps</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp-sourcemaps</span><br></pre></td></tr></table></figure>

<p>我們可以使用 gulp-sourcemaps 套件生成 SourceMap 文件，不需要下載其他相依套件，開箱即可使用。</p>
<h2 id="gulp-sourcemaps-基本使用"><a href="#gulp-sourcemaps-基本使用" class="headerlink" title="gulp-sourcemaps 基本使用"></a>gulp-sourcemaps 基本使用</h2><div class="note warning">此次範例會結合 gulp-sass 套件一起使用，相關文章連結：<a href="https://awdr74100.github.io/2019-12-31-gulp-gulpsass/" target="_blank">gulp-sass</a></div>

<p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── source&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── scss&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── base</span><br><span class="line">│           │</span><br><span class="line">│           └─── _reset.scss</span><br><span class="line">│       │</span><br><span class="line">│       └─── component</span><br><span class="line">│           │</span><br><span class="line">│           └─── _button.scss</span><br><span class="line">│       │</span><br><span class="line">│       └─── helpers</span><br><span class="line">│           │</span><br><span class="line">│           └─── _variables.scss</span><br><span class="line">│       │</span><br><span class="line">│       └─── layout</span><br><span class="line">│           │</span><br><span class="line">│           └─── _footer.scss</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.scss     # SCSS 主檔案</span><br><span class="line">│</span><br><span class="line">├─── gulpfile.js          # Gulp 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json         # 安裝 gulp、gulp-sass、gulp-sourcemaps</span><br></pre></td></tr></table></figure>

<p><code>./source/scss/all.scss</code> 載入所有組件：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// base</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'base/reset'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// helpers</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'helpers/variables'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// component</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'component/button'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// layout</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'layout/footer'</span>;</span><br></pre></td></tr></table></figure>

<p>載入並使用 gulp-sourcemaps：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>); <span class="comment">// 載入 gulp-sass 套件</span></span><br><span class="line"><span class="keyword">const</span> sourcemaps = <span class="built_in">require</span>(<span class="string">'gulp-sourcemaps'</span>); <span class="comment">// 載入 gulp-sourcemaps 套件</span></span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./source/scss/*.scss'</span>)</span><br><span class="line">    .pipe(sourcemaps.init()) <span class="comment">// 初始化 sourcemaps</span></span><br><span class="line">    .pipe(sass().on(<span class="string">'error'</span>, sass.logError)) <span class="comment">// 使用 gulp-sass 進行編譯</span></span><br><span class="line">    .pipe(sourcemaps.write(<span class="string">'./'</span>)) <span class="comment">// 生成 sourcemaps 文件 (.map)</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'public/css'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>執行指定任務：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp sass</span><br></pre></td></tr></table></figure>

<p>生成 <code>./public/css/all.css</code> 和 <code>./public/css/all.css.map</code>檔案，開啟 DevTool 工具並觀察 sourcemap 是否映射成功：</p>
<img src="https://i.imgur.com/C1e8h43.jpg" alt="DevTool 觀察 sourcemap">

<p>從上圖可以發現，各元素映射的 Style 路徑從原本的 all.css 改為尚未編譯的 .scss 路徑，這樣的結果也就代表 sourcemap 映射成功，相同的原理也可套用在其他檔案類型身上，下面會再做補充。</p>
<h2 id="gulp-sourcemaps-可傳遞選項"><a href="#gulp-sourcemaps-可傳遞選項" class="headerlink" title="gulp-sourcemaps 可傳遞選項"></a>gulp-sourcemaps 可傳遞選項</h2><p>可參考 <a href="https://www.npmjs.com/package/gulp-sourcemaps#init-options" target="_blank" rel="external nofollow noopener noreferrer">sourcemap Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li>sourceMappingURLPrefix：<code>String</code><br>設定映射源的前綴，默認為 <code>none</code></li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./source/scss/*.scss'</span>)</span><br><span class="line">    .pipe(sourcemaps.init()) <span class="comment">// 初始化 sourcemaps</span></span><br><span class="line">    .pipe(sass().on(<span class="string">'error'</span>, sass.logError)) <span class="comment">// 使用 gulp-sass 進行編譯</span></span><br><span class="line">    .pipe(</span><br><span class="line">      sourcemaps.write(<span class="string">'./'</span>, &#123;</span><br><span class="line">        sourceMappingURLPrefix: <span class="string">'scss'</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    ) <span class="comment">// 寫入 sourcemaps</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'public/css'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="補充：gulp-concat-生成-sourcemap"><a href="#補充：gulp-concat-生成-sourcemap" class="headerlink" title="補充：gulp-concat 生成 sourcemap"></a>補充：gulp-concat 生成 sourcemap</h2><p>gulp-concat 套件主要為合併檔案用，通常在開發專案時，我們會引入許多的套件，比如說 jquery、bootstrap 等等，這些分散的檔案我們需要一個一個引入，造成許多的麻煩，這時我們就可以利用合併檔案的方式彙整成一個檔案，供 HTML 引入，這時問題就來了，這一個彙整檔案是無法映射原始單獨檔案的，造成除錯(debug)較為困難，這一個問題也可以由 sourcemap 來解決，讓我們先從安裝開始。</p>
<blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/gulp-concat" target="_blank" rel="external nofollow noopener noreferrer">gulp-concat</a>、<a href="https://www.npmjs.com/package/jquery" target="_blank" rel="external nofollow noopener noreferrer">jquery</a>、<a href="https://www.npmjs.com/package/bootstrap" target="_blank" rel="external nofollow noopener noreferrer">bootstrap</a></p>
</blockquote>
<p>gulp-concat：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp-concat</span><br></pre></td></tr></table></figure>

<p>jquery：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install jquery</span><br></pre></td></tr></table></figure>

<p>bootstrap：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install bootstrap</span><br></pre></td></tr></table></figure>

<p>此次範例會結合 jquery 與 bootstrap 一起使用，說明如何使用 gulp-concat 合併檔案並生成 sourcemap。</p>
<p>載入並使用 gulp-concat：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'vendorsJs'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src([</span><br><span class="line">      <span class="string">'./node_modules/jquery/dist/jquery.slim.min.js'</span>,</span><br><span class="line">      <span class="string">'./node_modules/bootstrap/dist/js/bootstrap.bundle.min.js'</span>,</span><br><span class="line">      <span class="string">'./source/js/all.js'</span>,</span><br><span class="line">    ])</span><br><span class="line">    .pipe(sourcemaps.init()) <span class="comment">// 初始化 sourcemaps</span></span><br><span class="line">    .pipe(concat(<span class="string">'vendors.js'</span>)) <span class="comment">// 合併檔案，名稱為：vendors.js</span></span><br><span class="line">    .pipe(sourcemaps.write(<span class="string">'./'</span>)) <span class="comment">// 寫入 sourcemaps</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/js'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>執行指定任務：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp vendorsJs</span><br></pre></td></tr></table></figure>

<p>生成 <code>./public/js/vendors.js</code> 和 <code>./public/js/vendors.js.map</code> 檔案，開啟 DevTool 工具並觀察 sourcemap 是否映射成功：</p>
<img src="https://i.imgur.com/jMPTkLZ.jpg" alt="DevTool 觀察 sourcemap">

<p>從上圖可以發現，頁面映射的 JavaScript 路徑從原本的 vendors.css 改為尚未編譯的各獨立檔案路徑，這樣的結果也就代表 sourcemap 映射成功。</p>
<p>從前面的幾個範例可以發現，sourcemap 的生成主要是利用 <code>sourcemaps.init()</code> 與 <code>sourcemaps.write()</code> 來完成，前者用來初始化，建議放置在第一個 pipe 節點，後者用來寫入 sourcemap，建議放在輸出文件的前一個 pipe 節點；事實上，gulp-sourcemaps 支援非常多種類型檔案生成 sourcemap，查詢檔案類型是否支援可參考下面連結：</p>
<blockquote>
<p>支援列表：<a href="https://github.com/gulp-sourcemaps/gulp-sourcemaps/wiki/Plugins-with-gulp-sourcemaps-support" target="_blank" rel="external nofollow noopener noreferrer">Plugins with gulp sourcemaps support</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp 4</tag>
        <tag>Node.js</tag>
        <tag>SCSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Gulp 前端自動化 - 自動清除檔案與資料夾</title>
    <url>/2020-01-15-gulp-del/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Gulp 主要用來幫助我們使前端的一切建構動作都能夠自動化，但你會發現先前的套件範例並不是這麼的自動化，主要缺點為當我們執行編譯時，都必須刪除之前編譯產生的內容，以確保最新編譯結果不互相干擾，這有違自動化的用意。此篇將介紹使用 del 套件在編譯開始前刪除上一次的編譯結果，達到完全自動化目的。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>del 安裝</li>
<li>del 基本使用</li>
<li>del 可傳遞選項</li>
<li>補充：gulp-clean 套件使用</li>
</ul>
<h2 id="del-安裝"><a href="#del-安裝" class="headerlink" title="del 安裝"></a>del 安裝</h2><blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/del" target="_blank" rel="external nofollow noopener noreferrer">del</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install del</span><br></pre></td></tr></table></figure>

<p>網上相關文章大多都是使用 <a href="https://www.npmjs.com/package/gulp-clean" target="_blank" rel="external nofollow noopener noreferrer">gulp-clean</a> 套件來做介紹，但在 Gulp 的官方範例中則是使用 del 套件作演示，其原因可能為單純的刪除檔案就不要另外造 Gulp 插件輪子了，使用 Node.js 原生套件是更明智的選擇。</p>
<h2 id="del-基本使用"><a href="#del-基本使用" class="headerlink" title="del 基本使用"></a>del 基本使用</h2><div class="note warning">此次範例會結合 gulp-sass 套件一起使用，相關文章連結：<a href="https://awdr74100.github.io/2019-12-31-gulp-gulpsass/" target="_blank">gulp-sass</a></div>

<p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── source&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── scss&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.scss     # SCSS 主檔案</span><br><span class="line">│</span><br><span class="line">├─── gulpfile.js          # Gulp 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json         # 安裝 gulp、gulp-sass、del</span><br></pre></td></tr></table></figure>

<p>載入並使用 del：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> del = <span class="built_in">require</span>(<span class="string">'del'</span>); <span class="comment">// 載入 del 套件</span></span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>); <span class="comment">// 載入 gulp-sass 套件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 編譯 SCSS --- */</span></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./source/scss/*.scss'</span>)</span><br><span class="line">    .pipe(sass().on(<span class="string">'error'</span>, sass.logError))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/css'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 刪除指定目錄檔案 -- */</span></span><br><span class="line">gulp.task(<span class="string">'clean'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> del([<span class="string">'./public'</span>]); <span class="comment">// 需刪除檔案或目錄</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 同步運行任務 --- */</span></span><br><span class="line">gulp.task(<span class="string">'build'</span>, gulp.series(<span class="string">'clean'</span>, <span class="string">'sass'</span>));</span><br></pre></td></tr></table></figure>

<p>執行指定任務：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp build</span><br></pre></td></tr></table></figure>

<p>由於編譯速度太快，導致我們無法明確知道 del 套件是否成功刪除先前編譯後檔案，我們可在 <code>./public</code> 資料夾下新增一個 <code>index.html</code> 檔案，再次執行 <code>gulp build</code> 指令。</p>
<p>測試 <code>public</code> 資料夾是否為新：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> ├─── public/</span><br><span class="line"> │   │</span><br><span class="line"><span class="addition">+│   └─── index.html   # 測試是否被刪除</span></span><br></pre></td></tr></table></figure>

<p>del 套件刪除成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├─── public&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.css</span><br></pre></td></tr></table></figure>

<p>del 套件刪除失敗：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├─── public&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.css</span><br><span class="line">│   │</span><br><span class="line">│   └─── index.html   # 依舊沒被刪除，代表資料夾不是新的</span><br></pre></td></tr></table></figure>

<p>由於我們是指定刪除整個 <code>./public</code> 資料夾，這也代表編譯完成時，整個資料夾都會是新的才對，del 套件是否使用成功可參考上面結構。</p>
<h2 id="del-可傳遞選項"><a href="#del-可傳遞選項" class="headerlink" title="del 可傳遞選項"></a>del 可傳遞選項</h2><p>可參考 <a href="https://github.com/sindresorhus/globby#options" target="_blank" rel="external nofollow noopener noreferrer">globby Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li>gitignore：<code>true</code> | <code>false</code><br>匹配 <code>.gitignore</code> 文件中的忽略項目，默認為 <code>false</code></li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'clean'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> del([<span class="string">'./public'</span>], &#123;</span><br><span class="line">    gitignore: <span class="literal">true</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="補充：gulp-clean-套件使用"><a href="#補充：gulp-clean-套件使用" class="headerlink" title="補充：gulp-clean 套件使用"></a>補充：gulp-clean 套件使用</h2><p>由於一部分人還是使用 gulp-clean 套件來完成刪除檔案與資料夾操作，故在這邊補充及簡單介紹。</p>
<blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/gulp-clean" target="_blank" rel="external nofollow noopener noreferrer">gulp-clean</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp-clean</span><br></pre></td></tr></table></figure>

<p>載入並使用 gulp-clean：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>); <span class="comment">// 載入 gulp-sass 套件</span></span><br><span class="line"><span class="keyword">const</span> clean = <span class="built_in">require</span>(<span class="string">'gulp-clean'</span>); <span class="comment">// 載入 gulp-clean 套件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 編譯 SCSS --- */</span></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./source/scss/*.scss'</span>)</span><br><span class="line">    .pipe(sass().on(<span class="string">'error'</span>, sass.logError))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/css'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 刪除指定目錄檔案 -- */</span></span><br><span class="line">gulp.task(<span class="string">'clean'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./public'</span>, &#123; <span class="attr">read</span>: <span class="literal">false</span>, <span class="attr">allowEmpty</span>: <span class="literal">true</span> &#125;).pipe(clean());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 同步運行任務 --- */</span></span><br><span class="line">gulp.task(<span class="string">'build'</span>, gulp.series(<span class="string">'clean'</span>, <span class="string">'sass'</span>));</span><br></pre></td></tr></table></figure>

<p>使用 gulp-clean 套件與 del 套件不同的地方在於，gulp-clean 使用 <code>gulp.src()</code> 作為刪除依據，而 del 則是直接使用本身 API 作為刪除依據，在上面範例中，我們在 <code>gulp.src()</code> 傳遞了一個物件，這個物件為自身的可傳遞選項，分別為 <code>read</code> 與 <code>allowEmpty</code> ，<code>read</code> 選項可避免 Gulp 讀取文件中的內容，單純的傳入任務依據，提高效能，而 <code>allowEmpty</code> 為允許任務依據為空，此選項可避免 gulp-clean 未偵測到 <code>./public</code> 資料時執行刪除所發生的錯誤，del 套件預設就有這一個選項，實際使用下來，del 套件明顯較為方便。</p>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp 4</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Gulp 前端自動化 - 壓縮並優化圖片</title>
    <url>/2020-01-20-gulp-gulpimagemin/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一次介紹完了代碼該如何壓縮，這一次我們來介紹該如何壓縮圖片，事實上，影響網頁載入速度最重要的關鍵就在於圖片，無論你的代碼優化的多麼完美，只要一張 size 較大的圖片存在於網頁上，就有可能造成渲染速度的低落，我們所要做的就是將這些圖片進行壓縮，盡可能的減少檔案大小，達到最佳化的目的；此篇將介紹如何使用 gulp-imagemin 套件進行圖片壓縮等應用。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>gulp-imagemin 安裝</li>
<li>gulp-imagemin 基本使用</li>
<li>gulp-imagemin 可傳遞選項</li>
<li>補充：optipng 圖片優化器</li>
</ul>
<h2 id="gulp-imagemin-安裝"><a href="#gulp-imagemin-安裝" class="headerlink" title="gulp-imagemin 安裝"></a>gulp-imagemin 安裝</h2><blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/gulp-imagemin" target="_blank" rel="external nofollow noopener noreferrer">gulp-imagemin</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp-imagemin</span><br></pre></td></tr></table></figure>

<p>gulp-imagemin 套件可以幫助我們壓縮 PNG、JPEG、GIF、SVG 等類型圖檔，無任何相依套件需安裝，直接安裝此套件即可。</p>
<h2 id="gulp-imagemin-基本使用"><a href="#gulp-imagemin-基本使用" class="headerlink" title="gulp-imagemin 基本使用"></a>gulp-imagemin 基本使用</h2><p>初始專案結構</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── source&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── img&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── IMG1.jpg     # JPG 圖檔</span><br><span class="line">│</span><br><span class="line">├─── gulpfile.js          # Gulp 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json         # 安裝 gulp、gulp-imagemin</span><br></pre></td></tr></table></figure>

<p>載入並使用 gulp-imagemin：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> imagemin = <span class="built_in">require</span>(<span class="string">'gulp-imagemin'</span>); <span class="comment">// 載入 gulp-imagemin 套件</span></span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'imagemin'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'source/img/*'</span>)</span><br><span class="line">    .pipe(imagemin()) <span class="comment">// 執行優化(壓縮)</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'public/img'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>執行指定任務：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp imagemin</span><br></pre></td></tr></table></figure>

<p>生成 <code>./public/img/IMG.JPG</code> 圖檔，觀察已壓縮與未壓縮檔案大小差異：</p>
<p>原圖：</p>
<img src="https://i.imgur.com/grzZrmK.png" alt="未壓縮圖片資訊">

<p>經過壓縮：</p>
<img src="https://i.imgur.com/EiWGpcr.png" alt="以壓縮圖片資訊">

<p>可以發現壓縮後的圖檔幾乎看不出有任何失真的狀況，而圖檔大小卻整整縮小了 50% 之多，從原有的 144.7KB 縮減為 65.1KB，可以說是相當的有感，以後就再也不需要去使用像 <a href="https://tinypng.com/" target="_blank" rel="external nofollow noopener noreferrer">tinypng</a> 等類似的服務囉。</p>
<h2 id="gulp-imagemin-可傳遞選項"><a href="#gulp-imagemin-可傳遞選項" class="headerlink" title="gulp-imagemin 可傳遞選項"></a>gulp-imagemin 可傳遞選項</h2><p>gulp-imagemin 與其他 Gulp 套件相比較為不同，主要依靠各類圖檔優化器進行設定，相關優化器如下：</p>
<ul>
<li><a href="https://github.com/imagemin/imagemin-gifsicle" target="_blank" rel="external nofollow noopener noreferrer">gifsicle</a>：GIF 圖片優化器</li>
<li><a href="https://github.com/imagemin/imagemin-mozjpeg" target="_blank" rel="external nofollow noopener noreferrer">mozjpeg</a>：JPEG 圖片優化器</li>
<li><a href="https://github.com/imagemin/imagemin-optipng" target="_blank" rel="external nofollow noopener noreferrer">optipng</a>：PNG 圖片優化器</li>
<li><a href="https://github.com/imagemin/imagemin-svgo" target="_blank" rel="external nofollow noopener noreferrer">svgo</a>：SVG 圖片優化器</li>
</ul>
<p>上述套件均為 gulp-imagemin 相依套件，無須進行任何下載，配置即可使用，下面為 mozjpeg 使用範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> imagemin = <span class="built_in">require</span>(<span class="string">'gulp-imagemin'</span>);</span><br><span class="line"><span class="keyword">const</span> mozjpeg = <span class="built_in">require</span>(<span class="string">'imagemin-mozjpeg'</span>); <span class="comment">// 載入 imagemin-mozjpeg 套件</span></span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'imagemin'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'source/img/*'</span>)</span><br><span class="line">    .pipe(</span><br><span class="line">      imagemin([</span><br><span class="line">        mozjpeg(&#123;</span><br><span class="line">          quality: <span class="number">75</span>, <span class="comment">// 壓縮品質</span></span><br><span class="line">        &#125;),</span><br><span class="line">      ])</span><br><span class="line">    )</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'public/img'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="補充：optipng-圖片優化器"><a href="#補充：optipng-圖片優化器" class="headerlink" title="補充：optipng 圖片優化器"></a>補充：optipng 圖片優化器</h2><p>這邊補充一下關於 optipng 圖片優化器的應用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> imagemin = <span class="built_in">require</span>(<span class="string">'gulp-imagemin'</span>);</span><br><span class="line"><span class="keyword">const</span> mozjpeg = <span class="built_in">require</span>(<span class="string">'imagemin-mozjpeg'</span>);</span><br><span class="line"><span class="keyword">const</span> optipng = <span class="built_in">require</span>(<span class="string">'imagemin-optipng'</span>); <span class="comment">// 載入 imagemin-optipng 套件</span></span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'imagemin'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'source/img/*'</span>)</span><br><span class="line">    .pipe(</span><br><span class="line">      imagemin([</span><br><span class="line">        mozjpeg(&#123;</span><br><span class="line">          quality: <span class="number">75</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">        optipng(&#123;</span><br><span class="line">          optimizationLevel: <span class="number">3</span>, <span class="comment">// 優化級別</span></span><br><span class="line">        &#125;),</span><br><span class="line">      ])</span><br><span class="line">    )</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'public/img'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>基本上圖片優化器使用方式都大同小異，參照官方 API 文件即可進行配置。</p>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp 4</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Gulp 前端自動化 - Minimist 命令行參數解析工具</title>
    <url>/2020-01-21-gulp-minimist/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通常在開發項目時，我們會分所謂的 development(開發環境) 與 production(生產環境)；常見的壓縮代碼流程就屬於 production 環境，你不會想再 development 環境壓縮代碼的，全部代碼都擠在一起，除起錯來相當困難。此篇將介紹如何使用 Minimist 命令行參數解析工具區分 Gulp 套件在 development 與 production 環境下的使用。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>minimist 安裝</li>
<li>minimist 基本使用</li>
<li>minimist 可傳遞選項</li>
<li>補充：Node.js 原生獲取命令行參數方法</li>
</ul>
<h2 id="minimist-安裝"><a href="#minimist-安裝" class="headerlink" title="minimist 安裝"></a>minimist 安裝</h2><blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/minimist" target="_blank" rel="external nofollow noopener noreferrer">minimist</a>、<a href="https://www.npmjs.com/package/gulp-if" target="_blank" rel="external nofollow noopener noreferrer">gulp-if</a></p>
</blockquote>
<p>minimist：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install minimist</span><br></pre></td></tr></table></figure>

<p>gulp-if：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp-if</span><br></pre></td></tr></table></figure>

<p>minimist 套件為解析命令行傳遞參數用，我們可以使用 gulp-if 套件針對這一個參數做判斷，區分出 development 與 production 環境分別運行那些套件。為使下面範例正常運行，請先將這兩個套件進行安裝。</p>
<h2 id="minimist-基本使用"><a href="#minimist-基本使用" class="headerlink" title="minimist 基本使用"></a>minimist 基本使用</h2><div class="note warning">此次範例會結合 gulp-sass、gulp-clean-css 套件一起使用，相關文章連結：<a href="https://awdr74100.github.io/2019-12-31-gulp-gulpsass/" target="_blank">gulp-sass</a>、<a href="https://awdr74100.github.io/2020-01-17-gulp-gulphtmlmin-gulpcleancss-gulpuglify/" target="_blank">gulp-clean-css</a></div>

<p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── source&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── scss&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.scss     # SCSS 主檔案</span><br><span class="line">│</span><br><span class="line">├─── gulpfile.js          # Gulp 配置檔案</span><br><span class="line">├─── test.js              # minimist 範例檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json         # 安裝 gulp、gulp-sass、gulp-clean-css、minimist、gulp-if</span><br></pre></td></tr></table></figure>

<p>minimist 語法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> parseArgs = <span class="built_in">require</span>(<span class="string">'minimist'</span>);</span><br><span class="line"><span class="keyword">const</span> argv = parseArgs(process.argv.slice(<span class="number">2</span>)); <span class="comment">// 取得命令行傳遞參數</span></span><br></pre></td></tr></table></figure>

<p>minimist 範例檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> argv = <span class="built_in">require</span>(<span class="string">'minimist'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(argv); <span class="comment">// Function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 終端機執行：node test.js --env development --- */</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'測試 1：'</span> + argv(process.argv.slice(<span class="number">2</span>))); <span class="comment">// 測試 1：&#123; _: [], env: 'development' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 終端機執行：node test.js --env development --- */</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'測試 2：'</span> + argv(process.argv.slice(<span class="number">2</span>)).env); <span class="comment">// 測試 2：development</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 終端機執行：node test.js --env production --- */</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'測試 3：'</span> + argv(process.argv.slice(<span class="number">2</span>)).env); <span class="comment">// 測試 3：production</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 終端機執行：node test.js --config HelloWorld --- */</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'測試 4：'</span> + argv(process.argv.slice(<span class="number">2</span>)).config); <span class="comment">// 測試 4：HelloWorld</span></span><br></pre></td></tr></table></figure>

<p>從上面範例可以得知，使用 <code>parseArgs(process.argv.slice(2))</code> 即可取得命令行傳遞參數，命令行格式需為 <code>$ node test.js --參數(key) 參數(value)</code>；應用時只需拿取對應的參數 (key)，即可獲得參數 (key) 內的參數 (value)。讓我們來實際演練一番。</p>
<p>載入並使用 minimist、gulp-if：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>);</span><br><span class="line"><span class="keyword">const</span> cleanCSS = <span class="built_in">require</span>(<span class="string">'gulp-clean-css'</span>);</span><br><span class="line"><span class="keyword">const</span> parseArgs = <span class="built_in">require</span>(<span class="string">'minimist'</span>); <span class="comment">// 載入 minimist 套件</span></span><br><span class="line"><span class="keyword">const</span> gulpif = <span class="built_in">require</span>(<span class="string">'gulp-if'</span>); <span class="comment">// 載入 gulp-if 套件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 獲取命令行參數</span></span><br><span class="line"><span class="keyword">const</span> argv = parseArgs(process.argv.slice(<span class="number">2</span>)).env;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- SCSS 編譯 --- */</span></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./source/scss/*.scss'</span>)</span><br><span class="line">    .pipe(sass().on(<span class="string">'error'</span>, sass.logError))</span><br><span class="line">    .pipe(gulpif(argv === <span class="string">'production'</span>, cleanCSS(&#123; <span class="attr">compatibility</span>: <span class="string">'ie8'</span> &#125;))) <span class="comment">// 區分套件使用環境</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'public/css'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在 development 環境執行指定任務：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp sass --env development</span><br></pre></td></tr></table></figure>

<p>SCSS 編譯結果：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box3</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 production 環境執行指定任務：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp sass --env production</span><br></pre></td></tr></table></figure>

<p>SCSS 編譯結果：</p>
<!-- prettier-ignore-start -->
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box1</span>&#123;<span class="attribute">color</span>:red&#125;.box2&#123;color:<span class="number">#00f</span>&#125;.box3&#123;color:<span class="number">#000</span>&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>從上面範例可以得知，gulp-if 套件能夠幫助我們進行邏輯判斷，第一個參數為 <code>True</code> or <code>False</code>，第二個參數為作用的 gulp 套件，當我們成功獲取命令行傳遞參數時，即可針對這一個參數做邏輯判斷，development 與 production 環境就是由此方法來做區分。</p>
<h2 id="minimist-可傳遞選項"><a href="#minimist-可傳遞選項" class="headerlink" title="minimist 可傳遞選項"></a>minimist 可傳遞選項</h2><p>可參考 <a href="https://www.npmjs.com/package/minimist" target="_blank" rel="external nofollow noopener noreferrer">minimist Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li><p>opts.string：<code>Array</code> =&gt; <code>[ 參數(key), ... ]</code><br>指定參數(key)內的參數(value)強制轉型為 string，默認為 <code>none</code></p>
</li>
<li><p>opts.boolean：<code>Array</code> =&gt; <code>[ 參數(key), ... ]</code><br>指定參數(key)內的參數(value)強制轉型為 boolean，默認為 <code>none</code></p>
</li>
<li><p>opts.default：<code>Object</code> =&gt; <code>{ 參數(key): 參數(value) }</code><br>預設命令行傳遞參數，默認為 <code>none</code></p>
</li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> argv = <span class="built_in">require</span>(<span class="string">'minimist'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- minimist可傳遞選項 --- */</span></span><br><span class="line"><span class="keyword">const</span> opts = &#123;</span><br><span class="line">  string: [<span class="string">'env1'</span>], <span class="comment">// or 'env1'</span></span><br><span class="line">  boolean: [<span class="string">'env2'</span>], <span class="comment">// or 'env2'</span></span><br><span class="line">  <span class="keyword">default</span>: &#123; <span class="attr">env</span>: <span class="string">'development'</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 終端機執行：node test.js --- */</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'測試 1：'</span> + argv(process.argv.slice(<span class="number">2</span>))); <span class="comment">// 測試 1：&#123; _: [], env2: false, env: 'development' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 終端機執行：node test.js --env production --- */</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'測試 2：'</span> + argv(process.argv.slice(<span class="number">2</span>))); <span class="comment">// 測試 2：&#123; _: [], env2: false, env: 'production' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 終端機執行：node test.js --env1 1234 --- */</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'測試 3：'</span> + argv(process.argv.slice(<span class="number">2</span>))); <span class="comment">// 測試 3：&#123; _: [], env2: false, env1: '1234', env: 'development' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 終端機執行：node test.js --env2 5678 --- */</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'測試 4：'</span> + argv(process.argv.slice(<span class="number">2</span>))); <span class="comment">// 測試 4：&#123; _: [ 5678 ], env2: true, env: 'development' &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="補充：Node-js-原生獲取命令行參數方法"><a href="#補充：Node-js-原生獲取命令行參數方法" class="headerlink" title="補充：Node.js 原生獲取命令行參數方法"></a>補充：Node.js 原生獲取命令行參數方法</h2><p>事實上，minimist 套件是以 Node.js 中的 <code>process.argv</code> API 來實現，不過基於原生方法較為不這麼人性化，故大多人都是使用 minimist 套件完成獲取命令行傳遞參數任務。以下為 Node.js 原生獲取命令行參數範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* --- 終端機執行：node test.js --env development --- */</span></span><br><span class="line"><span class="keyword">const</span> argv = process.argv;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(argv); <span class="comment">// [Node.js 路徑, test.js 路徑, '--env', 'development']</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(argv[<span class="number">3</span>]); <span class="comment">// development</span></span><br></pre></td></tr></table></figure>

<p>從上面範例可以得知，原生的 Node.js 獲取命令行參數方法參數 (key) 與參數 (value) 是沒有任何關聯性的，所有參數值都將成為陣列中的項目，實際使用起來很不人性化，建議使用 minimist 套件來完成。</p>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp 4</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Gulp 前端自動化 - 替換 Stream 中的檔案名稱</title>
    <url>/2020-01-22-gulp-gulprename/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一次介紹了 Minimist 這個套件以區分生產環境與開發環境的處理流程，通常在一般開發中，我們會針對生產環境與開發環境所釋出的檔案個別命名以方便辨認，但在 Gulp 中預設是無法進行重命名操作的，Stream 的起始文件名稱為何，導出時名稱就為何。此篇將介紹如何使用 gulp rename 套件針對 Gulp 中的 Stream 檔案進行重命名動作。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>gulp-rename 安裝</li>
<li>gulp-rename 基本使用</li>
<li>gulp-rename 可傳遞方法</li>
</ul>
<h2 id="gulp-rename-安裝"><a href="#gulp-rename-安裝" class="headerlink" title="gulp-rename 安裝"></a>gulp-rename 安裝</h2><blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/gulp-rename" target="_blank" rel="external nofollow noopener noreferrer">gulp-rename</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp-rename</span><br></pre></td></tr></table></figure>

<p>無任何相依套件，直接安裝即可。</p>
<h2 id="gulp-rename-基本使用"><a href="#gulp-rename-基本使用" class="headerlink" title="gulp-rename 基本使用"></a>gulp-rename 基本使用</h2><div class="note warning">此次範例會結合 minimist、gulp-sass 套件一起使用，相關文章連結：<a href="https://awdr74100.github.io/2020-01-21-gulp-minimist/" target="_blank">minimist</a>、<a href="https://awdr74100.github.io/2019-12-31-gulp-gulpsass/" target="_blank">gulp-sass</a></div>

<p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── source&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── scss&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.scss     # SCSS 主檔案</span><br><span class="line">│</span><br><span class="line">├─── gulpfile.js          # Gulp 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json         # 安裝 gulp、gulp-rename、other...</span><br></pre></td></tr></table></figure>

<p>載入並使用 gulp-rename：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>);</span><br><span class="line"><span class="keyword">const</span> cleanCSS = <span class="built_in">require</span>(<span class="string">'gulp-clean-css'</span>);</span><br><span class="line"><span class="keyword">const</span> parseArgs = <span class="built_in">require</span>(<span class="string">'minimist'</span>);</span><br><span class="line"><span class="keyword">const</span> gulpif = <span class="built_in">require</span>(<span class="string">'gulp-if'</span>);</span><br><span class="line"><span class="keyword">const</span> rename = <span class="built_in">require</span>(<span class="string">'gulp-rename'</span>); <span class="comment">// 載入 gulp-rename 套件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 獲取命令行參數</span></span><br><span class="line"><span class="keyword">const</span> argv = parseArgs(process.argv.slice(<span class="number">2</span>)).env;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- SCSS 編譯 --- */</span></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./source/scss/*.scss'</span>)</span><br><span class="line">    .pipe(sass().on(<span class="string">'error'</span>, sass.logError))</span><br><span class="line">    .pipe(gulpif(argv === <span class="string">'production'</span>, cleanCSS(&#123; <span class="attr">compatibility</span>: <span class="string">'ie8'</span> &#125;)))</span><br><span class="line">    .pipe(gulpif(argv === <span class="string">'production'</span>, rename(<span class="string">'all.min.css'</span>))) <span class="comment">// 重命名</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'public/css'</span>)); <span class="comment">// ./public/css/all.min.css</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在 production 環境執行指定任務：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp sass --env production</span><br></pre></td></tr></table></figure>

<p>此時生成檔案的名稱會從 <code>all.css</code> 改為 <code>all.min.css</code>，由於上面這一個 rename 名稱是寫死的，如果有多個檔案同時導入，最後在導出檔案時因為名稱相同，可能會發生錯誤，我們可以改使用下面寫法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>);</span><br><span class="line"><span class="keyword">const</span> cleanCSS = <span class="built_in">require</span>(<span class="string">'gulp-clean-css'</span>);</span><br><span class="line"><span class="keyword">const</span> parseArgs = <span class="built_in">require</span>(<span class="string">'minimist'</span>);</span><br><span class="line"><span class="keyword">const</span> gulpif = <span class="built_in">require</span>(<span class="string">'gulp-if'</span>);</span><br><span class="line"><span class="keyword">const</span> rename = <span class="built_in">require</span>(<span class="string">'gulp-rename'</span>); <span class="comment">// 載入 gulp-rename 套件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 獲取命令行參數</span></span><br><span class="line"><span class="keyword">const</span> argv = parseArgs(process.argv.slice(<span class="number">2</span>)).env;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- SCSS 編譯 --- */</span></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./source/scss/*.scss'</span>)</span><br><span class="line">    .pipe(sass().on(<span class="string">'error'</span>, sass.logError))</span><br><span class="line">    .pipe(gulpif(argv === <span class="string">'production'</span>, cleanCSS(&#123; <span class="attr">compatibility</span>: <span class="string">'ie8'</span> &#125;)))</span><br><span class="line">    .pipe(</span><br><span class="line">      gulpif(</span><br><span class="line">        argv === <span class="string">'production'</span>,</span><br><span class="line">        rename(<span class="function">(<span class="params">path</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(path); <span class="comment">// &#123; dirname: '.', basename: 'all', extname: '.css' &#125;</span></span><br><span class="line">          path.basename += <span class="string">'.min'</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'public/css'</span>)); <span class="comment">// ./public/css/all.min.css</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>gulp-rename 套件預設可傳入一個 callback，第一個參數可得到初始檔案組成的物件，針對這一個物件做修改，同樣也可以達到重命名的目的，推薦使用此方法。</p>
<h2 id="gulp-rename-可傳遞方法"><a href="#gulp-rename-可傳遞方法" class="headerlink" title="gulp-rename 可傳遞方法"></a>gulp-rename 可傳遞方法</h2><p>可參考 <a href="https://www.npmjs.com/package/gulp-rename#usage" target="_blank" rel="external nofollow noopener noreferrer">rename Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li><p>dirname：<code>String</code><br>檔案目錄，預設為 <code>./</code></p>
</li>
<li><p>basename：<code>String</code><br>基本名稱，預設為 <code>Stream 初始檔案名稱</code></p>
</li>
<li><p>prefix：<code>String</code><br>增加前綴，預設為 <code>none</code></p>
</li>
<li><p>suffix：<code>String</code><br>增加後綴，預設為 <code>none</code></p>
</li>
<li><p>extname：<code>String</code><br>副檔名，預設為 <code>Stream 初始檔案副檔名</code></p>
</li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'sass'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./source/scss/*.scss'</span>)</span><br><span class="line">    .pipe(sass().on(<span class="string">'error'</span>, sass.logError))</span><br><span class="line">    .pipe(gulpif(argv === <span class="string">'production'</span>, cleanCSS(&#123; <span class="attr">compatibility</span>: <span class="string">'ie8'</span> &#125;)))</span><br><span class="line">    .pipe(</span><br><span class="line">      rename(&#123;</span><br><span class="line">        dirname: <span class="string">'./component'</span>,</span><br><span class="line">        basename: <span class="string">'stylesheet'</span>,</span><br><span class="line">        prefix: <span class="string">'master-'</span>,</span><br><span class="line">        suffix: <span class="string">'.min'</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'public/css'</span>)); <span class="comment">// ./public/component/master-stylesheet.min.css</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以可傳遞選項方式重命名檔案，相比上面幾種方法來說，似乎最為方便，我個人是比較常使用此方法，自己喜歡最重要。</p>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp 4</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Gulp 前端自動化 - 客製化 Bootstrap 樣式並進行編譯</title>
    <url>/2020-01-24-gulp-includebootstrap/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Bootstrap 目前已經算是前端必備的技能了，相信大部分人在使用時都是以 CDN 的方式進行載入，但這樣子的作法等同於將整個官方預編譯好的 Bootstrap 進行載入，當我們需要客製化 Bootstrap 樣式時，必定得採取其他方法。此篇將介紹如何使用 npm 方式載入 Bootstrap，並透過 Gulp 編譯屬於我們自己的客製化樣式。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>相關套件安裝</li>
<li>客製並編譯 Bootstrap 預設變數</li>
<li>客製並編譯 Bootstrap 載入元件</li>
</ul>
<h2 id="相關套件安裝"><a href="#相關套件安裝" class="headerlink" title="相關套件安裝"></a>相關套件安裝</h2><blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/gulp-sass" target="_blank" rel="external nofollow noopener noreferrer">gulp-sass</a>、<a href="https://www.npmjs.com/package/gulp-postcss" target="_blank" rel="external nofollow noopener noreferrer">gulp-postcss</a>、<a href="https://www.npmjs.com/package/autoprefixer" target="_blank" rel="external nofollow noopener noreferrer">autoprefixer</a>、<a href="https://getbootstrap.com/" target="_blank" rel="external nofollow noopener noreferrer">bootstrap</a></p>
</blockquote>
<p>bootstrap：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install bootstrap</span><br></pre></td></tr></table></figure>

<p>require：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp-sass gulp-postcss autoprefixer</span><br></pre></td></tr></table></figure>

<p>Bootstrap 4 主要由 SCSS 建構而成，當你使用 npm 方式進行安裝時，在下載下來的 package 內即包含未編譯的 SCSS 原始檔案，我們可以針對這一個原始檔案進行客製化並編譯它，在這邊使用 gulp-sass 套件進行編譯，由於 Bootstrap 官方的預編譯版本有使用到 autoprefixer 插件以便自動在構建時向某些 CSS 屬性增加前輟詞，我們在處理編譯後檔案時，也必須參照此作法，所以同時安裝了 gulp-postcss 與 autoprefixer 套件。</p>
<h2 id="客製並編譯-Bootstrap-預設變數"><a href="#客製並編譯-Bootstrap-預設變數" class="headerlink" title="客製並編譯 Bootstrap 預設變數"></a>客製並編譯 Bootstrap 預設變數</h2><div class="note warning">此次範例會結合 gulp-sass、gulp-postcss 套件一起使用，相關文章連結：<a href="https://awdr74100.github.io/2019-12-31-gulp-gulpsass/" target="_blank">gulp-sass</a>、<a href="https://awdr74100.github.io/2020-01-12-gulp-gulppostcss/" target="_blank">gulp-postcss</a></div>

<p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── source&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── scss&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── helpers</span><br><span class="line">│           │</span><br><span class="line">│           └─── _variables.scss    # 新增並修改 Bootstrap 預設變數</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.scss     # SCSS 主檔案</span><br><span class="line">│</span><br><span class="line">├─── gulpfile.js          # Gulp 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json         # 安裝 gulp、gulp-sass、gulp-postcss、autoprefixer、bootstrap</span><br></pre></td></tr></table></figure>

<div class="note warning">推薦使用懶人覆蓋法，將 ./node_modules/bootstrap/scss/_variables.scss 另存新檔至本地端</div>

<p>新增 <code>./source/scss/helpers/_variables.scss</code> 並修改預設變數(須查詢預設變數名稱)：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 查詢 node_modules/bootstrap/scss/_variables.scss 預設變數並新增到本地檔案 */</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$primary</span>: <span class="number">#178ba0</span>; <span class="comment">// 隨意修改變數</span></span><br><span class="line"><span class="variable">$success</span>: <span class="number">#35a327</span>;</span><br></pre></td></tr></table></figure>

<p>新增 <code>./source/scss/helpers/_variables.scss</code> 並修改預設變數(懶人覆蓋法)：</p>
<!-- prettier-ignore-start -->
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 另存新檔 node_modules/bootstrap/scss/_variables.scss 預設變數並修改 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他省略 ...</span></span><br><span class="line"><span class="variable">$primary</span>:       <span class="number">#178ba0</span>; <span class="comment">// $blue !default;</span></span><br><span class="line"><span class="variable">$success</span>:       <span class="number">#35a327</span>; <span class="comment">// $green !default;</span></span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>根據官方文檔說明，Bootstrap 4 中的每個 SCSS 變數都包含 <code>!default</code> 標誌，允許您在自己的 SCSS 中覆蓋變數的預設值，而無需修改 Bootstrap 的原始碼。唯一要注意的是<strong>新變數必須在導入 Bootstrap 的 SCSS 主文件之前</strong>，否則無法成功，如下範例：</p>
<div class="note warning">includePaths 為 gulp-sass 套件的可傳遞選項，接受屬性值為字串符陣列，默認為空陣列，主要用來讓解析引擎遍歷這些傳入的路徑，尋找 SCSS 模塊，已嘗試解析 @import 宣告</div>

<p>路徑：<code>./source/scss/all.scss</code></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* --- Required (使用 includePaths 方法) --- */</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'functions'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/variables'</span>; <span class="comment">// 使用本地檔案</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'mixins'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- Bootstrap 主檔案 --- */</span></span><br><span class="line"><span class="comment">// @import "../../node_modules/bootstrap/scss/bootstrap.scss";</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- Bootstrap 主檔案 (使用 includePaths 方法)--- */</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'bootstrap'</span>;</span><br></pre></td></tr></table></figure>

<p>編寫 <code>gulpfile.js</code> 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>);</span><br><span class="line"><span class="keyword">const</span> postcss = <span class="built_in">require</span>(<span class="string">'gulp-postcss'</span>);</span><br><span class="line"><span class="keyword">const</span> autoprefixer = <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- SCSS 編譯 --- */</span></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./source/scss/*.scss'</span>)</span><br><span class="line">    .pipe(</span><br><span class="line">      sass(&#123;</span><br><span class="line">        outputStyle: <span class="string">'compressed'</span>, <span class="comment">// 執行壓縮</span></span><br><span class="line">        includePaths: [<span class="string">'node_modules/bootstrap/scss/'</span>], <span class="comment">// 導入 sass 模塊可能路徑</span></span><br><span class="line">      &#125;).on(<span class="string">'error'</span>, sass.logError)</span><br><span class="line">    )</span><br><span class="line">    .pipe(postcss([autoprefixer()])) <span class="comment">// 加入 CSS Prefix</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/css'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>建立 <code>.browserslistrc</code> 並輸入官方編譯版本：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt;= 1%</span><br><span class="line">last 1 major version</span><br><span class="line">not dead</span><br><span class="line">Chrome &gt;= 45</span><br><span class="line">Firefox &gt;= 38</span><br><span class="line">Edge &gt;= 12</span><br><span class="line">Explorer &gt;= 10</span><br><span class="line">iOS &gt;= 9</span><br><span class="line">Safari &gt;= 9</span><br><span class="line">Android &gt;= 4.4</span><br><span class="line">Opera &gt;= 30</span><br></pre></td></tr></table></figure>

<p>依造官方 <a href="https://getbootstrap.com/docs/4.4/getting-started/browsers-devices/" target="_blank" rel="external nofollow noopener noreferrer">Browsers and devices</a> 文檔說明，使用 Autoprefixer 可搭配 <a href="https://github.com/browserslist/browserslist" target="_blank" rel="external nofollow noopener noreferrer">Browserslist</a> 進行 CSS Prefix 支援裝置設定，上面為官方預編譯各裝置支援版本。</p>
<p>執行指定任務：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp sass</span><br></pre></td></tr></table></figure>

<p>生成 <code>./public/css/all.css</code> 檔案，觀察 Bootstrap 預設變數是否成功更改：</p>
<p>官方預編譯版本：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#007bff</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-success</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#28a745</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他省略</span></span><br></pre></td></tr></table></figure>

<p>客製化版本：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#178ba0</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-success</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#35a327</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他省略</span></span><br></pre></td></tr></table></figure>

<p>由上面結果可得知，Bootstrap 預設變數已經被我們給覆蓋掉，同時也代表整個流程正確無誤，事實上 Bootstrap 客製化應用都大同小異，差別只在於你想要如何客製化 Bootstrap 而已。</p>
<h2 id="客製並編譯-Bootstrap-載入元件"><a href="#客製並編譯-Bootstrap-載入元件" class="headerlink" title="客製並編譯 Bootstrap 載入元件"></a>客製並編譯 Bootstrap 載入元件</h2><p>Bootstrap 最為人詬病的問題大概就是 package 實在是太大了，雖然可透過壓縮方式進行縮小化，但與 <a href="https://purecss.io/" target="_blank" rel="external nofollow noopener noreferrer">Pure.css</a> 等同類型框架相比還是太大了，內含的許多元件在實際開發時，幾乎都用不太到，造成空間的浪費；我們可以嘗試客製 Bootstrap 載入元件，以減少 package 的大小，讓我們先從 Bootstrap 架構開始說明：</p>
<p>Bootstrap 組成架構：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路徑：node_modules/bootstrap/scss/bootstrap.scss</span></span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'functions'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'variables'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'mixins'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'root'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'reboot'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'type'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'images'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'code'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'grid'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'tables'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'forms'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'buttons'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'transitions'</span>;</span><br><span class="line"><span class="comment">// 以下省略 ...</span></span><br></pre></td></tr></table></figure>

<p>Bootstrap 是一個標準的 OOCSS 範例，也因為使用此設計準則，我們可以很輕鬆的移除沒有使用到的元件。請先將 Bootstrap 主檔案內容複製到 <code>./source/scss/all.scss</code> 內，接著註釋掉不需使用的元件，如下範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路徑：./source/scss/all.scss</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Required</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'functions'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'variables'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'mixins'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自訂需載入的元件</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'forms'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'buttons'</span>;</span><br><span class="line"><span class="comment">// @import "transitions";</span></span><br><span class="line"><span class="comment">// @import "dropdown";</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'button-group'</span>;</span><br><span class="line"><span class="comment">// ... 以下省略</span></span><br></pre></td></tr></table></figure>

<p><code>gulpfile.js</code> 檔案內容如同前面範例，這邊要注意的是，<code>function</code>、<code>variables</code>、<code>mixins</code> 是必要載入的檔案，所有元件都須依賴這三個檔案。</p>
<p>執行指定任務</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp sass</span><br></pre></td></tr></table></figure>

<p>最後觀察編譯後 CSS 檔案，你會發現檔案縮小了很多，這就是客製化 Bootstrap 載入元件的方法，在每次開發後可自行載入須使用的元件，有利於減少 CSS 檔案大小。</p>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Gulp 4</tag>
        <tag>Node.js</tag>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title>Gulp 前端自動化 - CommonJS 模組化設計</title>
    <url>/2020-01-26-gulp-modular/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CommonJS 為當初最早設計用來解決 JavaScript 模組化設計的規範，使用簡單的幾個語法，即可達到模組化的效果。本篇不會探討較新標準的其他規範，比如 ES6 Module 等等，將會把焦點放在如何以 CommonJS 規範針對 Gulp 進行模組化設計，以及 CommonJS 規範中最常被人拿來討論的 module.exports 與 exports 語法兩者差別。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>CommonJS 初始環境建構</li>
<li>CommonJS 規範相關語法</li>
<li>Gulp 相關套件安裝</li>
<li>Gulp 模組化設計</li>
</ul>
<h2 id="CommonJS-初始環境建構"><a href="#CommonJS-初始環境建構" class="headerlink" title="CommonJS 初始環境建構"></a>CommonJS 初始環境建構</h2><p>專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commonjs&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── main.js              # JavaScript 主檔案</span><br><span class="line">└─── module.js            # JavaScript 模組</span><br></pre></td></tr></table></figure>

<p>在之後講解到關於 CommonJS 規範相關語法時，都會以上面這一個專案結構做為測試目的。</p>
<h2 id="CommonJS-規範相關語法"><a href="#CommonJS-規範相關語法" class="headerlink" title="CommonJS 規範相關語法"></a>CommonJS 規範相關語法</h2><div class="note warning">在 Node.js 中，一個 .js 檔即代表一個模組，每個模組內都有一個隱式(implicit)的 module 物件，這個 module 物件身上有一個 exports (即 module.exports) 屬性</div>

<p>CommonJS 規範相關語法：</p>
<ul>
<li><code>module.exports</code>：導出模塊(推薦寫法)</li>
<li><code>exports</code>：導出模塊</li>
<li><code>require</code>：引入模塊</li>
</ul>
<p>內部原理：</p>
<ul>
<li><code>exports</code> = <code>module.exports</code> = <code>{}</code> = 空物件</li>
<li><code>exports</code> 是 <code>module.exports</code> 的一個捷徑變數</li>
<li><code>exports.xxx</code>，相當於在匯出物件上新增屬性，該屬性對呼叫模組直接可見</li>
<li><code>exports = xxx</code>，相當於給 <code>exports</code> 物件重新賦值，<code>require</code> 無法訪問 <code>exports</code> 物件及其屬性</li>
<li><code>require</code> 引用模組後，返回給呼叫者的是 <code>module.exports</code> 而不是 <code>exports</code></li>
<li>由於一個模組只有一個 <code>exports</code>，當有多個物件需要 <code>exports</code> 時，可利用新增屬性方式掛載到物件上，最後統一導出</li>
</ul>
<h3 id="exports-module-exports-空物件"><a href="#exports-module-exports-空物件" class="headerlink" title="exports = module.exports = {} = 空物件"></a><code>exports</code> = <code>module.exports</code> = <code>{}</code> = 空物件</h3><p>路徑：<code>./module.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.exports); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(exports); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.exports === exports); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以物件方式增加屬性</span></span><br><span class="line"><span class="built_in">module</span>.exports.test1 = <span class="string">'Hi module.exports'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.exports); <span class="comment">// &#123; test1: 'Hi module.exports' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以物件方式增加屬性</span></span><br><span class="line">exports.test2 = <span class="string">'Hi exports'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(exports); <span class="comment">// &#123; test1: 'Hi module.exports', test2: 'Hi exports' &#125;</span></span><br></pre></td></tr></table></figure>

<p>從上面範例可以得知，<code>module.exports</code> 與 <code>exports</code> 本身是一個物件，而 <code>exports</code> 本身是 <code>module.exports</code> 的捷徑變數，兩者指向記憶體位址是一樣的，也就代表不管是操作 <code>module.exports</code> 還是 <code>exports</code> 物件，其實都是操作同一個物件。</p>
<h3 id="exports-是-module-exports-的一個捷徑變數"><a href="#exports-是-module-exports-的一個捷徑變數" class="headerlink" title="exports 是 module.exports 的一個捷徑變數"></a><code>exports</code> 是 <code>module.exports</code> 的一個捷徑變數</h3><p>路徑：<code>./module.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以物件方式增加屬性</span></span><br><span class="line"><span class="built_in">module</span>.exports.test1 = <span class="string">'Hi module.exports'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.exports); <span class="comment">// &#123; test1: 'Hi module.exports' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以物件方式增加屬性</span></span><br><span class="line">exports.test2 = <span class="string">'Hi exports'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(exports); <span class="comment">// &#123; test1: 'Hi module.exports', test2: 'Hi exports' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  test3: <span class="number">10</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.exports); <span class="comment">// &#123; test3: 10 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(exports); <span class="comment">// &#123; test1: 'Hi module.exports', test2: 'Hi exports' &#125;</span></span><br></pre></td></tr></table></figure>

<p>前面有講解到 <code>exports</code> 是 <code>module.exports</code> 的捷徑變數，但需要注意的是，這邊說的捷徑變數是指 <code>module.exports</code> 初始物件，如果 <code>module.exports</code> 有任何賦值動作，<code>exports</code> 只會透過捷徑映射到初始物件，如同上面範例。</p>
<h3 id="exports-xxx，相當於在匯出物件上新增屬性，該屬性對呼叫模組直接可見"><a href="#exports-xxx，相當於在匯出物件上新增屬性，該屬性對呼叫模組直接可見" class="headerlink" title="exports.xxx，相當於在匯出物件上新增屬性，該屬性對呼叫模組直接可見"></a><code>exports.xxx</code>，相當於在匯出物件上新增屬性，該屬性對呼叫模組直接可見</h3><p>路徑：<code>./module.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fun = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 導出模塊 --- */</span></span><br><span class="line"><span class="built_in">module</span>.exports.fun = fun;</span><br></pre></td></tr></table></figure>

<p>路徑：<code>./main.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* --- 導入模塊 ---*/</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">require</span>(<span class="string">'./module'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; fun: [Function: fun] &#125;</span></span><br><span class="line">obj.fun(); <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure>

<p>在我們導出模塊時，可透過物件新增屬性的方式掛載內容，接收方只需要使用 <code>require</code> 導入模塊即可載入目標模塊的物件以及掛載內容，前面有提到 <code>exports</code> 是 <code>module.exports</code> 的捷徑變數，我們可改寫導出模塊方式：</p>
<p>路徑：<code>./module.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fun = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 導出模塊 --- */</span></span><br><span class="line">exports.fun = fun;</span><br></pre></td></tr></table></figure>

<h3 id="exports-xxx，相當於給-exports-物件重新賦值，require-無法訪問-exports-物件及其屬性"><a href="#exports-xxx，相當於給-exports-物件重新賦值，require-無法訪問-exports-物件及其屬性" class="headerlink" title="exports = xxx，相當於給 exports 物件重新賦值，require 無法訪問 exports 物件及其屬性"></a><code>exports = xxx</code>，相當於給 <code>exports</code> 物件重新賦值，<code>require</code> 無法訪問 <code>exports</code> 物件及其屬性</h3><p>路徑：<code>./module.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fun = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 將 module.exports 重新賦值 --- */</span></span><br><span class="line"><span class="built_in">module</span>.exports = fun;</span><br></pre></td></tr></table></figure>

<p>路徑：<code>./main.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* --- 導入模塊 ---*/</span></span><br><span class="line"><span class="keyword">const</span> fun = <span class="built_in">require</span>(<span class="string">'./module'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fun); <span class="comment">// [Function: fun]</span></span><br><span class="line">fun(); <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure>

<p>前面我們都是針對 <code>module.exports</code> 本身物件新增屬性，之後再導出模塊，事實上，我們可以直接針對 <code>module.exports</code> 重新賦值，這樣子的作法在導入模塊時，就不需要以物件方式拿取裡面的內容，可以直接進行取用，可能有人就在想，既然 <code>exports</code> 是 <code>module.exports</code> 的捷徑變數，那我們是否可針對 <code>exports</code> 重新賦值？如下面寫法：</p>
<p>路徑：<code>./module.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fun = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 將 exports 重新賦值 --- */</span></span><br><span class="line">exports = fun;</span><br></pre></td></tr></table></figure>

<p>答案是不行的，下段介紹會有說明。</p>
<h3 id="require-引用模組後，返回給呼叫者的是-module-exports-而不是-exports"><a href="#require-引用模組後，返回給呼叫者的是-module-exports-而不是-exports" class="headerlink" title="require 引用模組後，返回給呼叫者的是 module.exports 而不是 exports"></a><code>require</code> 引用模組後，返回給呼叫者的是 <code>module.exports</code> 而不是 <code>exports</code></h3><p>路徑：<code>./module.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fun = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 將 exports 重新賦值 --- */</span></span><br><span class="line">exports = fun;</span><br></pre></td></tr></table></figure>

<p>路徑：<code>./main.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* --- 導入模塊 ---*/</span></span><br><span class="line"><span class="keyword">const</span> fun = <span class="built_in">require</span>(<span class="string">'./module'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fun); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>前面有提到，使用 <code>exports</code> 重新賦值時，<code>require</code> 接收到的或是一個空物件，造成此結果的原因在於 <code>require</code> 引用模組時，返回給呼叫者的是 <code>module.exports</code> 而不是 <code>exports</code>，<code>exports</code> 預設是 <code>module.exports</code> 的捷徑變數，代表兩者指向記憶體位址相同，當我們針對 <code>exports</code> 物件新增屬性時，<code>module.exports</code> 也會接連變動，但當我們針對 <code>exports</code> 重新賦值後，<code>exports</code> 就與 <code>module.exports</code> 無任何關係，兩個是完全不一樣的東西，這才導致使用 <code>require</code> 時，接收到的會是一個空物件，因為 <code>module.exports</code> 物件匯出時沒有任何掛載屬性，簡單來講，<code>exports</code> 只適合用以掛載屬性導出模塊，如果你想要避免兩者的使用陷阱，<code>module.exports</code> 是最好的選擇。</p>
<h3 id="由於一個模組只有一個-exports，當有多個物件需要-exports-時，可利用新增屬性方式掛載到物件上，最後統一導出"><a href="#由於一個模組只有一個-exports，當有多個物件需要-exports-時，可利用新增屬性方式掛載到物件上，最後統一導出" class="headerlink" title="由於一個模組只有一個 exports，當有多個物件需要 exports 時，可利用新增屬性方式掛載到物件上，最後統一導出"></a>由於一個模組只有一個 <code>exports</code>，當有多個物件需要 <code>exports</code> 時，可利用新增屬性方式掛載到物件上，最後統一導出</h3><p>路徑：<code>./module.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> variable = <span class="string">'變數'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fun = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'函式'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> people = &#123;</span><br><span class="line">  name: <span class="string">'Roya'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.variable = variable;</span><br><span class="line">exports.fun = fun;</span><br><span class="line">exports.people = people;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// module.exports = &#123; variable: variable, fun: fun, people: people &#125;;</span></span><br></pre></td></tr></table></figure>

<p>路徑：<code>./main.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">require</span>(<span class="string">'./module'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">&#123; </span></span><br><span class="line"><span class="comment">  variable: '變數',</span></span><br><span class="line"><span class="comment">  fun: [Function: fun],</span></span><br><span class="line"><span class="comment">  people: &#123; name: 'Roya', age: 20 &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>由於一個 .js 檔案就等於一個 <code>module.exports</code>，如果有多個物件、變數、函式需要做導出時，可使用物件新增屬性方式掛載內容，如上面範例。此時也可以搭配物件解構直接取用掛載內容：</p>
<p>路徑：<code>./main.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; variable, fun, people &#125; = <span class="built_in">require</span>(<span class="string">'./module'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(variable); <span class="comment">// 變數</span></span><br><span class="line"><span class="built_in">console</span>.log(fun); <span class="comment">// [Function: fun]</span></span><br><span class="line"><span class="built_in">console</span>.log(people); <span class="comment">// &#123; name: 'Roya', age: 20 &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Gulp-相關套件安裝"><a href="#Gulp-相關套件安裝" class="headerlink" title="Gulp 相關套件安裝"></a>Gulp 相關套件安裝</h2><blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/gulp-sass" target="_blank" rel="external nofollow noopener noreferrer">gulp-sass</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp-sass</span><br></pre></td></tr></table></figure>

<p>此次範例會使用 gulp-sass 套件，請先進行安裝</p>
<h2 id="Gulp-模組化設計"><a href="#Gulp-模組化設計" class="headerlink" title="Gulp 模組化設計"></a>Gulp 模組化設計</h2><p>初始專案結構：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> gulp-demo/</span><br><span class="line"> │</span><br><span class="line"> ├─── node_modules/</span><br><span class="line"> │</span><br><span class="line"><span class="addition">+├─── gulpfile.js/         # Gulp 模組化配置相關檔案</span></span><br><span class="line"><span class="addition">+│   │</span></span><br><span class="line"><span class="addition">+│   ├─── index.js         # 預設 Gulp 編譯主檔案</span></span><br><span class="line"><span class="addition">+│   └─── compile.js       # Gulp 模組檔案 - SCSS 編譯</span></span><br><span class="line"> │</span><br><span class="line"> ├─── source/</span><br><span class="line"> │   │</span><br><span class="line"> │   └─── scss</span><br><span class="line"> │       │</span><br><span class="line"> │       └─── all.scss     # SCSS 主檔案</span><br><span class="line"> │</span><br><span class="line"><span class="deletion">-├─── gulpfile.js          # Gulp 單一配置檔</span></span><br><span class="line"> ├─── package-lock.json</span><br><span class="line"> └─── package.json         # 安裝 gulp、gulp-sass</span><br></pre></td></tr></table></figure>

<p>請注意 Gulp 主檔案位置，原本我們都是使用 <code>gulpfile.js</code> 作為依據，設計模組化應用時，建議將同應用檔案放在同一個資料夾，所以我們新增了一個 <code>gulpfile.js</code> 資料夾，裡面新增了一個 <code>index.js</code> 檔案，這一個就是我們的 Gulp 主檔案，而 <code>compile.js</code> 是我們 SCSS 相關套件的模組檔案，下面會有說明。</p>
<div class="note danger">gulpfile.js 資料夾默認是使用 index.js 作為執行檔案，要注意的是使用 CLI 執行任務時，入口路徑為 gulpfile.js 資料夾路徑，並不是 index.js 路徑</div>

<p>Gulp 主檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="comment">/* --- 導入模組 --- */</span></span><br><span class="line"><span class="keyword">const</span> &#123; compile &#125; = <span class="built_in">require</span>(<span class="string">'./compile'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>, gulp.series(compile));</span><br></pre></td></tr></table></figure>

<p>Gulp 模組檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 以函式方式宣告任務 --- */</span></span><br><span class="line"><span class="keyword">const</span> compile = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./source/scss/*.scss'</span>)</span><br><span class="line">    .pipe(sass().on(<span class="string">'error'</span>, sass.logError))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/css'</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 導出模組 --- */</span></span><br><span class="line">exports.compile = compile;</span><br></pre></td></tr></table></figure>

<p>之前我們都是使用 Task 名稱作為執行任務參數依據，在 Gulp 4 中可接受函式作為參數依據，就如同上面範例所演示，Gulp 主檔案使用 <code>gulp.series</code> 非同步方式執行任務，而這一個任務以往都是字串形式的 Task 名稱，但現在我們使用函式方式導入，而這一個函示就是 <code>./compile.js</code> 所宣告的函式，我們可以將任務內容寫到函式裡頭，最後再將這一個函式導出，即可完成模組化應用，相同方式可套用在其他模組，只需要了解 <code>exports</code> 與 <code>require</code> 原理，就能夠拆分出任何形式的模組。</p>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Gulp 4</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Gulp 前端自動化 - 升級至 Gulp 4 完整說明</title>
    <url>/2020-01-28-gulp-upgradegulp/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Gulp 4 已經推出有一段時間了，有礙於網上文章大多都是使用 Gulp 3 版本，對於學習 Gulp 4 的開發者來說較為不友善，此篇將完整解說 Gulp 3 與 Gulp 4 的差異，包含 Gulp 4 新增的幾個好用語法，比如 gulp.series()、gulp.parallel() 等等，以及 task() API 已不被官方推薦使用，取而代之的 function task 究竟如何使用，全部內容都將完整說明。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>註冊 Task 任務的新方法</li>
<li>任務依賴和執行函式</li>
<li>非同步完成</li>
<li>Watch API 可監聽全局事件</li>
</ul>
<h2 id="註冊-Task-任務的新方法"><a href="#註冊-Task-任務的新方法" class="headerlink" title="註冊 Task 任務的新方法"></a>註冊 Task 任務的新方法</h2><p>在 Gulp 3 版本，我們都是使用 <code>gulp.tsak()</code> API 去註冊任務，之後再使用 CLI 指令去執行任務，這個流程在 Gulp 4 版本一樣可以使用，但官方已不再推薦使用 <code>gulp.task()</code> API，在 Gulp 4 版本，取而代之的是使用 <code>function</code> 來建立任務，以及 <code>exports</code> 來導出任務，範例如下：</p>
<p>Gulp 3：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'build'</span>, (cb) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 任務內容</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Gulp 4：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compile_Sass</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 任務內容</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- export.任務名稱 = 工作內容相關函式名稱 --- */</span></span><br><span class="line">exports.build = compile_Sass;</span><br></pre></td></tr></table></figure>

<p>使用 <code>function 工作內容相關函式名稱() {}</code> 即可建立任務，此時任務狀態為 Private，不會被 CLI 給偵測到，只能供內部使用，此時可以使用 <code>exports.工作名稱 = 工作內容相關函式名稱</code> 將任務導出，CLI 即可偵測到任務，狀態為 Public，最後執行 <code>gulp build</code> 指令執行任務，結果會與 Gulp 3 相同，讓我們來看其他例子：</p>
<p><strong>多任務執行</strong>：</p>
<p>Gulp 3：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'scss'</span>, (cb) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 任務內容</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'pug'</span>, (cb) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 任務內容</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'build'</span>, gulp.series(<span class="string">'scss'</span>, <span class="string">'pug'</span>));</span><br></pre></td></tr></table></figure>

<p>Gulp 4：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scss</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 任務內容</span></span><br><span class="line">  cb();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pug</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 任務內容</span></span><br><span class="line">  cb();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.build = gulp.series(scss, pug);</span><br></pre></td></tr></table></figure>

<p>在 Gulp 3 我們都是使用字串形式的 <code>taskname</code> 作為參數執行任務，但在 Gulp 4 新增接受 <code>function</code> 作為參數執行任務，這也是之前文章提到可使用 CommonJS 模組化的關鍵，彈性與上個版本相比提高了不少，這確實是件好事，接著我們來說明之前提到的 Private Task 與 Public Task 究竟是什麼，請先使用 <code>gulp --tasks</code> 檢視所有任務：</p>
<p>Gulp 3：</p>
<img src="https://i.imgur.com/DwSH0cc.jpg" alt="Gulp 3 所有任務">

<p>Gulp 4：</p>
<img src="https://i.imgur.com/8hnbIk4.jpg" alt="Gulp 4 所有任務">

<p>在 Gulp 3 中，所有宣告的任務都屬於 Public Task，這樣子的界定方式容易造成結構混亂，而在 Gulp 4 中，分為 Private Task 和 Public Task 兩種狀態任務：</p>
<ul>
<li><p>公開任務 (Public Task)：從 <code>gulpfile.js</code> 被導出 (exports)，可以通過 CLI 命令直接調用。例如：<code>exports.build = build</code></p>
</li>
<li><p>私有任務 (Private Task)：被設計在內部使用，通常做為 series() 或 parallel() 組合的參數部分。例如：<code>exports.build = gulp.series(scss, pug)</code></p>
</li>
</ul>
<p>雖然與 Gulp 3 相比可能較為麻煩，但這樣子的界定方式能夠有效的避免結構混亂導致維護困難等問題。</p>
<h2 id="任務依賴和執行函式"><a href="#任務依賴和執行函式" class="headerlink" title="任務依賴和執行函式"></a>任務依賴和執行函式</h2><p>以往 Gulp 都是採用任務依賴的方式執行任務，如下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'compile'</span>, [<span class="string">'jade'</span>, <span class="string">'sass'</span>, <span class="string">'watch'</span>], () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 任務內容</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>此時執行 <code>gulp compile</code> 即可非同步執行所有任務，亦即<strong>並行執行</strong> <code>jade</code>、<code>sass</code>、<code>watch</code> 任務，當依賴任務執行完成，最後才會執行自身 <code>compile</code> 的任務，這是比較簡單的情況，假設我們在執行 <code>compile</code> 任務前，需要清除先前編譯的資料呢？寫法可能如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'compile'</span>, [<span class="string">'clean'</span>, <span class="string">'jade'</span>, <span class="string">'sass'</span>, <span class="string">'watch'</span>], () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 任務內容</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面這個寫法是錯的，前面有提到 Gulp 3 的 Array 寫法是以<strong>並行執行</strong>所有任務，也就代表當我們執行 <code>jade</code> 或 <code>sass</code> 任務時，編譯出來的檔案可能會被 <code>clean</code> 任務給直接清除掉，正確的流程應該為執行 <code>compile</code> 任務前，必須先執行 <code>clean</code> 任務且已執行完成，亦即<strong>串行執行</strong>，這時可使用 <a href="https://www.npmjs.com/package/run-sequence" target="_blank" rel="external nofollow noopener noreferrer">run-sequence</a> 套件來改寫任務：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'compile'</span>, () =&gt; &#123;</span><br><span class="line">  runSequence(<span class="string">'clean'</span>, [<span class="string">'jade'</span>, <span class="string">'sass'</span>, <span class="string">'watch'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>run-sequence 套件可幫助我們並行或串行執行任務，以上面這個範例來說，當我們執行 <code>gulp compile</code> 指令時，會先觸發 <code>clean</code> 任務，當任務完成時，才會並行觸發 <code>jade</code>、<code>sass</code>、<code>watch</code> 任務，相同的概念可無限延伸，可能會有人問，會不會有點麻煩？還需要載入套件才可以使用？沒錯！但這是 Gulp 3 的說法，Gulp 4 新增了兩個革命性的 API 以解決此問題，讓我們先來看範例：</p>
<!-- prettier-ignore-start -->
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(</span><br><span class="line">  <span class="string">"compile"</span>,</span><br><span class="line">  gulp.series(<span class="string">"clean"</span>, gulp.parallel(<span class="string">"jade"</span>, <span class="string">"sass"</span>, <span class="string">"watch"</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p><strong>Gulp 4 棄用了任務依賴改而使用執行函式來操作任務</strong>，也就代表如果你在 Gulp 4 版本中使用任務依賴的寫法(如同之前範例)，會引發錯誤，取而代之的是使用 <code>gulp.series()</code> 與 <code>gulp.parallel</code> API 來操作任務，兩者差別如下：</p>
<ul>
<li><p><code>gulp.series()</code>：用於串行(同步)任務執行，可接受 <code>taskname</code> 或 <code>function</code> 作為任務執行參數。</p>
</li>
<li><p><code>gulp.parallel</code>：用於並行(非同步)任務執行，可接受 <code>taskname</code> 或 <code>function</code> 作為任務執行參數。</p>
</li>
</ul>
<p>當初就是因為 Gulp 官方也認為依靠套件來處理串行、並行任務較不方便，進而改寫 Gulp 並推出這兩個 API，實際使用下來，我認為可以完全取代 Gulp 3 的任務依賴寫法，超好用的！舊有開發者也可以無痛上手，你可以幫她想像成 runSequence 套件的另一種寫法，不過不需要載入任何套件，此為 Gulp 4 內建 API，讓我們來看其他範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只載入 Gulp 相關 API</span></span><br><span class="line"><span class="keyword">const</span> &#123; series, parallel &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clean = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 任務內容</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> css = series(clean, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 任務內容</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> javascript = series(clean, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 任務內容</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 導出任務 --- */</span></span><br><span class="line">exports.build = parallel(css, javascript);</span><br></pre></td></tr></table></figure>

<p>上面這個範例存在一個 Bug，那就是 clean 任務在並行執行 <code>css</code> 與 <code>javascript</code> 任務時，被執行了兩次，這樣子的作法可能會導致無法預期的結果，在 Gulp 4 中，以先前介紹的 <code>function Task</code> 來說明，<strong>建議一個 function 只完成自己的任務內容，最後在導出任務</strong>，此時寫法可改為：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只載入 Gulp 相關 API</span></span><br><span class="line"><span class="keyword">const</span> &#123; series, parallel &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clean</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 任務內容</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">css</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 任務內容</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">javascript</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 任務內容</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 導出任務 --- */</span></span><br><span class="line">exports.build = series(clean, parallel(css, javascript));</span><br></pre></td></tr></table></figure>

<p>現在 <code>clean</code> 任務只會被執行一次，結構也變得更加明確，這才是 Gulp 的正確寫法與流程。</p>
<h2 id="非同步完成"><a href="#非同步完成" class="headerlink" title="非同步完成"></a>非同步完成</h2><p>在 Gulp 4 版本，非同步操作(並行執行)完成後須執行一個 callback 函式用以通知 Gulp 這個任務已經完成，讓我們直接來看範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, () =&gt; &#123;</span><br><span class="line">  gulp</span><br><span class="line">    .src(<span class="string">'./src/scss/*.scss'</span>)</span><br><span class="line">    .pipe(sass().on(<span class="string">'error'</span>, sass.logError))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./dist/css'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面是一個基本的編譯 SCSS 範例，此時執行 <code>gulp sass</code> 指令，會跳出如下圖錯誤：</p>
<img src="https://i.imgur.com/eiTqPEO.jpg" alt="Gulp 3 所有任務">

<p>這個問題是發生在 Gulp 無法明確知道 <code>sass</code> 任務何時結束進而引發的錯誤；在 Gulp 3 版本，此問題將被忽略，但在 Gulp 4 版本，更加的嚴格，你必須明確告知任務已經完成，好讓 Gulp 正常的處理流程，有以下幾種方法可以幫助我們告知任務已經完成：</p>
<ul>
<li>返回一個 Stream：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./src/scss/*.scss'</span>)</span><br><span class="line">    .pipe(sass().on(<span class="string">'error'</span>, sass.logError))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./dist/css'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>兌現 Promise：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(</span><br><span class="line">    gulp</span><br><span class="line">      .src(<span class="string">'./src/scss/*.scss'</span>)</span><br><span class="line">      .pipe(sass().on(<span class="string">'error'</span>, sass.logError))</span><br><span class="line">      .pipe(gulp.dest(<span class="string">'./dist/css'</span>))</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>調用 callback：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  gulp</span><br><span class="line">    .src(<span class="string">'./src/scss/*.scss'</span>)</span><br><span class="line">    .pipe(sass().on(<span class="string">'error'</span>, sass.logError))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./dist/css'</span>));</span><br><span class="line">  cb();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>返回 RxJS 觀察對象：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Observable = <span class="built_in">require</span>(<span class="string">"rx"</span>).Observable;</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">"sass"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Observable.return(</span><br><span class="line">    gulp</span><br><span class="line">      .src(<span class="string">"./src/scss/*.scss"</span>)</span><br><span class="line">      .pipe(sass().on(<span class="string">"error"</span>, sass.logError))</span><br><span class="line">      .pipe(gulp.dest(<span class="string">"./dist/css"</span>))</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>由上面幾種方法來說，調用 callback 看起來更加容易，這也是我一般開發較常使用的方法。</p>
<h2 id="Watch-API-可監聽全局事件"><a href="#Watch-API-可監聽全局事件" class="headerlink" title="Watch API 可監聽全局事件"></a>Watch API 可監聽全局事件</h2><p>Gulp 本身內建的監控檔案變動 API 相信大家都有使用過，基本上也算是開發者使用 Gulp 必備的功能，在 Gulp 3 版本，我們可使用 <code>gulp.watch()</code> 與 <code>gulp.watch().on()</code> 函式監控檔案變動，如下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'watch'</span>, () =&gt; &#123;</span><br><span class="line">  gulp.watch(<span class="string">'./src/scss/*.scss'</span>, gulp.series(<span class="string">'sass'</span>)).on(<span class="string">'change'</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event);</span><br><span class="line">    <span class="built_in">console</span>.log(path);</span><br><span class="line">    <span class="built_in">console</span>.log(stats);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>基本上 Gulp 3 版本的 <code>gulp.watch()</code> 已經可滿足大部分需求，一般開發足以應付，硬要挑剔的話，可能只剩無法全局監聽檔案可說嘴，但這的確是個問題，有時候我們需要知道更動檔案的相關資訊，比如說：新增、刪除事件等等，對於 Gulp 3 版本來講，是無法提供新增或刪除檔案等相關資料的，一部分人可能會去使用 <code>gulp-watch</code> 套件，這的確也是個辦法，但與之前提到的 run-sequence 套件來說，這些基本的功能也需要依靠套件去完成，會不會有點麻煩？到了 Gulp 4 版本，改寫了內部 <code>gulp.watch()</code> 的運作邏輯，新增了幾個參數可以使用，讓我們直接看範例：</p>
<!-- prettier-ignore-start -->
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">"watch"</span>, () =&gt; &#123;</span><br><span class="line">  gulp</span><br><span class="line">    .watch(<span class="string">"./src/scss/*.scss"</span>, gulp.series(<span class="string">"sass"</span>))</span><br><span class="line">    .on(<span class="string">"all"</span>, (event, path, stats) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(event);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>使用 function task：</p>
<!-- prettier-ignore-start -->
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exports.watch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  gulp</span><br><span class="line">    .watch(<span class="string">"./src/scss/*.scss"</span>, gulp.series(<span class="string">"sass"</span>))</span><br><span class="line">    .on(<span class="string">"all"</span>, (event, path, stats) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(event);</span><br><span class="line">      <span class="built_in">console</span>.log(path);</span><br><span class="line">      <span class="built_in">console</span>.log(stats);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>Gulp 4 版本的 <code>gulp.watch()</code> API 可使用 <code>all</code> 作為事件名稱，代表著任何事件都將被觸發，包含新增、刪除等等，以及新增了 <code>path</code> 與 <code>stats</code> 參數，訪問參數即可得知更動檔案的相關資訊，簡單來講就是小幅加強了 <code>gulp.watch()</code> 函式，也不需要再使用其他套件，內建的 API 足以勝任大部分工作。</p>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp 4</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Gulp 前端自動化 - 使用 ES6 Module 撰寫 Gulpfile</title>
    <url>/2020-02-03-gulp-gulpfilebabel/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>隨著 JavaScript 版本的推進，ES6 版本已逐漸大眾化，在各種開發環境下，ES6 相關語法都能夠更有效率的幫助你完成目的，唯一的問題是，在 Node 環境中，ES6 的大部分特性都以支援，唯獨模組化機制尚未完整支援，都還是得依靠 Babel 等相關編譯器將代碼編譯成 ES5 代碼以解決兼容性問題。此篇將使用 import/export 等 ES6 module 語法撰寫我們的 Gulpfile，並透過 Babel 編譯以保證任務成功運行。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>Babel 相關套件安裝</li>
<li>CommonJS 改成 ES6 Module 寫法</li>
</ul>
<h2 id="Babel-相關套件安裝"><a href="#Babel-相關套件安裝" class="headerlink" title="Babel 相關套件安裝"></a>Babel 相關套件安裝</h2><blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/@babel/core" target="_blank" rel="external nofollow noopener noreferrer">@babel/core</a>、<a href="https://www.npmjs.com/package/@babel/preset-env" target="_blank" rel="external nofollow noopener noreferrer">@babel/preset-env</a>、<a href="https://www.npmjs.com/package/@babel/register" target="_blank" rel="external nofollow noopener noreferrer">@babel/register</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install @babel/core @babel/preset-env @babel/register</span><br></pre></td></tr></table></figure>

<p>Babel 的核心套件就不多加以介紹，這邊比較值得注意的是 @babel/register 套件，它可以幫助我們改寫 require 命令，為它加上一個 hook，此後，每當使用 require 加載檔案時，就會先用 Babel 進行編譯。</p>
<h2 id="CommonJS-改成-ES6-Module-寫法"><a href="#CommonJS-改成-ES6-Module-寫法" class="headerlink" title="CommonJS 改成 ES6 Module 寫法"></a>CommonJS 改成 ES6 Module 寫法</h2><div class="note warning">此次範例會結合 gulp-sass 套件一起使用，相關文章連結：<a href="https://awdr74100.github.io/2019-12-31-gulp-gulpsass/" target="_blank">gulp-sass</a></div>

<p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── source&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── scss&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.scss     # SCSS 主檔案</span><br><span class="line">│</span><br><span class="line">├─── gulpfile.js          # Gulp 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json         # 安裝 gulp、gulp-sass、@babel&#x2F;core...</span><br></pre></td></tr></table></figure>

<p>CommonJS 模組規範寫法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compileSass = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./source/scss/*.scss'</span>)</span><br><span class="line">    .pipe(sass().on(<span class="string">'error'</span>, sass.logError))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/css'</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.sass = compileSass;</span><br></pre></td></tr></table></figure>

<p>上面為 Gulp 4 推薦的寫法，由於 Node 預設就以支援 CommonJS 模組規範，直接執行 gulp sass 即可運行任務，讓我們來改用 ES6 Module 寫法吧！</p>
<div class="note danger">使用 Babel 預編譯 Gulp 文件時，需將名稱從 gulpfile.js 改為 gulpfile.babel.js，否則無法偵測到文件需使用 Babel</div>

<p>將 <code>gulpfile.js</code> 改為 <code>gulpfile.babel.js</code>：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> gulp-demo/</span><br><span class="line"> │</span><br><span class="line"><span class="deletion">-├─── gulpfile.js</span></span><br><span class="line"><span class="addition">+└─── gulpfile.babel.js</span></span><br></pre></td></tr></table></figure>

<p>新增並配置 <code>.babelrc</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"@babel/preset-env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES6 Module 模組規範寫法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gulp <span class="keyword">from</span> <span class="string">'gulp'</span>;</span><br><span class="line"><span class="keyword">import</span> sass <span class="keyword">from</span> <span class="string">'gulp-sass'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compileSass = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./source/scss/*.scss'</span>)</span><br><span class="line">    .pipe(sass().on(<span class="string">'error'</span>, sass.logError))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/css'</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; compileSass <span class="keyword">as</span> sass &#125;;</span><br></pre></td></tr></table></figure>

<p>執行指定任務：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp sass</span><br></pre></td></tr></table></figure>

<p>此時結果會與 CommonJS 相同，雖然 Gulp 官方範例都是使用 CommonJS 的寫法，但對於早已習慣 import/export 語法的開發者來說，使用 Babel 雖然較為麻煩，無痛上手等特點卻值得你去嘗試使用它。</p>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp 4</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Gulp 前端自動化 - 基於 Gulp 4 的學習總結</title>
    <url>/2020-02-10-gulp-final/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此篇將紀錄從接觸 Gulp 開始到後來能夠獨立開發專案所需 Gulp 環境的學習總結。前面會先把之前所遇到的坑做一個解決辦法補充，比如透過 Babel 編譯後，require 語法無法在 Browser 運行等問題，以及使用 gulp-rename 套件後，該如何連同 HTML 相關的引用路徑做一個響應變動等等，最後也會提供我最為常用的 Gulp 開發環境，供有興趣的開發者快速導入現有專案。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>本系列文章</li>
<li>踩坑 - require 語法無法在 Browser 運行</li>
<li>踩坑 - HTML 引用路徑該如何做響應變動</li>
<li>總結 - Gulp 常用開發環境</li>
</ul>
<h2 id="本系列文章"><a href="#本系列文章" class="headerlink" title="本系列文章"></a>本系列文章</h2><ul>
<li><a href="https://awdr74100.github.io/2019-12-24-gulp-install/">Gulp 前端自動化 - 環境安裝與執行</a></li>
<li><a href="https://awdr74100.github.io/2019-12-31-gulp-gulpsass/">Gulp 前端自動化 - 編譯 Sass/SCSS</a></li>
<li><a href="https://awdr74100.github.io/2020-01-02-gulp-gulppug/">Gulp 前端自動化 - 編譯 Pug</a></li>
<li><a href="https://awdr74100.github.io/2020-01-08-gulp-gulpbabel/">Gulp 前端自動化 - 使用 Babel 編譯 ES6</a></li>
<li><a href="https://awdr74100.github.io/2020-01-12-gulp-gulppostcss/">Gulp 前端自動化 - PostCSS 與 Autoprefixer</a></li>
<li><a href="https://awdr74100.github.io/2020-01-13-gulp-gulpsourcemaps/">Gulp 前端自動化 - 生成 SourceMap 映射文件</a></li>
<li><a href="https://awdr74100.github.io/2020-01-14-gulp-browsersync/">Gulp 前端自動化 - Browsersync 瀏覽器同步測試工具</a></li>
<li><a href="https://awdr74100.github.io/2020-01-15-gulp-del/">Gulp 前端自動化 - 自動清除檔案與資料夾</a></li>
<li><a href="https://awdr74100.github.io/2020-01-17-gulp-gulphtmlmin-gulpcleancss-gulpuglify/">Gulp 前端自動化 - 壓縮 HTML、CSS、JavaScript 代碼</a></li>
<li><a href="https://awdr74100.github.io/2020-01-20-gulp-gulpimagemin/">Gulp 前端自動化 - 壓縮並優化圖片</a></li>
<li><a href="https://awdr74100.github.io/2020-01-21-gulp-minimist/">Gulp 前端自動化 - Minimist 命令行參數解析工具</a></li>
<li><a href="https://awdr74100.github.io/2020-01-22-gulp-gulprename/">Gulp 前端自動化 - 替換 Stream 中的檔案名稱</a></li>
<li><a href="https://awdr74100.github.io/2020-01-24-gulp-includebootstrap/">Gulp 前端自動化 - 導入 Bootstrap 客製並編譯它</a></li>
<li><a href="https://awdr74100.github.io/2020-01-26-gulp-modular/">Gulp 前端自動化 - CommonJS 模組化設計</a></li>
<li><a href="https://awdr74100.github.io/2020-01-28-gulp-upgradegulp/">Gulp 前端自動化 - 升級至 Gulp 4 完整說明</a></li>
<li><a href="https://awdr74100.github.io/2020-02-03-gulp-gulpfilebabel/">Gulp 前端自動化 - 使用 ES6 Module 撰寫 Gulpfile</a></li>
</ul>
<h2 id="踩坑-require-語法無法在-Browser-運行"><a href="#踩坑-require-語法無法在-Browser-運行" class="headerlink" title="踩坑 - require 語法無法在 Browser 運行"></a>踩坑 - require 語法無法在 Browser 運行</h2><p>在之前的 <a href="https://awdr74100.github.io/2020-01-08-gulp-gulpbabel/">使用 Babel 編譯 ES6</a> 文章中，有提到關於 @babel/runtime 與 @babel/polyfill 的使用方式，解決 Babel 預設只能處理 Syntax 的問題，但此時也就衍發了另一個問題，那就是編譯後檔案中的 require 語法是無法在 Browser 運行的，require 語法屬於 Node.js 的模組化語法，瀏覽器不兼容此語法，當初卡了這個問題好久，最後找到了 Webpack-stream 這一個套件，透過打包的方式解決此問題，讓我們直接來使用它吧！</p>
<p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── source&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── js&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.js</span><br><span class="line">│</span><br><span class="line">├─── gulpfile.js</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure>

<blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/gulp-babel" target="_blank" rel="external nofollow noopener noreferrer">gulp-babel</a>、<a href="https://www.npmjs.com/package/@babel/runtime-corejs3" target="_blank" rel="external nofollow noopener noreferrer">@babel/runtime-corejs3</a>、<a href="https://www.npmjs.com/package/@babel/plugin-transform-runtime" target="_blank" rel="external nofollow noopener noreferrer">@babel/plugin-transform-runtime</a></p>
</blockquote>
<p>安裝 Babel：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp-babel @babel/core @babel/preset-env</span><br></pre></td></tr></table></figure>

<p>安裝 Plugins：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install @babel/runtime-corejs3 @babel/plugin-transform-runtime</span><br></pre></td></tr></table></figure>

<p>撰寫 ES6+ 版本代碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = arr.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item &gt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>

<p>載入並使用 gulp-babel：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> babelTask = <span class="function"><span class="params">()</span> =&gt;</span> gulp.src(<span class="string">'./source/js/*.js'</span>).pipe(babel()).pipe(gulp.dest(<span class="string">'public/js'</span>));</span><br><span class="line"></span><br><span class="line">exports.default = babelTask;</span><br></pre></td></tr></table></figure>

<p>新增並配置 <code>.babelrc</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"@babel/preset-env"</span>],</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/plugin-transform-runtime"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"corejs"</span>: <span class="number">3</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行指定任務：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp</span><br></pre></td></tr></table></figure>

<p>編譯結果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _interopRequireDefault = <span class="built_in">require</span>(<span class="string">'@babel/runtime-corejs3/helpers/interopRequireDefault'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _filter = _interopRequireDefault(<span class="built_in">require</span>(<span class="string">'@babel/runtime-corejs3/core-js-stable/instance/filter'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> result = (<span class="number">0</span>, _filter[<span class="string">'default'</span>])(arr).call(arr, <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>

<p>瀏覽器運行結果(報錯)：</p>
<p><code style="color:#e74b4b">Uncaught ReferenceError: require is not defined</code></p>
<p>很明顯的 require 語法是無法在瀏覽器上運行的，通常都得透過像是 Webpack 的打包工具，將代碼轉換為適合瀏覽器的可用格式才能成功運行，事實上，Webpack-stream 就是 Webpack 用來與 Gulp 搭配的集成工具，透過 Webpack 的配置方式即可完成操作，讓我們先從安裝開始。</p>
<blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/webpack-stream" target="_blank" rel="external nofollow noopener noreferrer">webpack-stream</a>、<a href="https://github.com/babel/babel-loader" target="_blank" rel="external nofollow noopener noreferrer">babel-loader</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install webpack-stream babel-loader</span><br></pre></td></tr></table></figure>

<p>Webpack 本身是 Webpack-stream 相依套件，我們只需下載 Webpack-stream 即可，另外也必須下載 babel-loader 作為編譯的預處理器。</p>
<p>載入並使用 webpack-stream：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack-stream'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> babelTask = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  gulp</span><br><span class="line">    .src(<span class="string">'./source/js/*.js'</span>)</span><br><span class="line">    .pipe(</span><br><span class="line">      webpack(&#123;</span><br><span class="line">        mode: <span class="string">'production'</span>,</span><br><span class="line">        output: &#123;</span><br><span class="line">          filename: <span class="string">'all.js'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">module</span>: &#123;</span><br><span class="line">          rules: [</span><br><span class="line">            &#123;</span><br><span class="line">              test: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">              exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">              use: &#123;</span><br><span class="line">                loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'public/js'</span>));</span><br><span class="line"></span><br><span class="line">exports.default = babelTask;</span><br></pre></td></tr></table></figure>

<p>執行指定任務：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp</span><br></pre></td></tr></table></figure>

<p>瀏覽器運行結果(成功)：</p>
<p><code>[ 4, 5 ]</code></p>
<p>相信熟悉 Webpack 的人對於上面配置應該再清楚不過了，事實上，Webpack-stream 就是用來導入 Webpack 的 Gulp 工具，當 Webpack 所在的 Stream 處理完成時，即進入下一個 pipe 節點，由於 babel-loader 的使用，我們也不需要使用 gulp-babel 了，Webpack 與 Gulp 的結合就是採用此方法來完成，有興趣的可以在進行研究，之後也會推出一系列的 Webpack 文章，敬請期待。</p>
<h2 id="踩坑-HTML-引用路徑該如何做響應變動"><a href="#踩坑-HTML-引用路徑該如何做響應變動" class="headerlink" title="踩坑 - HTML 引用路徑該如何做響應變動"></a>踩坑 - HTML 引用路徑該如何做響應變動</h2><p>在我們之前介紹到 minimist 命令行參數解析工具時，有提到關於 development 與 production 環境的差別，當時是以 gulp-clean-css 與 gulp-rename 套件去做示例，假設當前為 production 環境，需使用 gulp-clean-css 壓縮代碼並且使用 gulp-rename 更改名稱為 <code>.min.css</code> 檔，此時當我們開啟 index.html 檔案時，會發現 js 與 css 都沒有被載入進來，因為此環境編譯後檔案是不存在 <code>.js</code> 或 <code>.css</code> 檔案的，檔名通通都改成 <code>.min</code> 了，可能會有人手動去更改編譯前的引用路徑，但這有違使用自動化工具的目的，這時我們可以使用 gulp-html-replace 套件來解決這一個問題，讓我們直接開始吧！</p>
<p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── source&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.css</span><br><span class="line">│   │</span><br><span class="line">│   └─── index.html</span><br><span class="line">│</span><br><span class="line">├─── gulpfile.js</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure>

<blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/del" target="_blank" rel="external nofollow noopener noreferrer">del</a>、<a href="https://www.npmjs.com/package/gulp-clean-css" target="_blank" rel="external nofollow noopener noreferrer">gulp-clean-css</a>、<a href="https://www.npmjs.com/search?q=gulp-if" target="_blank" rel="external nofollow noopener noreferrer">gulp-if</a>、<a href="https://www.npmjs.com/package/gulp-rename" target="_blank" rel="external nofollow noopener noreferrer">gulp-rename</a>、<a href="https://www.npmjs.com/package/minimist" target="_blank" rel="external nofollow noopener noreferrer">minimist</a>、<a href="https://www.npmjs.com/package/gulp-html-replace" target="_blank" rel="external nofollow noopener noreferrer">gulp-html-replace</a></p>
</blockquote>
<p>相關套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install del gulp-clean-css gulp-if gulp-rename minimist</span><br></pre></td></tr></table></figure>

<p>主要套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp-html-replace</span><br></pre></td></tr></table></figure>

<p>載入並使用 gulp-html-replace：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> cleanCSS = <span class="built_in">require</span>(<span class="string">'gulp-clean-css'</span>);</span><br><span class="line"><span class="keyword">const</span> parseArgs = <span class="built_in">require</span>(<span class="string">'minimist'</span>);</span><br><span class="line"><span class="keyword">const</span> gulpif = <span class="built_in">require</span>(<span class="string">'gulp-if'</span>);</span><br><span class="line"><span class="keyword">const</span> rename = <span class="built_in">require</span>(<span class="string">'gulp-rename'</span>);</span><br><span class="line"><span class="keyword">const</span> del = <span class="built_in">require</span>(<span class="string">'del'</span>);</span><br><span class="line"><span class="keyword">const</span> htmlreplace = <span class="built_in">require</span>(<span class="string">'gulp-html-replace'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 獲取命令行參數</span></span><br><span class="line"><span class="keyword">const</span> argv = parseArgs(process.argv.slice(<span class="number">2</span>)).env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> htmlTask = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./source/*.html'</span>)</span><br><span class="line">    .pipe(</span><br><span class="line">      gulpif(</span><br><span class="line">        argv === <span class="string">'production'</span>,</span><br><span class="line">        htmlreplace(&#123;</span><br><span class="line">          css: <span class="string">'css/all.min.css'</span>, <span class="comment">// 針對指定 name 做替換</span></span><br><span class="line">        &#125;)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cssTask = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'source/css/*.css'</span>)</span><br><span class="line">    .pipe(gulpif(argv === <span class="string">'production'</span>, cleanCSS(&#123; <span class="attr">compatibility</span>: <span class="string">'ie8'</span> &#125;)))</span><br><span class="line">    .pipe(</span><br><span class="line">      gulpif(</span><br><span class="line">        argv === <span class="string">'production'</span>,</span><br><span class="line">        rename(&#123;</span><br><span class="line">          suffix: <span class="string">'.min'</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'public/css'</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clean = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> del([<span class="string">'public'</span>]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.default = gulp.series(clean, gulp.parallel(htmlTask, cssTask));</span><br></pre></td></tr></table></figure>

<p>開啟 <code>./source/index.html</code> 並輸入以下註解：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- build:css --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/all.css"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- endbuild --&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 production 環境執行指定任務：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp --env production</span><br></pre></td></tr></table></figure>

<p>編譯結果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/all.min.css"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>從上面結果可得知，使用 gulp-html-replace 套件確實可以響應引用路徑，它的原理其實很簡單，如下範例：</p>
<p><code>index.html</code>：</p>
<!-- prettier-ignore-start -->
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- build:css1 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/style1"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- endbuild --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- build:css2 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/style2"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- endbuild --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- build:js --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/js1"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/js2"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/js3"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- endbuild --&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p><code>gulpfile.js</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">htmlreplace(&#123;</span><br><span class="line">  css1: <span class="string">'css/style1.min.css'</span>, <span class="comment">// 針對 css1 塊做替換</span></span><br><span class="line">  css2: <span class="string">'css/style2.min.css'</span>, <span class="comment">// 針對 css2 塊做替換</span></span><br><span class="line">  js: <span class="string">'js/all.min.js'</span>, <span class="comment">// 針對 js 塊做替換</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>編譯結果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/style1.min.css"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/style2.min.css"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/all.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用 gulp-html-replace 的關鍵在於 <code>&lt;!-- build:name --&gt;</code> 註解中的 name 需要與 <code>htmlreplace</code> 中的 <code>key</code> 相互對應，告知此區塊開始進行處理，並且加入<code>&lt;!-- endbuild --&gt;</code> 告知此處結束處理，這邊要注意的是此操作是以塊的方式進行處理，如同上面範例的 js 區塊，不管有幾行的代碼，通通都會被取代成相對應的代碼，搭配 gulp-if 等相關套件即可解決 gulp-rename 後引用路徑錯誤的問題，達到真正的自動化效果。</p>
<h2 id="總結-Gulp-常用開發環境"><a href="#總結-Gulp-常用開發環境" class="headerlink" title="總結 - Gulp 常用開發環境"></a>總結 - Gulp 常用開發環境</h2><table>
<thead>
<tr>
<th>主要套件</th>
<th>優化套件</th>
<th>輔助套件</th>
<th>通用套件</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.npmjs.com/package/gulp-babel" target="_blank" rel="external nofollow noopener noreferrer">gulp-babel</a></td>
<td><a href="https://www.npmjs.com/package/gulp-clean-css" target="_blank" rel="external nofollow noopener noreferrer">gulp-clean-css</a></td>
<td><a href="https://www.npmjs.com/package/gulp-rename" target="_blank" rel="external nofollow noopener noreferrer">gulp-rename</a></td>
<td><a href="https://www.npmjs.com/package/browser-sync" target="_blank" rel="external nofollow noopener noreferrer">browser-sync</a></td>
</tr>
<tr>
<td><a href="https://www.npmjs.com/package/gulp-pug" target="_blank" rel="external nofollow noopener noreferrer">gulp-pug</a></td>
<td><a href="https://www.npmjs.com/package/gulp-htmlmin" target="_blank" rel="external nofollow noopener noreferrer">gulp-htmlmin</a></td>
<td><a href="https://www.npmjs.com/package/gulp-html-replace" target="_blank" rel="external nofollow noopener noreferrer">gulp-html-replace</a></td>
<td><a href="https://www.npmjs.com/package/minimist" target="_blank" rel="external nofollow noopener noreferrer">minimist</a></td>
</tr>
<tr>
<td><a href="https://www.npmjs.com/package/gulp-sass" target="_blank" rel="external nofollow noopener noreferrer">gulp-sass</a></td>
<td><a href="https://www.npmjs.com/package/gulp-imagemin" target="_blank" rel="external nofollow noopener noreferrer">gulp-imagemin</a></td>
<td><a href="https://www.npmjs.com/package/gulp-sourcemaps" target="_blank" rel="external nofollow noopener noreferrer">gulp-sourcemaps</a></td>
<td><a href="https://www.npmjs.com/package/webpack-stream" target="_blank" rel="external nofollow noopener noreferrer">webpack-stream</a></td>
</tr>
<tr>
<td><a href="https://www.npmjs.com/package/gulp-postcss" target="_blank" rel="external nofollow noopener noreferrer">gulp-postcss</a></td>
<td><a href="https://www.npmjs.com/package/gulp-uglify" target="_blank" rel="external nofollow noopener noreferrer">gulp-uglify</a></td>
<td><a href="https://www.npmjs.com/package/gulp-if" target="_blank" rel="external nofollow noopener noreferrer">gulp-if</a></td>
<td><a href="https://www.npmjs.com/package/del" target="_blank" rel="external nofollow noopener noreferrer">del</a></td>
</tr>
</tbody></table>
<p>安裝套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm i gulp-babel gulp-sass gulp-postcss gulp-clean-css gulp-htmlmin gulp-imagemin gulp-uglify gulp-rename gulp-html-replace gulp-sourcemaps gulp-if browser-sync minimist webpack-stream del</span><br></pre></td></tr></table></figure>

<p>Babel 相關套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm i @babel/core @babel/preset-env @babel/plugin-transform-runtime @babel/runtime-corejs3</span><br></pre></td></tr></table></figure>

<p>PostCSS 相關套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm i autoprefixer</span><br></pre></td></tr></table></figure>

<p>Webpack-stream 相關套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm i babel-loader</span><br></pre></td></tr></table></figure>

<p>新增並配置 <code>gulpfile.js</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>);</span><br><span class="line"><span class="keyword">const</span> pug = <span class="built_in">require</span>(<span class="string">'gulp-pug'</span>);</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>);</span><br><span class="line"><span class="keyword">const</span> postcss = <span class="built_in">require</span>(<span class="string">'gulp-postcss'</span>);</span><br><span class="line"><span class="keyword">const</span> autoprefixer = <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>);</span><br><span class="line"><span class="keyword">const</span> sourcemaps = <span class="built_in">require</span>(<span class="string">'gulp-sourcemaps'</span>);</span><br><span class="line"><span class="keyword">const</span> browserSync = <span class="built_in">require</span>(<span class="string">'browser-sync'</span>).create();</span><br><span class="line"><span class="keyword">const</span> del = <span class="built_in">require</span>(<span class="string">'del'</span>);</span><br><span class="line"><span class="keyword">const</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line"><span class="keyword">const</span> cleanCSS = <span class="built_in">require</span>(<span class="string">'gulp-clean-css'</span>);</span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">const</span> imagemin = <span class="built_in">require</span>(<span class="string">'gulp-imagemin'</span>);</span><br><span class="line"><span class="keyword">const</span> parseArgs = <span class="built_in">require</span>(<span class="string">'minimist'</span>);</span><br><span class="line"><span class="keyword">const</span> gulpif = <span class="built_in">require</span>(<span class="string">'gulp-if'</span>);</span><br><span class="line"><span class="keyword">const</span> rename = <span class="built_in">require</span>(<span class="string">'gulp-rename'</span>);</span><br><span class="line"><span class="keyword">const</span> htmlreplace = <span class="built_in">require</span>(<span class="string">'gulp-html-replace'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack-stream'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 獲取命令行參數 --- */</span></span><br><span class="line"><span class="keyword">const</span> argv = parseArgs(process.argv.slice(<span class="number">2</span>)).env;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 編譯 Sass/SCSS --- */</span></span><br><span class="line"><span class="keyword">const</span> scssTask = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./source/scss/*.scss'</span>)</span><br><span class="line">    .pipe(sourcemaps.init())</span><br><span class="line">    .pipe(sass().on(<span class="string">'error'</span>, sass.logError))</span><br><span class="line">    .pipe(postcss())</span><br><span class="line">    .pipe(gulpif(argv === <span class="string">'production'</span>, cleanCSS(&#123; <span class="attr">compatibility</span>: <span class="string">'ie8'</span> &#125;)))</span><br><span class="line">    .pipe(</span><br><span class="line">      gulpif(</span><br><span class="line">        argv === <span class="string">'production'</span>,</span><br><span class="line">        rename(&#123;</span><br><span class="line">          suffix: <span class="string">'.min'</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    .pipe(sourcemaps.write(<span class="string">'./'</span>))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/css'</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 編譯 HTML --- */</span></span><br><span class="line"><span class="keyword">const</span> htmlTask = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'source/**/*.html'</span>)</span><br><span class="line">    .pipe(gulpif(argv === <span class="string">'production'</span>, htmlmin(&#123; <span class="attr">collapseWhitespace</span>: <span class="literal">true</span> &#125;)))</span><br><span class="line">    .pipe(</span><br><span class="line">      gulpif(</span><br><span class="line">        argv === <span class="string">'production'</span>,</span><br><span class="line">        htmlreplace(&#123;</span><br><span class="line">          css: <span class="string">'css/all.min.css'</span>,</span><br><span class="line">          js: <span class="string">'js/all.min.js'</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/'</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 編譯 ES6+ 代碼 --- */</span></span><br><span class="line"><span class="keyword">const</span> babelTask = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'./source/js/*.js'</span>)</span><br><span class="line">    .pipe(babel())</span><br><span class="line">    .pipe(</span><br><span class="line">      webpack(&#123;</span><br><span class="line">        mode: <span class="string">'development'</span>,</span><br><span class="line">        output: &#123;</span><br><span class="line">          filename: <span class="string">'all.js'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">module</span>: &#123;</span><br><span class="line">          rules: [</span><br><span class="line">            &#123;</span><br><span class="line">              test: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">              exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">              use: &#123;</span><br><span class="line">                loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .pipe(gulpif(argv === <span class="string">'production'</span>, uglify()))</span><br><span class="line">    .pipe(</span><br><span class="line">      gulpif(</span><br><span class="line">        argv === <span class="string">'production'</span>,</span><br><span class="line">        rename(&#123;</span><br><span class="line">          suffix: <span class="string">'.min'</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/js/'</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 本地伺服器 --- */</span></span><br><span class="line"><span class="keyword">const</span> watch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  browserSync.init(&#123;</span><br><span class="line">    server: &#123;</span><br><span class="line">      baseDir: <span class="string">'./public'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  gulp.watch(<span class="string">'./source/js/*.js'</span>, gulp.series(babelTask));</span><br><span class="line">  gulp.watch(<span class="string">'./source/*.html'</span>, gulp.series(htmlTask));</span><br><span class="line">  gulp.watch(<span class="string">'./source/scss/*.scss'</span>, gulp.series(scssTask));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 刪除指定目錄檔案 --- */</span></span><br><span class="line"><span class="keyword">const</span> cleanTask = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> del([<span class="string">'./public'</span>]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 壓縮圖檔 --- */</span></span><br><span class="line"><span class="keyword">const</span> imageTask = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'source/img/*'</span>)</span><br><span class="line">    .pipe(gulpif(argv === <span class="string">'production'</span>, imagemin()))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'public/img'</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  scss: scssTask, <span class="comment">// 單獨編譯 Sass/SCSS</span></span><br><span class="line">  html: htmlTask, <span class="comment">// 單獨編譯 HTML</span></span><br><span class="line">  babel: babelTask, <span class="comment">// 單獨編譯 ES6+ 代碼</span></span><br><span class="line">  image: imageTask, <span class="comment">// 壓縮圖檔</span></span><br><span class="line">  clean: cleanTask, <span class="comment">// 刪除指定檔案目錄</span></span><br><span class="line">  serve: gulp.series(cleanTask, gulp.parallel(scssTask, htmlTask, babelTask, imageTask), watch),</span><br><span class="line">  build: gulp.series(cleanTask, gulp.parallel(scssTask, htmlTask, babelTask, imageTask)),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新增並配置 <code>.babelrc</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"@babel/preset-env"</span>],</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/plugin-transform-runtime"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"corejs"</span>: <span class="number">3</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增並配置 <code>postcss.config.js</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [<span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新增並配置 <code>.browserslistrc</code>：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">last 2 version</span><br><span class="line">&gt; 1%</span><br><span class="line">IE 10</span><br></pre></td></tr></table></figure>

<p>學到了這邊，看到很多相關文章都在探討 Webpack 將會取代 Gulp 成為主流，但我認為兩者本質上是不同的東西，何來比較？各有各的優缺點，雙方是互補的，在上面範例中，由於 require 無法運行在瀏覽器上面，我也是導入 Webpack-stream 用以打包代碼，並沒有誰好誰不好的說法，Gulp 適合小型開發，配置簡單，輕鬆上手，而 Wepack 適合開發稍有規模的專案，尤其是 SPA (單頁式應用)，對於筆者來講，兩個工具都把它學起來，就沒有這麼多的麻煩了，之後也會有一系列的 Webpack 文章，敬請期待。</p>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp 4</tag>
        <tag>Node.js</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Windows 環境下使用 nvm 管控 NodeJS</title>
    <url>/2020-02-15-nodejs-nvm/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>nvm 全名為 Node Version Manager，是一套用來管理 Node.js 版本的工具，在現代開發中，我們很常導入現有的 npm 套件幫助開發，像是 Webpack、Gulp、Browserify 等等，而這些套件都得依靠 Node.js 環境才能運行，且由於版本的差異，可能會造成無法運行的錯誤，開發者須同時擁有多個 Node.js 版本才方便進行測試，有別於以往 Node.js 下載安裝檔造成版本的綁定，使用 nvm 可同時存在多個 Node.js 版本，使用簡單的指令即可切換版本，推薦給所有的 Node.js 開發者。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>nvm 安裝</li>
<li>nvm 基本使用</li>
</ul>
<h2 id="nvm-安裝"><a href="#nvm-安裝" class="headerlink" title="nvm 安裝"></a>nvm 安裝</h2><p>nvm 在不同系統中有對應的安裝工具，分別如下：</p>
<ul>
<li>Windows 用戶：<a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="external nofollow noopener noreferrer">nvm-windows</a></li>
<li>Mac OS、Linux 用戶：<a href="https://github.com/nvm-sh/nvm" target="_blank" rel="external nofollow noopener noreferrer">nvm</a></li>
</ul>
<p>如果曾經透過官方下載 Node.js，請先執行以下動作：</p>
<ul>
<li>將 Node.js 完整移除</li>
<li>將 <code>npm</code> 資料夾徹底移除(預設位置：<code>C：\users\userName\AppData\Roaming\npm</code>)</li>
</ul>
<hr>
<p>由於筆者本身是使用 Windows 系統，下面介紹將會以此環境為主。</p>
<p>首先從 <a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="external nofollow noopener noreferrer">此處</a> 找到「<strong>nvm-setup.zip</strong>」下載並安裝，過程如同安裝一般程式，一路 <strong>Next</strong> 就對了！</p>
<img src="https://i.imgur.com/X994OQW.png" alt="nvm-setup">

<p>安裝完成後，可輸入 <code>nvm</code> 查看相關可用指令，如下圖所示：</p>
<img src="https://i.imgur.com/RZfLlGA.png" alt="nvm-order">

<p>nvm 常見指令如下：</p>
<ul>
<li><code>nvm list</code><ul>
<li>列出本機已安裝的 Node.js 清單</li>
</ul>
</li>
<li><code>nvm list available</code><ul>
<li>列出所有官方可安裝的 Node.js 清單</li>
</ul>
</li>
<li><code>nvm install latest</code><ul>
<li>安裝最新版本的 Node.js</li>
</ul>
</li>
<li><code>nvm install &lt;版本號&gt;</code><ul>
<li>安裝特定版本號的 Node.js</li>
</ul>
</li>
<li><code>nvm uninstall &lt;版本號&gt;</code><ul>
<li>移除特定版本號的 Node.js</li>
</ul>
</li>
<li><code>nvm use &lt;版本號&gt;</code><ul>
<li>切換成指定 Node.js 版本</li>
</ul>
</li>
</ul>
<h2 id="nvm-基本使用"><a href="#nvm-基本使用" class="headerlink" title="nvm 基本使用"></a>nvm 基本使用</h2><p>輸入 <code>nvm list available</code> 確認官方可安裝 Node.js 清單：</p>
<p><img src="https://i.imgur.com/AwM3CEo.png" alt="nvm-list-available"></p>
<p>輸入 <code>nvm install 12.16.0</code> 安裝特定版本的 Node.js：</p>
<p><img src="https://i.imgur.com/fMnbj4Q.png" alt="nvm-install"></p>
<p>輸入 <code>nvm use 12.16.0</code> 切換成指定 Node.js 版本：</p>
<p><img src="https://i.imgur.com/yQzLzJd.png" alt="nvm-use"></p>
<p>以上為基本的 nvm 使用方式，這邊要注意的是，每一個 Node.js 版本，都隨附 npm 工具，而 npm 工具互相是獨立的全域環境，比如說 13.7.0 版本的全域 npm 套件是無法在 12.16.0 版本使用的。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>針對不同版本的 Node.js 開啟 ECMAScript 模塊支持</title>
    <url>/2020-02-16-nodejs-enableesm/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>當初在學習 ES6 Modules 相關語法時，主要得依靠 Babel 編譯才能在 Node.js 中運行，原因為 Node.js 預設是使用 CommonJS 模組規範，事實上，大可不必這麼麻煩，Node.js 原生是支援 ES6 Modules 模組規範的，不過得透過一些方法才能將其切換，且不同版本還有各自的切換方法。本篇將使用 nvm (Node Version Manager) 切換不同的 Node.js 版本，並介紹在不同版本下該如何啟用對 ECMAScript 模塊的支持。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>Node.js v12 版本切換方式</li>
<li>Node.js v13 版本切換方式</li>
</ul>
<h2 id="Node-js-v12-版本切換方式"><a href="#Node-js-v12-版本切換方式" class="headerlink" title="Node.js v12 版本切換方式"></a>Node.js v12 版本切換方式</h2><p>輸入 <code>nvm use 12.16.0</code> 切換成指定 Node.js 版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nvm use 12.16.0</span><br></pre></td></tr></table></figure>

<p>參考 <a href="https://nodejs.org/dist/latest-v12.x/docs/api/esm.html#esm_enabling" target="_blank" rel="external nofollow noopener noreferrer">官方文檔</a> 啟用方式：</p>
<ul>
<li>使用 <code>--experimental-modules</code> 標誌，啟用對 ECMAScript 模塊的支持。</li>
</ul>
<p>啟用後，以下操作將視為 ECMAScript 模塊：</p>
<ul>
<li>帶有 <code>.mjs</code> 結尾的文件。</li>
<li><code>package.json</code> 文件包含 <code>&quot;type&quot;: &quot;module&quot;</code> 屬性。</li>
</ul>
<p>範例 (1)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* --- main.mjs --- */</span></span><br><span class="line"><span class="keyword">import</span> fun <span class="keyword">from</span> <span class="string">'./module.mjs'</span>;</span><br><span class="line"></span><br><span class="line">fun();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- module.mjs --- */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>輸入以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node --experimental-modules main.mjs</span><br></pre></td></tr></table></figure>

<p>範例 (2)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* --- main.js --- */</span></span><br><span class="line"><span class="keyword">import</span> fun <span class="keyword">from</span> <span class="string">'./module.mjs'</span>;</span><br><span class="line"></span><br><span class="line">fun();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- module.js --- */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* --- package.json --- */</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"type"</span>: <span class="string">"module"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>輸入以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node --experimental-modules main.js</span><br></pre></td></tr></table></figure>

<h2 id="Node-js-v13-版本切換方式"><a href="#Node-js-v13-版本切換方式" class="headerlink" title="Node.js v13 版本切換方式"></a>Node.js v13 版本切換方式</h2><p>輸入 <code>nvm use 13.7.0</code> 切換成指定 Node.js 版本：</p>
<p>參考 <a href="https://nodejs.org/dist/latest-v13.x/docs/api/esm.html#esm_enabling" target="_blank" rel="external nofollow noopener noreferrer">官方文檔</a> 啟用方式：</p>
<p><strong>v13 版本不須傳遞任何標誌，本身已支持 ECMAScript。</strong></p>
<p>以下操作將視為 ECMAScript 模塊：</p>
<ul>
<li>帶有 <code>.mjs</code> 結尾的文件。</li>
<li><code>package.json</code> 文件包含 <code>&quot;type&quot;: &quot;module&quot;</code> 屬性。</li>
</ul>
<p>範例 (1)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* --- main.mjs --- */</span></span><br><span class="line"><span class="keyword">import</span> fun <span class="keyword">from</span> <span class="string">'./module.mjs'</span>;</span><br><span class="line"></span><br><span class="line">fun();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- module.mjs --- */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>輸入以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node main.mjs</span><br></pre></td></tr></table></figure>

<p>範例 (2)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* --- main.js --- */</span></span><br><span class="line"><span class="keyword">import</span> fun <span class="keyword">from</span> <span class="string">'./module.mjs'</span>;</span><br><span class="line"></span><br><span class="line">fun();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- module.js --- */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* --- package.json --- */</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"type"</span>: <span class="string">"module"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>輸入以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node main.js</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 前端打包工具 - 環境安裝與基本配置</title>
    <url>/2020-02-17-webpack-install/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Webpack 可說是近年來最為熱門的技術，以往在編寫 ES6、Sass/SCSS、Pug、CoffeeScript 等預處理器或需編譯內容時，通常都得透過自動化工具，如 Gulp、Grunt 等任務流程執行工具進行編譯處理，到了現在，Webpack 已逐漸取代這些工具，Webpack 本身提供許多強大的功能，包含現正熱門的 SPA (單頁式應用) 透過配置 loader 方式也能輕鬆應付。本篇將從 Webpack 運行原理開始做介紹，接著說明該如何建立 Webpack 運行環境，最後透過打包方式產出我們的第一個 bundle.js 檔案。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>Webpack 簡介</li>
<li>Webpack 安裝</li>
<li>Webpack 基本配置</li>
<li>Webpack 額外說明 - 指定運行環境</li>
<li>Webpack 額外說明 - 使用 ESM 模組規範</li>
<li>Webpack 額外說明 - 多個入口起點</li>
</ul>
<h2 id="Webpack-簡介"><a href="#Webpack-簡介" class="headerlink" title="Webpack 簡介"></a>Webpack 簡介</h2><p><img src="https://i.imgur.com/KznxzWD.png" alt="Webpack 介紹"></p>
<p>Webpack 本身是一個開源的 JavaScript 模組打包工具，提供了前端缺乏的模組化開發方式，將各種靜態資源視為模組，當執行相關命令進行編譯時，將依 <code>webpack.config.js</code> 配置檔案執行優化並將其 entry 檔案打包成單個 JavaScript 檔案。</p>
<p>你可能會好奇，Webpack 所針對的模組不是指 JavaScript 模組嗎？那他要如何像 Gulp 一樣處理 <code>.scss</code>、<code>.pug</code> 之類的檔案呢？這時就得提到 Webpack Loader 這一個東西，它可將 JavaScript 以外的檔案透過解析，將其轉換為 JavaScript 模組，非常的特別，這點在後面都會有提到，簡單來講，Webpack 可幫我們完成以下事情：</p>
<ul>
<li>整合 CommonJS &amp; AMD &amp; ES6 Modulrs 模組規範</li>
<li>編譯 Sass/SCSS、Pug、CoffeeScript 等預處理器</li>
<li>轉換 TypeScript、ECMAScript 6 相關代碼</li>
<li>解析模組間的相互依賴，進行打包處理</li>
<li>other…</li>
</ul>
<p>Webpack 最大的特色就在於模組打包，上圖所呈現的就是打包的進行方式，且能解決模組間的相互依賴問題，這也是一般人常說 Webpack 比 Gulp 更為適合開發 SPA (單頁式應用) 的關鍵，由於 Webpack 是以模組為基石，我們可以更為自由的操作整體結構，非常的強大，讓我們先從安裝開始說起。</p>
<h2 id="Webpack-安裝"><a href="#Webpack-安裝" class="headerlink" title="Webpack 安裝"></a>Webpack 安裝</h2><div class="note warning">本篇教學都是採用 Webpack 4 版本，與 v3 版本有些許不同，請稍加注意</div>

<p>Webpack 依賴 Node.js 環境，需先進行安裝。在這邊使用 nvm 進行安裝：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm install 12.14.1</span><br></pre></td></tr></table></figure>

<p>當然你也可以使用 <a href="https://nodejs.org/en/" target="_blank" rel="external nofollow noopener noreferrer">官方安裝檔</a> 安裝 Node.js，接著使用以下指令查看是否正確安裝：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/ysAfrID.png" alt="node 是否正確安裝"></p>
<p>讓我們先建立一個專案資料夾並切換：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir webpack-demo</span><br><span class="line"><span class="built_in">cd</span> webpack-demo</span><br></pre></td></tr></table></figure>

<p>初始化專案並生成 <code>package.json</code> 檔案：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure>

<p>安裝 webpack 所需相關套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install webpack webpack-cli -D</span><br></pre></td></tr></table></figure>

<p>這邊要注意的是 Webpack 4 把以往都綁在 Webpack 內的 Webpack-CLI 挪出來另外安裝，所以除了安裝 Webpack 外還要記得安裝 Webpack-CLI。且由於 Webpack 不像是 Gulp 需要指定編譯內容，所以我們可將 Webpack 安裝在專案環境，並透過 npm script 執行即可，官方也推薦此做法。</p>
<h2 id="Webpack-基本配置"><a href="#Webpack-基本配置" class="headerlink" title="Webpack 基本配置"></a>Webpack 基本配置</h2><p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── main.js          # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── webpack.config.js    # Webpack 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json         # 已安裝 webpack、webpack-cli</span><br></pre></td></tr></table></figure>

<p>請依造上面專案結構所示，新增 <code>src/main.js</code> 與 <code>webpack.config.js</code> 檔案。</p>
<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>讓我們來了解一下 Webpack 配置檔有什麼東西：</p>
<ul>
<li><strong>entry</strong><ul>
<li>用來設定 entry 檔案的進入點，也就是 JavaScript 模組檔案的入口處</li>
</ul>
</li>
<li><strong>output</strong><ul>
<li><strong>path</strong>：設定打包後的 JavaScript 檔案放置路徑，通常都會搭配 path 模組以形成絕對路徑<ul>
<li><code>__dirname</code>：c:\Users\blue\Desktop\webpack-demo</li>
<li><code>path.resolve(...)</code>：c:\Users\blue\Desktop\webpack-demo\dist</li>
</ul>
</li>
<li><strong>filename</strong>：打包後的 JavaScript 檔案名稱，你也可以這樣寫 <code>js/bundle.js</code></li>
</ul>
</li>
</ul>
<p>entry 入口處 (<code>src/main.js</code>) 鍵入以下內容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myName = <span class="string">'Roya'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hello '</span> + myName);</span><br></pre></td></tr></table></figure>

<p>至 <code>package.json</code> 新增編譯指令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --mode development"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行編譯指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>此時你會發現專案根目錄新增了 <code>dist/bundle.js</code> 檔案，這個檔案就是依照 <code>webpack.config.js</code> 配置所打包而成的 JavaScript 檔案，可直接做引入。</p>
<p>新增 <code>./index.html</code> 並引入打包而成的 <code>bundle.js</code> 檔案：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 其他省略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/bundle.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>觀察 Console 結果：</p>
<p><img src="https://i.imgur.com/dFTKYWQ.png" alt="console"></p>
<p>當出現以上結果，即代表操作流程正確無誤，同時也恭喜你成功打包了第一個項目，這也就是 Webpack 整個的處理流程，是不是很容易？但這僅僅是 Webpack 的冰山一角，我們可以透過其他配置來完成更為進階的操作，讓我們先從運行環境開始說起。</p>
<h2 id="Webpack-額外說明-指定運行環境"><a href="#Webpack-額外說明-指定運行環境" class="headerlink" title="Webpack 額外說明 - 指定運行環境"></a>Webpack 額外說明 - 指定運行環境</h2><p>在前面的 <code>package.json</code> 中，我們新增了以下的編譯指令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --mode development"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事實上，這道命令驅動了 Webpack 在 development 環境執行編譯，我們可以嘗試把 <code>--mode development</code> 拿掉，如下所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行 <code>npm run build</code> 指令並察看結果：</p>
<p><img src="https://i.imgur.com/S1c5Rok.png" alt="webpack運行環境"></p>
<p>你會發現 Webpack 雖然編譯成功，但跳出了相關的警告，警告內容為提醒你尚未配置 mode 選項，預設將以 production 為運行環境，此時觀察 <code>dist/bundle.js</code> 檔案，你會發現全部 JavaScript 都已被壓縮，這個概念就類似於使用 Uglify 套件進行壓縮，<strong>Webpack 本身以集成壓縮相關套件</strong>，在我們執行編譯命令時，可加入 mode 選項，指定當前的編譯環境並觸發相關的優化，以下為可選的項目：</p>
<ul>
<li>development：指定為開發環境(未壓縮代碼)</li>
<li>production：指定為生產環境(壓縮代碼)</li>
<li>none：退出任何默認優化選項</li>
</ul>
<p>根據 <a href="https://webpack.js.org/configuration/mode/" target="_blank" rel="external nofollow noopener noreferrer">官方文件</a> 顯示，如果沒有指定當前環境，Webpack 會將 <code>mode</code> 選項設置為 <code>production</code> 環境，也就是默認選項。</p>
<p>CLI 命令傳遞 <code>mode</code> 選項：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --mode development"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相當於在 <code>webpack.config.js</code> 中設置 <code>mode</code> 選項：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>經過了以上介紹，你會發現 Webpack 本身以集成了許多功能，以往在使用 Gulp 時，都必須倚賴相關套件才能達到相同效果，Webpack 把這些使用頻率較高的套件集成在自己身上，透過簡單配置，即可達到相同效益，非常的方便。</p>
<h2 id="Webpack-額外說明-使用-ESM-模組規範"><a href="#Webpack-額外說明-使用-ESM-模組規範" class="headerlink" title="Webpack 額外說明 - 使用 ESM 模組規範"></a>Webpack 額外說明 - 使用 ESM 模組規範</h2><p>以往在開發 Gulp 時，都只能使用 CommonJS 模組規範相關語法做撰寫，當然你也可以使用 <code>gulpfile.babel.js</code> 並導入 Babel 做撰寫，但你不會覺得這樣有點太麻煩了嗎？ESM 規範語法確實好用，但兼容性問題未解決之前，一切真的都免談。基於 Webpack 本身就是以模組為核心，他很完美的整合了各式的模組規範，你不需要載入任何的套件，照正常編寫即可，以下為 ES6 Modules 範例：</p>
<p>請先新增 <code>src/js/module.js</code> 檔案並輸入以下內容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 entry 入口處引入模組：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fun <span class="keyword">from</span> <span class="string">'./js/module'</span>;</span><br><span class="line"></span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>

<p>執行 <code>npm run build</code> 進行打包並觀察引入後 Console 結果：</p>
<p><img src="https://i.imgur.com/QMSUbjr.png" alt="基於 Webpack 的 ESM 示範"></p>
<p>當出現以上結果及代表編譯成功，我們沒有進行任何配置，就只是單純的使用 ESM 規範語法而已，這也是 Webpack 的其中一個特點，<strong>在 entry 入口處的任意檔案能夠隨意使用任何模組規範</strong>，透過 Webpack 解析模組間的相互依賴關係，最後打包成靜態檔案，當瀏覽器引入時也不存在兼容性等問題。</p>
<h2 id="Webpack-額外說明-多個入口起點"><a href="#Webpack-額外說明-多個入口起點" class="headerlink" title="Webpack 額外說明 - 多個入口起點"></a>Webpack 額外說明 - 多個入口起點</h2><p>上面所講述的，都是以單個頁面，也就是單個 <code>index.html</code> 為主，但有時我們會需要開發多個頁面的網站，這時該怎麼配置 Webpack 呢？請先在 <code>src</code> 資料夾建立以下所需檔案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── main.js          # entry 入口檔案(1)</span><br><span class="line">│   └─── about.js         # entry 入口檔案(2)</span><br></pre></td></tr></table></figure>

<p>至 <code>webpack.config.js</code> 進行配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/main.js'</span>,</span><br><span class="line">    about: <span class="string">'./src/about.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>事實上，entry 入口處除了以字串型式宣告入口文件路徑外，還能夠以物件的方式進行傳遞，如上面範例所示，且傳統我們會稱 <code>entry.main</code>、<code>entry.about</code> 為物件的 “key”，在 Webpack 中稱之為 “chunk”，而一個 “chunk” 對應一個 entry 入口文件路徑，這樣子的型式稱之為多入口文件，最後 output 時也會各自打包成獨立的 JavaScript 檔案，最後要注意的是 <code>output.filename</code> 中檔案名稱的寫法，等等會再作解釋，讓我們先執行 <code>npm run build</code> 編譯看看：</p>
<p><img src="https://i.imgur.com/12r89pn.png" alt="webpack result"></p>
<p>觀察打包後的 dist 資料夾，確實生成了 <code>about.js</code> 與 <code>main.js</code> 檔案，有別於以往寫死名稱的作法，使用 <code>[name]</code> 能夠依照 “chunk” 名稱命名打包後的檔案名稱，提供更大的彈性，這邊要注意是，<strong>使用多文件入口時，千萬不能把 filename 寫死，會發生打包後名稱相同問題，導致編譯失敗</strong>。讓我們來看其他 <code>[name]</code> 的範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/about.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面為單個 entry 並搭配 <code>[name]</code> 的範例，我們並沒有使用物件方式配置 “chunk”，此時打包過後的檔案名稱是什麼呢？答案為 <code>main.js</code>，<strong>其實使用字串方式宣告 entry 單入口文件路徑，等同於下面的寫法</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/about.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>除了 <code>[name]</code> 用法以外，Webpack 還提供了很多類似用法，詳細可看 <a href="https://webpack.js.org/configuration/output/#outputfilename" target="_blank" rel="external nofollow noopener noreferrer">這邊</a>，以上就是 Webpack 多個入口起點該如何配置的簡單介紹。</p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>w3HexSchool</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 前端打包工具 - 使用 css-loader 與 style-loader 處理樣式表</title>
    <url>/2020-02-26-webpack-cssloader-styleloader/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上次在介紹 Webpack 時有稍微提到 Loader 究竟是做什麼用，簡單來講，Webpack 本身只能處理 JavaScript 模組，如果要處理其他類型的文件，就需要使用相關的 Loader 進行轉換。Loader 可以理解為模組和資源的轉換器，它本身是一個 function，接受源文件作為參數傳遞，最後返回轉換後的結果。這次讓我們從最基本的打包 CSS 開始講解，利用 css-loader 抽取源文件相關的 CSS 檔進行轉換，並利用 css-loader 的好搭檔 style-loader 將轉換後的 CSS 附加到 style 標籤已進行存取。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>css-loader 與 style-loader 安裝</li>
<li>css-loader 與 style-loader 基本使用</li>
<li>css-loader 與 style-loader 可傳遞選項</li>
<li>補充：loader 屬性的簡寫方式</li>
<li>補充：獨立 CSS 與 非獨立 CSS 差別</li>
</ul>
<h2 id="css-loader-與-style-loader-安裝"><a href="#css-loader-與-style-loader-安裝" class="headerlink" title="css-loader 與 style-loader 安裝"></a>css-loader 與 style-loader 安裝</h2><blockquote>
<p>套件連結：<a href="https://github.com/webpack-contrib/css-loader" target="_blank" rel="external nofollow noopener noreferrer">css-loader</a>、<a href="https://github.com/webpack-contrib/style-loader" target="_blank" rel="external nofollow noopener noreferrer">style-loader</a></p>
</blockquote>
<p>主要的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install css-loader style-loader -D</span><br></pre></td></tr></table></figure>

<p>package.json：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^3.4.2"</span>,</span><br><span class="line">    <span class="attr">"style-loader"</span>: <span class="string">"^1.1.3"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.42.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這邊要注意的是 css-loader 只是單純將 entry 內相關的 CSS 檔案抽取出來做轉換，最後必須透過 style-loader 將 CSS 注入到 HTML 的 <code>&lt;style&gt;</code> 標籤上，已進行存取，也就代表使用 style-loader 會以 HTML 標籤的形式完成存取，並不是以單獨的 CSS 檔案做引用完成存取，這邊需要特別注意！之後也會介紹如何透過 pluign 的方式，單獨把 CSS 抽取成獨立的檔案，這次就先從 css-loader 與 style-loader 開始做介紹。</p>
<h2 id="css-loader-與-style-loader-基本使用"><a href="#css-loader-與-style-loader-基本使用" class="headerlink" title="css-loader 與 style-loader 基本使用"></a>css-loader 與 style-loader 基本使用</h2><p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.css      # CSS 主檔案</span><br><span class="line">│   │</span><br><span class="line">│   └─── main.js          # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── index.html           # 引入 bundle.js 測試用檔案</span><br><span class="line">├─── webpack.config.js    # Webpack 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure>

<p>撰寫 CSS 範例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgb</span>(37, 37, 177);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>配置 loader 其實很簡單，先前已經有介紹過 <strong>entry</strong> 與 <strong>output</strong> 選項，這次來介紹另一個也很重要的屬性，也就是 <code>module</code> 屬性，用以配置 loader 的處理方式：</p>
<ul>
<li><strong>module</strong>：配置選項決定如何處理<a href="https://webpack.docschina.org/concepts/modules" target="_blank" rel="external nofollow noopener noreferrer">不同類型的模組</a><ul>
<li><strong>rules</strong>：創建模組時，匹配請求的規則數組<ul>
<li><strong>test</strong>：查找符合 Regex (正規表達式) 副檔名的模組，如符合即使用 use 內指定的 loader</li>
<li><strong>use</strong>：定義需加載的 loader，可接受字串陣列或物件陣列傳遞。加載是由右到左依序作用</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>entry 入口處 (<code>src/main.js</code>) 引入 CSS 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./css/all.css'</span>; <span class="comment">// 使用 ESM 方式引入</span></span><br></pre></td></tr></table></figure>

<p>至 <code>package.json</code> 新增編譯指令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --mode development"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行編譯指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>至 <code>./index.html</code> 引入打包而成的 <code>bundle.js</code> 檔案：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 其他省略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-primary"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入打包生成的 JavaScript --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/bundle.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>查看結果：</p>
<p><img src="https://i.imgur.com/lKbi2wh.png" alt="css-loader 與 style-loader 編譯結果"></p>
<p>觀察上面結果可以得知，我們只是單獨的引入 bundle.js 這一個檔案，並沒有引入任何的 CSS 檔案，卻能夠讀取的相關的 CSS 樣式，這一切都是 style-loader 的功勞，他能夠將 css-loader 解析過後的 CSS 以 <code>&lt;style&gt;&lt;/style&gt;</code> 標籤方式插入到 <code>&lt;head&gt;&lt;/head&gt;</code> 內，此時也就完成了打包的目的。</p>
<h2 id="css-loader-與-style-loader-可傳遞選項"><a href="#css-loader-與-style-loader-可傳遞選項" class="headerlink" title="css-loader 與 style-loader 可傳遞選項"></a>css-loader 與 style-loader 可傳遞選項</h2><p>可參考 <a href="https://github.com/webpack-contrib/css-loader#options" target="_blank" rel="external nofollow noopener noreferrer">css-loader Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li>modules：<code>true</code> | <code>false</code><br>啟用/禁用 CSS 模組及其配置，默認為 <code>false</code></li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              modules: <span class="literal">true</span>, <span class="comment">// 啟用 CSS 模組功能</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>可參考 <a href="https://github.com/webpack-contrib/style-loader#options" target="_blank" rel="external nofollow noopener noreferrer">style-loader Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li><p>injectType：<code>styleTag</code> | <code>singletonStyleTag</code> | <code>lazyStyleTag</code> | <code>lazySingletonStyleTag</code> | <code>linkTag</code><br>設置 CSS 注入 DOM 的方式，默認為 <code>styleTag</code></p>
</li>
<li><p>attributes：<code>Object</code><br>附加在 <code>&lt;style&gt;</code> / <code>&lt;link&gt;</code> 標籤上的屬性及其值，莫認為 <code>{}</code></p>
</li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'style-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              injectType: <span class="string">'singletonStyleTag'</span>, <span class="comment">// 多個 CSS 合併為單一個 style 標籤</span></span><br><span class="line">              attributes: &#123;</span><br><span class="line">                id: <span class="string">'allCSS'</span>, <span class="comment">// 附加 id 屬性並定義其值為 "allCSS"</span></span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="補充：loader-屬性的簡寫方式"><a href="#補充：loader-屬性的簡寫方式" class="headerlink" title="補充：loader 屬性的簡寫方式"></a>補充：loader 屬性的簡寫方式</h2><p>在上面配置 loader 的教學中，我們都是字串陣列的方式取用 loader，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>事實上，上面的寫法就等同於以下寫法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'style-loader'</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通常物件陣列的寫法只會出現在有可傳遞選項時，如下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              modules: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在我們配置 loader 時，通常都是直接複製官方文檔中的範例在進行修改，既不會出錯也較為方便，並沒有說哪一種配置 loader 的寫法較好，完全是看個人的習慣以及喜好。</p>
<h2 id="補充：獨立-CSS-與-非獨立-CSS-差別"><a href="#補充：獨立-CSS-與-非獨立-CSS-差別" class="headerlink" title="補充：獨立 CSS 與 非獨立 CSS 差別"></a>補充：獨立 CSS 與 非獨立 CSS 差別</h2><p>當我們使用 style-loader 時，即代表是使用非獨立 CSS 的方式完成取用，但這有違一般開發的習慣，我們通常都是將 JavaScript、CSS 獨立抽取成單獨的檔案，並且利用 <code>&lt;script&gt;</code>、<code>&lt;link&gt;</code> 來引入檔案，我不能說單獨把 CSS 抽取成獨立檔案絕對是對的，以下是我對兩種方式的看法：</p>
<table>
<thead>
<tr>
<th align="center">獨立 CSS - <code>&lt;link&gt;</code> 引用</th>
<th align="center">沒有獨立 CSS - <code>&lt;style&gt;</code> 撰寫</th>
</tr>
</thead>
<tbody><tr>
<td align="center">減少 style 標籤 (舊版本的 IE 有限制)</td>
<td align="center">減少額外的 HTTP 請求</td>
</tr>
<tr>
<td align="center">獨立 CSS 較為方便修改</td>
<td align="center">減少多餘的 CSS 檔案</td>
</tr>
<tr>
<td align="center">CSS 與 JS 並行加載，將提高載入速度</td>
<td align="center">組件化更加乾淨的專案架構</td>
</tr>
<tr>
<td align="center">瀏覽器緩存機制</td>
<td align="center">無</td>
</tr>
</tbody></table>
<p>針對以上兩種取用方法，Webpack 都有提供各自的套件，比如說 <code>&lt;style&gt;</code> 取用就是使用本文章所介紹的 <a href="https://github.com/webpack-contrib/style-loader" target="_blank" rel="external nofollow noopener noreferrer">style-loader</a>，而 <code>&lt;link&gt;</code> 引用則是使用 <a href="https://github.com/webpack-contrib/mini-css-extract-plugin" target="_blank" rel="external nofollow noopener noreferrer">mini-css-extract-plugin</a>，關於 mini-css-extract-plugin 的使用方式將會在下一篇文章獨立做介紹，歡迎有興趣的人前去觀看。</p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>w3HexSchool</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 前端打包工具 - 使用 mini-css-extract-plugin 把 CSS 抽離出來</title>
    <url>/2020-03-02-webpack-minicssextractplugin/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此篇為接續上一篇再說明如何將 CSS 給單獨抽離的介紹文章。上一次我們利用了 style-loader 將 css-loader 處理過後的 CSS 注入到 HTML 內，將以 style 標籤的形式存在，但這有違一般開發的處理流程，建議還是將 CSS 檔案給獨立出來，既方便修改，也不會造成效能上的疑慮。這一次我們改用 mini-css-extract-plugin 將 CSS 給單獨抽離出來，並說明途中可能會踩到的坑以及該如何解決等辦法。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>mini-css-extract-plugin 安裝</li>
<li>mini-css-extract-plugin 基本使用</li>
<li>mini-css-extract-plugin 可傳遞選項</li>
<li>補充：background-image: url() 以相對路徑參考本地圖片時發生錯誤</li>
<li>補充：更改 CSS 檔案生成路徑</li>
<li>補充：publicPath 修改目標公共路徑</li>
</ul>
<h2 id="mini-css-extract-plugin-安裝"><a href="#mini-css-extract-plugin-安裝" class="headerlink" title="mini-css-extract-plugin 安裝"></a>mini-css-extract-plugin 安裝</h2><blockquote>
<p>套件連結：<a href="https://github.com/webpack-contrib/mini-css-extract-plugin" target="_blank" rel="external nofollow noopener noreferrer">mini-css-extract-plugin</a>、<a href="https://github.com/webpack-contrib/css-loader" target="_blank" rel="external nofollow noopener noreferrer">css-loader</a></p>
</blockquote>
<p>主要的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure>

<p>過程使用的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install css-loader -D</span><br></pre></td></tr></table></figure>

<p>package.json：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^3.4.2"</span>,</span><br><span class="line">    <span class="attr">"mini-css-extract-plugin"</span>: <span class="string">"^0.9.0"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.42.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這邊要注意的是 mini-css-extract-plugin 是屬於 Webpack 的 Plugin，主要為 style-loader 的另一種類型套件，你可以不用下載 style-loader，但主要編譯還是得依靠 css-loader，也就是說 mini-css-extract-plugin 與 css-loader 都必須進行安裝。</p>
<h2 id="mini-css-extract-plugin-基本使用"><a href="#mini-css-extract-plugin-基本使用" class="headerlink" title="mini-css-extract-plugin 基本使用"></a>mini-css-extract-plugin 基本使用</h2><div class="note warning">此次範例會搭配 css-loader 一起使用，相關文章連結：<a href="https://awdr74100.github.io/2020-02-26-webpack-cssloader-styleloader/" target="_blank">css-loader</a></div>

<p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.css      # CSS 主檔案</span><br><span class="line">│   │</span><br><span class="line">│   └─── main.js          # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── index.html           # 引入 bundle.js 與 main.css 測試用檔案</span><br><span class="line">├─── webpack.config.js    # Webpack 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure>

<p>撰寫 CSS 範例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#2525b1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 載入 mini-css-extract-plugin (第一步)</span></span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        <span class="comment">// 新增 loader (第三步)</span></span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 創建實例 (第二步)</span></span><br><span class="line">  plugins: [<span class="keyword">new</span> MiniCssExtractPlugin()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>配置 Plugin 相對於配置 loader 簡單不少，只需要新增 <code>plugins</code> 屬性，並以陣列項目的方式新增對應的 plugin 實例對象即可，如上範例。</p>
<p>entry 入口處 (<code>src/main.js</code>) 引入 CSS 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./css/all.css'</span>; <span class="comment">// 使用 ESM 方式引入</span></span><br></pre></td></tr></table></figure>

<p>至 <code>package.json</code> 新增編譯指令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --mode development"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行編譯指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>至 <code>./index.html</code> 引入打包而成的 <code>bundle.js</code> 與 <code>main.css</code> 檔案：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 其他省略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入打包生成的 CSS --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"dist/main.css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-primary"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入打包生成的 JavaScript --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/bundle.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>查看結果：</p>
<p><img src="https://i.imgur.com/8VdqkNr.png" alt="mini-css-extract-plugin 結果"></p>
<p>是不是一切都正常多了？相比於使用 style-loader 將 CSS 注入到 HTML，我更喜歡使用 mini-css-extract-plugin 將 CSS 給獨立抽取出來，我相信這應該也是大多人開發的習慣，這邊還有一點要注意，CSS 檔案目前是生成在與 bundle.js 同一個階層目錄，我自己是習慣將 CSS 放置在各自的資料夾，這點在後面會在補充說明。</p>
<h2 id="mini-css-extract-plugin-可傳遞選項"><a href="#mini-css-extract-plugin-可傳遞選項" class="headerlink" title="mini-css-extract-plugin 可傳遞選項"></a>mini-css-extract-plugin 可傳遞選項</h2><div class="note danger">關於 publicPath 更為詳細的說明，可參考下面的補充說明</div>

<p>可參考 <a href="https://github.com/webpack-contrib/mini-css-extract-plugin#options" target="_blank" rel="external nofollow noopener noreferrer">mini-css-extract-plugin Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li>publicPath：<code>String</code> | <code>Function</code><br>指定目標文件的公共路徑，默認為 <code>webpackOptions.output</code></li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: MiniCssExtractPlugin.loader,</span><br><span class="line">            options: &#123;</span><br><span class="line">              publicPath: <span class="string">'../'</span>, <span class="comment">// 指定公共路徑</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> MiniCssExtractPlugin()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="補充：background-image-url-以相對路徑參考本地圖片時發生錯誤"><a href="#補充：background-image-url-以相對路徑參考本地圖片時發生錯誤" class="headerlink" title="補充：background-image: url() 以相對路徑參考本地圖片時發生錯誤"></a>補充：background-image: url() 以相對路徑參考本地圖片時發生錯誤</h2><div class="note warning">此章節會使用到 file-loader，由於目前還未曾介紹過此套件，建議讀者可先至相關連結閱讀其文章，再回來吸收本章節內容，效果可能會更好喔！</div>

<p>經過了上面的介紹，相信各位對使用 mini-css-extract-plugin 都有一定程度的了解，細心的朋友可能已經發現其中的問題了，那就是使用 <code>background-image: url()</code> 語法時，Webpack 打包會跳出錯誤，事實上，這個問題並不是歸咎於這一個語法，而是歸咎於使用相對路徑參考本地圖片，這邊要注意，是使用相對路徑參考，而不是使用絕對路徑參考，使用絕對路徑參考本地圖片是不會發生錯誤的，讓我們來探討這個問題該如何解決。</p>
<blockquote>
<p>請先至 <code>src</code> 資料夾新增 <code>img</code> 資料夾並放入隨便一張圖片</p>
</blockquote>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> webpack-demo/</span><br><span class="line"> │</span><br><span class="line"> ├─── src/</span><br><span class="line"> │   │</span><br><span class="line"><span class="addition">+│   └─── img/</span></span><br><span class="line"><span class="addition">+│       │</span></span><br><span class="line"><span class="addition">+│       └─── test.jpg</span></span><br></pre></td></tr></table></figure>

<p>撰寫以<strong>絕對路徑</strong>參考本地圖片的 CSS 範例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bg-img</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'/src/img/test.jpg'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行編譯指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>成功編譯，打包後的 CSS 如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bg-img</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'/src/img/test.jpg'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>從上面範例可以得知，使用絕對路徑方式參考本地圖片是不會發生任何錯誤的，但沒有人會使用這種方式參考圖片，主要原因為圖片並不會自動透過 Webpack 打包到 <code>dist</code> 資料夾，且最後生產環境是以 <code>dist</code> 資料夾為主，根本不存在 <code>src</code> 資料夾，這也就導致引入圖片失敗，故沒有人會使用絕對路徑來撰寫參考圖片，讓我們來看使用相對路徑的範例：</p>
<p>撰寫以<strong>相對路徑</strong>參考本地圖片的 CSS 範例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bg-img</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'../img/test.jpg'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行編譯指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>編譯失敗，出現以下結果：</p>
<p><img src="https://i.imgur.com/NG2cD5C.png" alt="相對路徑參考本地圖片發生錯誤"></p>
<p>簡單來講呢，就是 Webpack 會自動偵測 CSS 檔案內所參考的相對路徑圖片，並且把它轉換成 <code>require</code> 方式引用圖片，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 遇到 --&gt;</span><br><span class="line">background-image: url(&quot;test.jpg&quot;);</span><br><span class="line"></span><br><span class="line">&lt;!-- 解析成 --&gt;</span><br><span class="line">require(&quot;.&#x2F;test.jpg&quot;);</span><br></pre></td></tr></table></figure>

<p>而為什麼會發生錯誤呢？原理如同之前所介紹的 Webpack 基礎知識，Webpack 本身只能處理 JavaScript 檔案，如果需要使用 CSS，就必須引入到 entry 內並配置 css-loader，而圖片檔則是依靠 url-loader 或 file-loader，這兩個 loader 就是專門用來處理圖片等類似檔案的，讓我們以 file-loader 來示範：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install file-loader -D</span><br></pre></td></tr></table></figure>

<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'file-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              name: <span class="string">'[name].[ext]'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> MiniCssExtractPlugin()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>關於 file-loader 的配置可至相關連結進行閱讀，這邊就不多加以說明，讓我們直接進行編譯看看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>成功編譯！此時 <code>src</code> 資料夾內的圖片也通通打包進來了，以下為打包後的 <code>dist</code> 資料夾專案結構：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">webpack-demo/</span><br><span class="line">│</span><br><span class="line">├─── dist/</span><br><span class="line">│   │</span><br><span class="line">│   ├─── bundle.js        # 打包生成的 JavaScrit 檔案</span><br><span class="line">│   ├─── main.css         # 打包生成的 CSS 檔案</span><br><span class="line">│   └─── test.jpg         # 自動抓取並通過 file-loader 的圖片檔</span><br></pre></td></tr></table></figure>

<p>觀察打包生成的 CSS 檔案：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bg-img</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(test.jpg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>從上面結果可以得知，連同參考路徑也幫我們做了修正，這也是會什麼使用相對路徑參考本地圖片時，需要使用 file-loader 的原因，它會透過解析修正你的相對路徑，非常的方便，但這邊千萬要注意，<strong>當你同時修改了 CSS 檔案的生成路徑，也務必要修改 mini-css-extract-plugin 的 publicPath 路徑</strong>，這點在後面會有說明，讓我們先從更改檔案生成路徑開始做介紹。</p>
<h2 id="補充：更改-CSS-檔案生成路徑"><a href="#補充：更改-CSS-檔案生成路徑" class="headerlink" title="補充：更改 CSS 檔案生成路徑"></a>補充：更改 CSS 檔案生成路徑</h2><p>以往我們在開發網頁時，習慣將各個語言放置在屬於自己資料夾，方便辨識之外，也有避免檔案過大等問題，但在初期配置 Webpack 時，你會發現 output 的檔案全部都生成在 <code>dist</code> 目錄階層下，相比於 Gulp ，簡單修改 <code>gulp.dest()</code> 即可更改放置目錄，Webpack 配置方式差不多，但可能有些小陷阱需要特別注意，先讓我們來看之前曾提過的 <code>bundle.js</code> 生成路徑修改範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    <span class="comment">// 把它想像成 gulp.dest(...)</span></span><br><span class="line">    filename: <span class="string">'js/bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>從上面範例可以看出，只需要修改 output 內的 <code>filename</code> 選項，即可將生成路徑做對應的修改，此時打包後的 <code>dist</code> 資料夾結構如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── js&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── bundle.js    # 打包生成的 JavaScrit 檔案</span><br></pre></td></tr></table></figure>

<p>這邊千萬要注意，<strong>修改路徑並不是修改 output 內的 path 選項</strong>，這會導致所有的 loader 或 plugin 都得做相對應的修改，變得非常的麻煩！讓我們來看 mini-css-extract-plugin 該如何與上面範例一樣修改檔案生成路徑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      <span class="comment">// 把它想像成 gulp.dest(...)</span></span><br><span class="line">      filename: <span class="string">'css/[name].[hash:3].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在每一個 plugin 中，都可以傳遞一個物件，而這一個物件可以配置 <code>filename</code>、<code>chunkFilename</code> 等屬性，配置原理如同 output 內的 <code>filename</code> 選項，同時也可以使用 <code>output.filename</code> 的模板字串，詳情可參考 <a href="https://webpack.js.org/configuration/output/#template-strings" target="_blank" rel="external nofollow noopener noreferrer">這裡</a>，此時打包後的 <code>dist</code> 資料夾結構如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── js&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── bundle.js    # 打包生成的 JavaScrit 檔案</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── main.18f.css # 打包生成的 CSS 檔案</span><br></pre></td></tr></table></figure>

<p>事實上，大部分的 loader 或 plugin 都可以藉由修改 <code>filename</code> 更改打包後的生成路徑，唯一要注意的是，像 CSS 這種檔案，我們很常使用 <code>background-image: url(&quot;../..&quot;)</code> 來載入圖片，這時問題就來了，<code>filename</code> 的生成路徑並不會響應樣式表內的相對路徑，打包出來的結果也就變成找不到圖片，這時候就得依靠 publicPath 可傳遞選項修改公共路徑，修正打包後的相對路徑，這樣說起來可能有點複雜，讓我們繼續往下看。</p>
<h2 id="補充：publicPath-修改目標公共路徑"><a href="#補充：publicPath-修改目標公共路徑" class="headerlink" title="補充：publicPath 修改目標公共路徑"></a>補充：publicPath 修改目標公共路徑</h2><p>讓我們結合以上所補充的兩點說明，此時 <code>webpack.config.js</code> 檔案配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/bundle.js'</span>, <span class="comment">// 修改生成路徑</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'file-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              name: <span class="string">'img/[name].[ext]'</span>, <span class="comment">// 修改生成路徑</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/[name].css'</span>, <span class="comment">// 修改生成路徑</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>這邊要注意 file-loader 的可傳遞選項 <code>name</code> 的寫法，這樣子的寫法相較於使用 <code>outputPath</code> 選項，我更推薦使用此種寫法，此時打包後的 <code>dist</code> 資料夾結構如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── js&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── bundle.js    # 打包生成的 JavaScrit 檔案</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── main.css     # 打包生成的 CSS 檔案</span><br><span class="line">│   │</span><br><span class="line">│   └─── img&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── test.jpg     # 自動抓取並通過 file-loader 的圖片檔</span><br></pre></td></tr></table></figure>

<p><strong>打包前</strong>的 CSS 檔案：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bg-img</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'../img/test.jpg'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>打包後</strong>的 CSS 檔案</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bg-img</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(img/test.jpg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>圖片跑不出來！打包後的路徑怎會變成這樣呢？因為我們修改了 CSS 預設的檔案生成路徑，對於 file-loader 來說，CSS 的檔案生成路徑還是以 <code>dist</code> 目錄下為主，這也就導致了圖片找不到的問題，解決方式也很簡單，主要有以下三種：</p>
<ol>
<li>使用 mini-css-extract-plugin 中的 <code>publicPath</code> 更改公共路徑 <strong>(推薦)</strong>：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: MiniCssExtractPlugin.loader,</span><br><span class="line">            options: &#123;</span><br><span class="line">              publicPath: <span class="string">'../'</span>, <span class="comment">// 修改公共路徑</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/[name].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相對於使用其他方法，我自己是偏好這一個方法，你可以把 publicPath 想像成替所有參考圖片路徑增加一個前綴，由於我們更改了 CSS 檔案的生成路徑，也就是多新增了一層目錄放置檔案，相對的，publicPath 也必須往上一層去找檔案，此時打包後的 CSS 結果如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bg-img</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(../img/test.jpg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ol start="2">
<li>使用 Webpack 基本配置中的 <code>output.publicPath</code> 修改公共路徑：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/bundle.js'</span>,</span><br><span class="line">    publicPath: <span class="string">'/'</span>, <span class="comment">// 修改公共路徑</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Webpack 中的 <code>output.publicPath</code> 選項，原理就如同 mini-css-extract-plugin 中的 <code>publicPath</code> 選項，一樣都是替資源中的相對路徑增加一個前綴，但與之不同的是，在 Webpack 中配置 publicPath 選項，會導致全域的修改，沒辦法像 mini-css-extract-plugin 獨立的配置，我自己是不太常用這一個方法，此時打包後的 CSS 結果如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* dist 目錄下 */</span></span><br><span class="line"><span class="selector-class">.bg-img</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(/img/test.jpg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ol start="3">
<li>使用 file-loader 中的 <code>publicPath</code> 修改公共路徑：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'file-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              name: <span class="string">'img/[name].[ext]'</span>,</span><br><span class="line">              publicPath: <span class="string">'../'</span>, <span class="comment">// 修改公共路徑</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>file-loader 的 publicPath 選項，原理如同前面兩個，但它是針對所有通過 file-loader 的檔案進行配置，有時候某些 JavaScript 會引入需通過 file-loader 的檔案，這時候 publicPath 的路徑配置可能會跟 CSS 有些衝突，除非 file-loader 就只是用來處理圖片資源，不然不建議直接將 publicPath 設置在 file-loader， 此時打包後的 CSS 結果如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bg-img</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(../img/test.jpg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上三種方法都可以修正預設的引用路徑，使資源載入正確，到了這邊，問題通通都被解決了，這也是一開始我在學習時所遇到的坑，沒想到解決方式這麼簡單，推薦給大家。</p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>w3HexSchool</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 前端打包工具 - 使用 sass-loader 編譯 Sass/SCSS 預處理器</title>
    <url>/2020-03-04-webpack-sassloader/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以我自己來說，已經很少用純 CSS 來撰寫樣式表了，大多時候都是直接使用 SCSS 作為開發語言，既方便又高效，雖然說得透過編譯器使之編譯成 CSS 檔案才能在瀏覽器運行，但這一切對於現代化開發來講，似乎已經不成問題了。此篇將介紹如何使用 sass-loader 編譯我們的 Sass/SCSS 預處理器，並說明途中可能會遇到的陷阱，以及一般人最為困惑的 Node Sass 與 Dart Sass 使用上的差別。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>sass-loader 安裝</li>
<li>sass-loader 基本使用</li>
<li>sass-loader 可傳遞選項</li>
<li>補充：Dart Sass 與 Node Sass</li>
<li>補充：使用 resolve.alias 參考相對路徑圖片</li>
</ul>
<h2 id="sass-loader-安裝"><a href="#sass-loader-安裝" class="headerlink" title="sass-loader 安裝"></a>sass-loader 安裝</h2><blockquote>
<p>套件連結：<a href="https://github.com/webpack-contrib/sass-loader" target="_blank" rel="external nofollow noopener noreferrer">sass-loader</a>、<a href="https://github.com/sass/node-sass" target="_blank" rel="external nofollow noopener noreferrer">node-sass</a></p>
</blockquote>
<p>主要的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install sass-loader node-sass -D</span><br></pre></td></tr></table></figure>

<p>過程會使用到的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install css-loader mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure>

<p>package.json：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^3.4.2"</span>,</span><br><span class="line">    <span class="attr">"mini-css-extract-plugin"</span>: <span class="string">"^0.9.0"</span>,</span><br><span class="line">    <span class="attr">"node-sass"</span>: <span class="string">"^4.13.1"</span>,</span><br><span class="line">    <span class="attr">"sass-loader"</span>: <span class="string">"^8.0.2"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.42.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>請注意！安裝 sass-loader 並不像 gulp-sass 會將依賴的 node-sass 也一起安裝，也就是說 sass-loader 與 node-sass 都需要進行安裝。以及 sass-loader 只負責編譯 Sass/SCSS 部分，最後還是得依靠 css-loader 與 mini-css-extract-plugin 生成獨立的檔案，通通給他安裝下去就對了！</p>
<h2 id="sass-loader-基本使用"><a href="#sass-loader-基本使用" class="headerlink" title="sass-loader 基本使用"></a>sass-loader 基本使用</h2><div class="note warning">此次範例會搭配 css-loader 與 mini-css-extract-plugin 一起使用，相關文章連結：<a href="https://awdr74100.github.io/2020-02-26-webpack-cssloader-styleloader/" target="_blank">css-loader</a>、<a href="https://awdr74100.github.io/2020-03-02-webpack-minicssextractplugin/" target="_blank">mini-css-extract-plugin</a></div>

<p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── scss&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.scss     # SCSS 主檔案</span><br><span class="line">│   │</span><br><span class="line">│   └─── main.js          # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── index.html           # 引入 bundle.js 與 main.css 測試用檔案</span><br><span class="line">├─── webpack.config.js    # Webpack 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure>

<p>撰寫 SCSS 範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$primary</span>: <span class="number">#2525b1</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.s[ac]ss$/i</span>,</span><br><span class="line">        <span class="comment">// 把 sass-loader 放在首要處理 (第一步)</span></span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> MiniCssExtractPlugin()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其實從上面的範例可以看出，配置 sass-loader 非常的簡單，只需要將其放置在使用 loader 的第一順位即可，後面的步驟就如同之前所介紹的，利用 css-loader 與 mini-css-extract-plugin 把 CSS 給獨立抽取成單獨檔案。</p>
<p>entry 入口處 (<code>src/main.js</code>) 引入 SCSS 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./scss/all.scss'</span>; <span class="comment">// 使用 ESM 方式引入</span></span><br></pre></td></tr></table></figure>

<p>至 <code>package.json</code> 新增編譯指令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --mode development"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行編譯指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>至 <code>./index.html</code> 引入打包而成的 <code>bundle.js</code> 與 <code>main.css</code> 檔案：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 其他省略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入打包生成的 CSS --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"dist/main.css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-primary"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入打包生成的 JavaScript --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/bundle.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>查看結果：</p>
<p><img src="https://i.imgur.com/8VdqkNr.png" alt="sass-loader 結果"></p>
<p>可能有人會覺得配置 sass-loader 挺簡單的，沒錯！就是這麼簡單。基於 Webpack 這種現代化工具來說，要處理這些預處理器真的不難，唯一有點小障礙的部分也就只有之前在 mini-css-extract-plugin 介紹的 <code>background-image: url(&quot;../..&quot;)</code> 使用相對路徑參考本地圖片發生錯誤的問題，有興趣的人可至相關連結進行閱讀，可能會有更深的理解喔！相關連結：<a href="https://awdr74100.github.io/2020-03-02-webpack-minicssextractplugin/">mini-css-extract-plugin</a></p>
<h2 id="sass-loader-可傳遞選項"><a href="#sass-loader-可傳遞選項" class="headerlink" title="sass-loader 可傳遞選項"></a>sass-loader 可傳遞選項</h2><p>可參考 <a href="https://github.com/webpack-contrib/sass-loader#options" target="_blank" rel="external nofollow noopener noreferrer">sass-loader Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li>sassOptions：<code>Object</code> | <code>Function</code><br><a href="https://github.com/sass/node-sass/#options" target="_blank" rel="external nofollow noopener noreferrer">Node Sass</a> 或 <a href="https://github.com/sass/dart-sass#javascript-api" target="_blank" rel="external nofollow noopener noreferrer">Dart Sass</a> 的可傳遞的選項，預設為 <code>none</code></li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.s[ac]ss$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sassOptions: &#123;</span><br><span class="line">                outputStyle: <span class="string">'compressed'</span>, <span class="comment">// Node Sass 的可傳遞選項</span></span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="補充：Dart-Sass-與-Node-Sass"><a href="#補充：Dart-Sass-與-Node-Sass" class="headerlink" title="補充：Dart Sass 與 Node Sass"></a>補充：Dart Sass 與 Node Sass</h2><div class="note warning">Dart Sass 與 Node Sass 都屬於 Sass 的編譯器，Dart Sass 具備編譯輸出為 JavaScript 的能力，目前為 Sass 的主要開發對象，這也代表各種新功能將優先引入；Node Sass 底層使用的是 LibSass，基於 C/C++ 編寫，這使其編譯速度快過 Dart Sass；對於一般開發建議使用 Node Sass，如有新功能的需求，可使用 Dart Sass。</div>

<p>在 sass-loader 中，與之前介紹的 gulp-sass 使用 Dart Sass 有所不同。sass-loader 在默認情況下，是以 <code>package.json</code> 中的依賴關係判定當下所需使用的編譯器，如下範例：</p>
<p>使用 Node Sass 編譯器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install node-sass -D</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"sass-loader"</span>: <span class="string">"^8.0.2"</span>,</span><br><span class="line">    <span class="attr">"node-sass"</span>: <span class="string">"^4.13.1"</span> // 只存在 node-sass</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Dart Sass 編譯器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install sass -D</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"sass-loader"</span>: <span class="string">"^8.0.2"</span>,</span><br><span class="line">    <span class="attr">"sass"</span>: <span class="string">"^1.26.2"</span> // 只存在 sass (dart-sass)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>從上面示例可以看出，<strong>sass-loader 是依造你當前環境唯一的編譯器做使用，不需要進行任何配置</strong>，如果只存在哪個編譯器就直接使用它，可能會有人問，那如果同時存在兩個編譯器呢？這種情況的話，sass-loader 默認會使用 node-sass，這也是當你安裝 sass-loader 且沒有安裝任何編譯器時，如果直接進行編譯的話，會跳出安裝 node-sass 的提示。</p>
<p>sass-loader 也提供了一種 <code>implementation</code> 選項，用來使在同時安裝 node-sass 與 dart-sass 編譯器情況下，強制切換成需要的編譯器，如下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.s[ac]ss$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              implementation: <span class="built_in">require</span>(<span class="string">'sass'</span>), <span class="comment">// 強制使用 dart-sass 編譯器</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="補充：使用-resolve-alias-參考相對路徑圖片"><a href="#補充：使用-resolve-alias-參考相對路徑圖片" class="headerlink" title="補充：使用 resolve.alias 參考相對路徑圖片"></a>補充：使用 resolve.alias 參考相對路徑圖片</h2><div class="note warning">此章節會使用到 file-loader，由於目前還未曾介紹過此套件，建議讀者可先至相關連結閱讀其文章，再回來吸收本章節內容，效果可能會更好喔！</div>

<p>之前完整介紹了有關 mini-css-extract-plugin 使用 publicPath 解決 <code>background-image: url()</code> 以相對路徑參考本地圖片時所發生的問題，連結在 <a href="https://awdr74100.github.io/2020-03-02-webpack-minicssextractplugin/">這裡</a>，這一次我們在做一點更細微的補充，先讓我們來看目前的 SCSS 資料夾結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── scss&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── base</span><br><span class="line">│           │</span><br><span class="line">│           └─── _reset.scss</span><br><span class="line">│       │</span><br><span class="line">│       └─── helpers</span><br><span class="line">│           │</span><br><span class="line">│           └─── _variables.scss</span><br><span class="line">│       │</span><br><span class="line">│       └─── component</span><br><span class="line">│           │</span><br><span class="line">│           └─── _navbar.scss</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.scss     # SCSS 主檔案</span><br></pre></td></tr></table></figure>

<p>在我們使用 Sass/SCSS 撰寫樣式表時，很常以上面這種結構來區分使用的對象，假設我們目前在撰寫 <code>navbar</code> 元件，且需要以 <code>background-image: url()</code> 來增加 logo 圖片，我們可能會這樣寫：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path：src/scss/component/_navbar.scss</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.logo</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">'../../img/test.png'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>載入所有 SCSS 模組：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path：src/scss/all.scss</span></span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./component/navbar'</span>;</span><br><span class="line"><span class="comment">// 其他省略</span></span><br></pre></td></tr></table></figure>

<p>這時如果直接編譯，會跳出以下錯誤：</p>
<p><img src="https://i.imgur.com/xh9tus1.png" alt="sass-loader 圖片找不到"></p>
<p>你可能會好奇，怎麼會跳出錯誤？且錯誤提示還是指出圖片的路徑錯誤，導致找不到圖片，其實原理很簡單，<strong>在我們撰寫 SCSS 的模組時，所有的相對路徑都應該是基於 <code>all.scss</code> 檔案才對，也就是載入所有模組的主檔案</strong>，如果以上面範例來說明，正確的路徑寫法應該如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path：src/scss/component/_navbar.scss</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.logo</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">'../img/test.png'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時編譯結果就會是成功的了，但這樣子的寫法非常不直覺，且通常我們會一不小心就跟著編輯器的指示一路給他按下去，比如 VSCode 中的 Path Intellisense 套件，最後就會導致錯誤，因為大部分的提示都是基於當前所編輯的檔案所給出的相對路徑提示，並不能指定提示的基準為哪一個檔案，造成種種的麻煩，這時該怎麼辦呢？</p>
<p>之前有說過，Webpack 最大的魅力就在於它會自動解析模組間的相互依賴關係，我們可以利用這一個專長來操作我們的圖片存取路徑。</p>
<p>配置 <code>webpack.config.js</code> 檔案中的 <code>resolve.alias</code> 選項：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'@img'</span>: path.resolve(__dirname, <span class="string">'src/img'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用 <code>alias</code> 指定圖片存取路徑：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path：src/scss/component/_navbar.scss</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.logo</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">'~@img/test.png'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這邊要注意在 sass-loader 處理的檔案中，必須增加 <code>~</code> 前綴以告知此不是相對路徑內容，而是需要 Webpack 去解析的模塊，在 <a href="https://github.com/webpack-contrib/sass-loader#resolving-import-at-rules" target="_blank" rel="external nofollow noopener noreferrer">官方文件</a> 也有說明，此時讓我們直接編譯看看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>編譯結果：</p>
<p><img src="https://i.imgur.com/wXVbem1.png" alt="sass-loader 使用 resolve.alias"></p>
<p>編譯成功！且圖片存取路徑也正確，從上面範例可以看出，使用 <code>resolve.alias</code> 設置別名，不僅可以提高辨識度，且更為方便使用，當然這一個 <code>resolve.alias</code> 選項不只可以用來設置在 SCSS 環境，JavaScript 環境也可以，且不需要使用 <code>~</code> 前綴，直接定義即可，以下為 ESM 載入模組的範例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'@src'</span>: path.resolve(__dirname, <span class="string">'src'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>entry 入口處 (<code>src/main.js</code>) 引入 SCSS 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'@src/scss/all.scss'</span>;</span><br></pre></td></tr></table></figure>

<p>這邊要注意，<code>resolve.alias</code> 的 <code>key</code> 值是可以隨意命名的喔！並不是一定要依造上面這樣的寫法，完全依靠個人習慣以及喜好。</p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>SCSS</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 前端打包工具 - 使用 postcss-loader 自動為 CSS 增加 Prefix</title>
    <url>/2020-03-05-webpack-postcssloader/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>PostCSS 是一套使用 JavaScript 轉換 CSS 的工具，有別於以往 Sass、Less 等預處理器將檔案編譯成 CSS，PostCSS 是針對 CSS 後續所作行為處理的後處理器，在某些情境也有可能為前處理器，透過載入並使用 Plugin 的方式來完成目的，常見的使用情境為 CSS Prefix、CSS Conpress 等等。此篇將介紹如何使用 postcss-loader 擴展我們的 CSS 語言特性，主要會以 Autoprefixer 這個 PostCSS Plugin 做示範，自動為編譯完成的 CSS 增加 Prefix，免除手動添加的麻煩。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>postcss-loader 安裝</li>
<li>postcss-loader 基本使用</li>
<li>postcss-loader 可傳遞選項</li>
<li>補充：Autoprefixer 與 Browserslist</li>
<li>補充：使用 postcss.config.js 配置 PostCSS</li>
</ul>
<h2 id="postcss-loader-安裝"><a href="#postcss-loader-安裝" class="headerlink" title="postcss-loader 安裝"></a>postcss-loader 安裝</h2><blockquote>
<p>套件連結：<a href="https://github.com/postcss/postcss-loader" target="_blank" rel="external nofollow noopener noreferrer">postcss-loader</a>、<a href="https://github.com/postcss/autoprefixer" target="_blank" rel="external nofollow noopener noreferrer">autoprefixer</a></p>
</blockquote>
<p>主要的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install postcss-loader autoprefixer -D</span><br></pre></td></tr></table></figure>

<p>過程會使用到的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install css-loader mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure>

<p>package.json：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"autoprefixer"</span>: <span class="string">"^9.7.5"</span>,</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^3.4.2"</span>,</span><br><span class="line">    <span class="attr">"mini-css-extract-plugin"</span>: <span class="string">"^0.9.0"</span>,</span><br><span class="line">    <span class="attr">"postcss-loader"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.42.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Webpack 通過 postcss-loader 來調用 PostCSS，直接安裝即可，以及下面將會以 autoprefixer 結合 PostCSS 作範例，同樣也必須安裝，最後包含基本的 css-loader 以及 mini-css-extract-plugin 也給它安裝下去就對了。</p>
<h2 id="postcss-loader-基本使用"><a href="#postcss-loader-基本使用" class="headerlink" title="postcss-loader 基本使用"></a>postcss-loader 基本使用</h2><div class="note warning">此次範例會搭配 css-loader 與 mini-css-extract-plugin 一起使用，相關文章連結：<a href="https://awdr74100.github.io/2020-02-26-webpack-cssloader-styleloader/" target="_blank">css-loader</a>、<a href="https://awdr74100.github.io/2020-03-02-webpack-minicssextractplugin/" target="_blank">mini-css-extract-plugin</a></div>

<p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.css      # CSS 主檔案</span><br><span class="line">│   │</span><br><span class="line">│   └─── main.js          # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── index.html           # 引入 bundle.js 與 main.css 測試用檔案</span><br><span class="line">├─── webpack.config.js    # Webpack 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure>

<p>撰寫 CSS 範例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.d-flex</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.justify-content-center</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bg-filter</span> &#123;</span><br><span class="line">  <span class="attribute">filter</span>: <span class="built_in">blur</span>(5px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">          <span class="comment">// 把 postcss-loader 放在 css-loader 前面 (第一步)</span></span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">// 傳遞 plugins 選項並載入 autoprefixer 做使用 (第二步)</span></span><br><span class="line">              plugins: [<span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)],</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> MiniCssExtractPlugin()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通常在配置 PostCSS 時，我們都是習慣把 options 的內容撰寫在獨立的 <code>postcss.config.js</code> 檔案內，如果 PostCSS 的配置較為複雜，相比於撰寫在 <code>webpack.config.js</code> 內，使用 <code>postcss.config.js</code> 更能提高其辨識度，這點在下面會再補充，讓我們先暫時以此方式進行配置。</p>
<p>entry 入口處 (<code>src/main.js</code>) 引入 CSS 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./css/all.css'</span>; <span class="comment">// 使用 ESM 方式引入</span></span><br></pre></td></tr></table></figure>

<p>至 <code>package.json</code> 新增編譯指令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --mode development"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行編譯指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>以下為經過 autoprefixer 處理後的 <code>dist/main.css</code> 檔案內容：</p>
<!-- prettier-ignore-start -->
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.d-flex</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.justify-content-center</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bg-filter</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-filter</span>: <span class="built_in">blur</span>(5px);</span><br><span class="line">          <span class="attribute">filter</span>: <span class="built_in">blur</span>(5px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>你會發現 autoprefixer 替我們增加了相關的 CSS Prefix，但僅限於目前支援度較低的語法，比如說 <code>filter</code> 語法，這個問題可以透過配置 <code>.browserslistrc</code> 來解決，下面會再補充說明，到了這邊。有沒有覺得 PostCSS 很神奇？我認為 PostCSS 更像是一個平台，利用豐富的插件進行前或後處理，有沒有發現我說的是前或後處理？事實上，某些 PostCSS 插件是以預處理的方式進行，比如說：<a href="https://www.npmjs.com/package/postcss-each" target="_blank" rel="external nofollow noopener noreferrer">postcss-each</a>，所以我們並不能直接把 PostCSS 定義為後處理器，得看使用的性質而定。</p>
<h2 id="postcss-loader-可傳遞選項"><a href="#postcss-loader-可傳遞選項" class="headerlink" title="postcss-loader 可傳遞選項"></a>postcss-loader 可傳遞選項</h2><p>可參考 <a href="https://github.com/postcss/postcss-loader#options" target="_blank" rel="external nofollow noopener noreferrer">postcss-loader Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li>plugins：<code>Array</code> | <code>Function</code><br>需要使用的插件，默認為 <code>none</code></li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              plugins: [<span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123; <span class="attr">cascade</span>: <span class="literal">false</span> &#125;)],</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="補充：Autoprefixer-與-Browserslist"><a href="#補充：Autoprefixer-與-Browserslist" class="headerlink" title="補充：Autoprefixer 與 Browserslist"></a>補充：Autoprefixer 與 Browserslist</h2><p>Browserslist 是一款用於不同前端工具之間共享目標瀏覽器和 Node.js 版本的工具，在之前如果要配置 Babel、ESLint、Autoprefixer 等相關工具，需要再各自的配置文件依序設定，造成許多的麻煩，Browserslist 就是為了解決這一個麻煩而建構，只需配置 <code>.browserslistrc</code> 文件，上面所提到的工具即可共享專案配置，這次我們就來介紹如何使用 Browserslist 配置 Autoprefixer 吧！</p>
<p>Browserslist 為 Autoprefixer 的相依套件，可自行檢查是否已完成安裝，如需下載，可使用以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install browserslist</span><br></pre></td></tr></table></figure>

<p>Browserslist 可以在 <code>package.json</code> 中設定，也可以用單獨檔案 <code>.browserslistrc</code> 設定。</p>
<blockquote>
<p>參考 <a href="https://github.com/browserslist/browserslist#full-list" target="_blank" rel="external nofollow noopener noreferrer">Full List</a> 進行配置：</p>
</blockquote>
<p>使用 <code>package.json</code> 配置:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"browserslist"</span>: [<span class="string">"last 2 version"</span>, <span class="string">"&gt; 1%"</span>, <span class="string">"IE 10"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增並使用 <code>.browserslistrc</code> 單獨檔案配置：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> webpack-demo/</span><br><span class="line"> │</span><br><span class="line"><span class="addition">+└─── .browserslistrc</span></span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">last 2 version</span><br><span class="line">&gt; 1%</span><br><span class="line">IE 10</span><br></pre></td></tr></table></figure>

<p>再次執行 <code>npm rum build</code> 指令進行編譯，此時 <code>dist/main.css</code> 結果如下：</p>
<!-- prettier-ignore-start -->
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.d-flex</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">display</span>: -ms-flexbox;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.justify-content-center</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-box-pack</span>: center;</span><br><span class="line">      <span class="attribute">-ms-flex-pack</span>: center;</span><br><span class="line">          <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bg-filter</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-filter</span>: <span class="built_in">blur</span>(5px);</span><br><span class="line">          <span class="attribute">filter</span>: <span class="built_in">blur</span>(5px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>觀察編譯後檔案可以發現 Autoprefixer 針對了我們的 <code>.browserslistrc</code> 配置進行編譯，大功告成！</p>
<h2 id="補充：使用-postcss-config-js-配置-PostCSS"><a href="#補充：使用-postcss-config-js-配置-PostCSS" class="headerlink" title="補充：使用 postcss.config.js 配置 PostCSS"></a>補充：使用 postcss.config.js 配置 PostCSS</h2><p>在前面我們是使用傳統 options 的方式配置 PostCSS，但其實還有另外一種配置方式可以使用，這邊要注意，並不是每一個 loader 都可以使用這種方式，主要得依靠官方是否支援專屬配置檔的設定，以下示範如何以專屬配置檔的方式配置 PostCSS：</p>
<p>在 <code>./</code> 根目錄新增名為 <code>postcss.config.js</code> 的檔案：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> webpack-demo/</span><br><span class="line"> │</span><br><span class="line"><span class="addition">+└─── postcss.config.js</span></span><br></pre></td></tr></table></figure>

<p>配置 <code>postcss.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [<span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的配置結果如同之前使用 options 的方式配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">            <span class="comment">// 如同這邊的配置</span></span><br><span class="line">            options: &#123;</span><br><span class="line">              plugins: [<span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)],</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此時的編譯結果會是一模一樣的，我自己是比較習慣單獨以 <code>postcss.config.js</code> 進行配置，往後如果要修改 PostCSS 的配置，直接到專屬檔案配置即可，比較不會造成眼花撩亂的問題。</p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>SCSS</tag>
        <tag>PostCSS</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 前端打包工具 - 使用 url-loader 與 file-loader 處理靜態資源</title>
    <url>/2020-03-09-webpack-urlloader-fileloader/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一次在介紹 mini-css-extract-plugin 時，有提到關於使用 background-image:url() 以相對路徑參考本地圖片時所發生的錯誤，最後是使用 file-loader 解決此問題；簡單來說，file-loader 就是用來處理一般開發網頁時所使用的靜態資源，例如：字形、圖片等等，將所有資源載入到 Webpack 內，並且解析資源的相互依賴，最後以配置的選項生成對應的結果；而 url-loader 則類似於 file-loader，可依資源的大小做對應的處理。此篇將介紹 file-loader 與 url-loader 的使用方法，以及兩者在應用時最大的差別為何。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>url-loader 與 file-loader 安裝</li>
<li>url-loader 與 file-loader 基本使用</li>
<li>url-loader 與 file-loader 可傳遞選項</li>
<li>補充：url-loader 與 file-loader 實際應用</li>
<li>補充：file-loader 載入本地字體</li>
</ul>
<h2 id="url-loader-與-file-loader-安裝"><a href="#url-loader-與-file-loader-安裝" class="headerlink" title="url-loader 與 file-loader 安裝"></a>url-loader 與 file-loader 安裝</h2><blockquote>
<p>套件連結：<a href="https://github.com/webpack-contrib/url-loader" target="_blank" rel="external nofollow noopener noreferrer">url-loader</a>、<a href="https://github.com/webpack-contrib/file-loader" target="_blank" rel="external nofollow noopener noreferrer">file-loader</a></p>
</blockquote>
<p>主要的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install url-loader file-loader -D</span><br></pre></td></tr></table></figure>

<p>package.json：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"file-loader"</span>: <span class="string">"^6.0.0"</span>,</span><br><span class="line">    <span class="attr">"url-loader"</span>: <span class="string">"^4.0.0"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.42.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面章節，我們會先以 file-loader 做示範，直到關於 <code>base64</code> 一詞的出現，才會使用到 url-loader，請先將兩個 loader 進行安裝。</p>
<h2 id="file-loader-與-url-loader-基本使用"><a href="#file-loader-與-url-loader-基本使用" class="headerlink" title="file-loader 與 url-loader 基本使用"></a>file-loader 與 url-loader 基本使用</h2><p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── img&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── test.png     # 測試用圖片</span><br><span class="line">│   │</span><br><span class="line">│   └─── main.js          # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── webpack.config.js    # Webpack 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure>

<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="comment">// 配置 loader (第一步)</span></span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'file-loader'</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>配置 file-loader 相對簡單，這邊要注意的是，目前我們的 Regex 只有單純篩選圖片的相關檔案，並未包含其他靜態資源。</p>
<p>entry 入口處 (<code>src/main.js</code>) 引入圖片檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./img/test.png'</span>;</span><br></pre></td></tr></table></figure>

<p>執行編譯指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>此時會生成名稱為 hash 值的圖片檔案：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> webpack-demo/</span><br><span class="line"> │</span><br><span class="line"> ├─── dist/</span><br><span class="line"> │   │</span><br><span class="line"><span class="addition">+│   ├─── 4664caca877b29c20cf1cc536e41911e.png</span></span><br><span class="line"> │   └─── bundle.js</span><br></pre></td></tr></table></figure>

<p>相信有閱讀過以前 Webpack 文章的朋友已經發現其中的問題，那就是我們還沒有配置 <code>filename</code>，導致預設名稱為 hash 值，這邊要注意，file-loader 並沒有 <code>filename</code> 這個屬性，取而代之的是 <code>name</code> 屬性，讓我們趕緊來配置它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="comment">// 配置 loader (第一步)</span></span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'file-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">// 配置 name 屬性 (第二步)</span></span><br><span class="line">              name: <span class="string">'[name].[ext]'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 file-loader 中的 <code>name</code> 屬性就類似於其他 loader 或 plugin 的 <code>filename</code> 屬性，不同的地方在於，<code>name</code> 屬性得依照官方文件中的 <a href="https://github.com/webpack-contrib/file-loader#placeholders" target="_blank" rel="external nofollow noopener noreferrer">Placeholders</a> 配置才行，上面這個配置就是最基本的依照 entry 檔案的名稱以及附檔名進行 output。</p>
<div class="note danger">切記先將 dist 資料夾完全刪除，以保證最新的編譯結果如同預期，之後也會介紹使用 clean-webpack-plugin 解決此問題</div>

<p>再次執行編譯指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>此時會生成與 entry 檔案名稱相同的圖片檔案：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> webpack-demo/</span><br><span class="line"> │</span><br><span class="line"> ├─── dist/</span><br><span class="line"> │   │</span><br><span class="line"><span class="addition">+│   ├─── test.png</span></span><br><span class="line"> │   └─── bundle.js</span><br></pre></td></tr></table></figure>

<p>以上就是 file-loader 的基本使用，可能有人會問，那 url-loader 呢？神奇的事情要發生了！讓我們直接將上面的 <code>webpack.config.js</code> 中的 file-loader 更改為 url-loader，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>, <span class="comment">// 將 file-loader 更改為 url-loader</span></span><br><span class="line">            options: &#123;</span><br><span class="line">              name: <span class="string">'[name].[ext]'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此時如果你執行 <code>npm run build</code> 進行編譯，結果會與 file-loader 一模一樣，有沒有很神奇？事實上，url-loader 預設提供了一個名為 <code>fallback</code> 的選項，用以調用超過文件大小的程序，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">// 超過大小時調用 file-loader 處理該檔案</span></span><br><span class="line">              fallback: <span class="built_in">require</span>.resolve(<span class="string">'file-loader'</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而 <strong>url-loader 中的 options 選項是與 file-loader 共用的</strong>，差別在於 url-loader 新增了 <code>limit</code> 選項，用以設置可轉為 base64 的文件大小上限，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              name: <span class="string">'[name].[ext]'</span>,</span><br><span class="line">              limit: <span class="number">8192</span>, <span class="comment">// 用以限制須轉為 base64 的文件大小 (單位：byte)</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>url-loader 唯一的功能就在於將資源轉換為 <code>base64</code> 的格式，主要依靠 <code>limit</code> 控制需轉換的文件，轉為 <code>base64</code> 的好處就在於，往後網頁在渲染圖片時，不需要以 request 的方式加載圖片，直接向 JavaScript 檔案拿取即可，這樣子以效能來說，會提高許多，但你也不能把大小的上限設定太高，由於 <code>base64</code> 是存在於 bundle.js 內，這樣子的做法會導致 JavaScript 異常的肥大，對於效能來說反而會下降，衡量並設置適當的大小才是正確的作法。</p>
<p>再次執行編譯指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>通過 url-loader 的文件將轉成 <code>base64</code> 存在於 bundle.js 內：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── bundle.js    # 圖片轉為 base64 存在於 JavaScript 檔案內</span><br></pre></td></tr></table></figure>

<p>關於 <code>base64</code> 的實際應用將在下面補充，讓我們來做個總結：</p>
<div class="note warning">file-loader 用以將靜態資源載入到 Webpack 內，並且解析資源的相互依賴關係，最後 output 到指定的位置，而 url-loader 用以將指定大小上限內的圖片資源轉換為 base64 格式，如遇到超過上限的資源，將 fallback 給 file-loader 做處理，兩者功能並沒有衝突，由於處理對象相同，導致很多人會搞混，通常兩個 loader 都是一起使用居多，並且直接設置 url-loader 即可</div>

<h2 id="url-loader-與-file-loader-可傳遞選項"><a href="#url-loader-與-file-loader-可傳遞選項" class="headerlink" title="url-loader 與 file-loader 可傳遞選項"></a>url-loader 與 file-loader 可傳遞選項</h2><div class="note warning">可與 file-loader 選項共用</div>

<p>可參考 <a href="https://github.com/webpack-contrib/url-loader#options" target="_blank" rel="external nofollow noopener noreferrer">url-loader Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li><p>limit：<code>Number</code> | <code>Boolean</code> | <code>String</code><br>限制可轉為 base64 的檔案大小上限，單位為 byte，默認為 <code>underfined</code></p>
</li>
<li><p>fallback：<code>String</code><br>指定當文件大小超過 limit 限制時，需轉向的加載程序，默認為 <code>fiel-loader</code></p>
</li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">// 用以限制須轉為 base64 的文件大小 (單位：byte)</span></span><br><span class="line">              limit: <span class="number">8192</span>,</span><br><span class="line">              <span class="comment">// 超過大小及調用 file-loader</span></span><br><span class="line">              fallback: <span class="built_in">require</span>.resolve(<span class="string">'file-loader'</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>可參考 <a href="https://github.com/webpack-contrib/file-loader#options" target="_blank" rel="external nofollow noopener noreferrer">file-loader Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li><p>name：<code>String</code> | <code>Function</code><br>設置 output 時的文件名稱，相關參數可參考 <a href="https://github.com/webpack-contrib/file-loader#placeholders" target="_blank" rel="external nofollow noopener noreferrer">Placeholders</a>，默認為 <code>[contenthash].[ext]</code></p>
</li>
<li><p>outputPath：<code>String</code> | <code>Function</code><br>指定目標文件的公共路徑，在 <a href="https://awdr74100.github.io/2020-03-02-webpack-minicssextractplugin/#補充：publicPath-修改目標公共路徑">mini-css-extract-plugin</a> 文章有介紹到，默認為 <code>underfined</code></p>
</li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'file-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">// 設置 output 時的檔案名稱</span></span><br><span class="line">              name: <span class="string">'img/[name].[ext]'</span>,</span><br><span class="line">              <span class="comment">// 修改公共路徑</span></span><br><span class="line">              publicPath: <span class="string">'../'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="補充：url-loader-與-file-loader-實際應用"><a href="#補充：url-loader-與-file-loader-實際應用" class="headerlink" title="補充：url-loader 與 file-loader 實際應用"></a>補充：url-loader 與 file-loader 實際應用</h2><p>前面講解到了 url-loader 與 file-loader 的基本使用方式，這次讓我們帶入到實際應用內，加深各位對這兩個 loader 的印象。</p>
<blockquote>
<p>套件連結：<a href="https://github.com/webpack-contrib/url-loader" target="_blank" rel="external nofollow noopener noreferrer">url-loader</a>、<a href="https://github.com/webpack-contrib/file-loader" target="_blank" rel="external nofollow noopener noreferrer">file-loader</a>、<a href="https://github.com/webpack-contrib/css-loader" target="_blank" rel="external nofollow noopener noreferrer">css-loader</a>、<a href="https://github.com/webpack-contrib/mini-css-extract-plugin" target="_blank" rel="external nofollow noopener noreferrer">mini-css-extract-plugin</a></p>
</blockquote>
<p>主要的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install url-loader file-loader -D</span><br></pre></td></tr></table></figure>

<p>過程會使用的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install css-loader mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure>

<p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── img&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       ├─── banner.jpg   # Size &gt;&#x3D; 10 KB</span><br><span class="line">│       └─── logo.jpg     # Size &lt; 10 KB</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.css      # CSS 主檔案</span><br><span class="line">│   │</span><br><span class="line">│   └─── main.js          # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── index.html           # 引入 bundle.js 與 main.css 測試用檔案</span><br><span class="line">├─── webpack.config.js    # Webpack 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure>

<p>撰寫 CSS 範例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.w-100-h-100</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bg-cover</span> &#123;</span><br><span class="line">  <span class="attribute">background-position</span>: center center;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.banner</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'../img/banner.jpg'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.logo</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'../img/logo.png'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: MiniCssExtractPlugin.loader,</span><br><span class="line">            <span class="comment">// 由於 CSS 增加了一層的結構，相對的 publicPath 也需增加一層</span></span><br><span class="line">            options: &#123;</span><br><span class="line">              publicPath: <span class="string">'../'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 直接配置 url-loader 就好，超過上限的資源會自動 fallback 給 file-loader</span></span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              name: <span class="string">'img/[name].[ext]'</span>,</span><br><span class="line">              limit: <span class="number">10000</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/[name].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>這邊要特別注意！並不是 file-loader 與 url-loader 都要進行配置，直接配置 url-loader 就等同於配置了 file-loader，<code>limit</code> 內的會交由 url-loader 處理，超過 <code>limit</code> 的資源則會 fallback 給 file-loader 進行處理。</p>
<div class="note danger">Webpack 會自動解析 CSS 內的參考圖檔，將它抓出來以 require 的方式處理，除非有特定資源需要透過 file-loader 處理，不然不需要另外的 import 這些 CSS 所用的圖檔</div>

<p>entry 入口處 (<code>src/main.js</code>) 引入 CSS 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./css/all.css'</span>;</span><br></pre></td></tr></table></figure>

<p>至 <code>package.json</code> 新增編譯指令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --mode development"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行編譯指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>至 <code>./index.html</code> 引入打包而成的 <code>bundle.js</code> 與 <code>main.css</code> 檔案：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 其他省略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入打包生成的 CSS --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"dist/css/main.css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"banner w-100-h-100 bg-cover"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"logo w-100-h-100 bg-cover"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入打包生成的 JavaScript --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/js/bundle.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>查看結果：</p>
<p><img src="https://i.imgur.com/MOMIu8C.png" alt="file-loader 結果"></p>
<p><img src="https://i.imgur.com/MoyAU11.png" alt="url-loader 結果"></p>
<p>從上面結果可以得知，logo.png 圖檔已被轉換成 base64 格式，而 banner.png 這張較大的圖檔，被 url-loader fallback 給 file-loader 處理，最後就只是在配置的指定位置生成而已。</p>
<h2 id="補充：file-loader-載入本地字體"><a href="#補充：file-loader-載入本地字體" class="headerlink" title="補充：file-loader 載入本地字體"></a>補充：file-loader 載入本地字體</h2><p>有時我們在開發網頁時，會需要使用一些特殊字體，像我本身就很常到 <a href="https://fonts.google.com/" target="_blank" rel="external nofollow noopener noreferrer">Google Fonts</a> 拉一些字體出來用，不僅可以增加網頁整體的質感，還可以擺脫傳統字體的呆板樣式。</p>
<p>而外部字體的載入方式有很多種，包含一般最為常見的 CSS link，或是使用 <code>@import</code> 方式載入字體，我個人是偏好使用 <code>@font-face</code> 來載入字體，將字體給下載下來，提供較為穩定的載入字體方法。</p>
<p>先前介紹了以 file-loader 或 url-loader 來處理圖片等靜態資源，此章節將介紹如何以 file-loader 處理 <code>.ttf</code>、<code>.otf</code> 等字體資源，讓我們直接開始吧！</p>
<blockquote>
<p>請先至 <a href="https://fonts.google.com/" target="_blank" rel="external nofollow noopener noreferrer">Google Fonts</a> 隨意下載字體，並放置在 <code>src/font</code> 內</p>
</blockquote>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> webpack-demo/</span><br><span class="line"> │</span><br><span class="line"> ├─── src/</span><br><span class="line"> │   │</span><br><span class="line"><span class="addition">+│   └─── font/</span></span><br><span class="line"><span class="addition">+│       │</span></span><br><span class="line"><span class="addition">+│       └─── NotoSansTC-Regular.otf</span></span><br></pre></td></tr></table></figure>

<p>以 <code>@font-face</code> 載入本地字體：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">'NotoSansTC'</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'../font/NotoSansTC-Regular.otf'</span>) <span class="built_in">format</span>(<span class="string">'opentype'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">'NotoSansTC'</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: MiniCssExtractPlugin.loader,</span><br><span class="line">            options: &#123;</span><br><span class="line">              publicPath: <span class="string">'../'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 處理 require("font")</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff|woff2|eot|ttf|otf|)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'file-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              name: <span class="string">'font/[name].[ext]'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 處理 require("image")</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              name: <span class="string">'img/[name].[ext]'</span>,</span><br><span class="line">              limit: <span class="number">10000</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/[name].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>這邊要注意，如果你打算將圖片、文字打包後放置在同一個路徑下，可以不必另外寫一個 Regex 去處理，<strong>上面這種寫法，主要是將圖片與文字放置在不同的資料夾</strong>，千萬要記得，Webpack 會將 CSS 內的相關路徑參考語法轉換為 <code>require</code> 的方式進行處理，並不是說 file-loader 的配置只能在 url-loader 區塊內配置，Webpack 是以 Regex 配對相關的 use，千萬不要搞混了！</p>
<p>執行編譯：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>此時 <code>src</code> 資料夾內的 <code>font</code> 也通通打包進來了，以下為打包後的 <code>dist</code> 資料夾專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── font&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── NotoSansTC-Regular.otf</span><br><span class="line">&#x2F;&#x2F; 其他省略</span><br></pre></td></tr></table></figure>

<p>觀察打包生成的 CSS 檔案：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">'NotoSansTC'</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(../font/NotoSansTC-Regular.otf) <span class="built_in">format</span>(<span class="string">'opentype'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">'NotoSansTC'</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>從上面結果可以得知，CSS 內的 <code>@font-face</code> 連結也是正確的，直接打開網頁即可看到字體已被更改，此時我們打包字體的目的也就成功了。</p>
<p>有人可能會問，font 字體可以使用 url-loader 處理嗎？答案是可以的，但非常不建議這樣做，英文字體少說 150 KB 起跳，而中文字體則是 5MB 起跳，對於網頁的效能來說，會有非常大的影響，這也是之前提到的 url-loader 中 limit 選項需要自己去衡量的原因，一般來說 8KB 左右就是極限了，超過的檔案就都建議以 file-loader 進行處理，各位可以自己試試看。</p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>w3HexSchool</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 前端打包工具 - 使用 babel-loader 編譯並轉換 ES6+ 代碼</title>
    <url>/2020-03-16-webpack-babelloader/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Babel 是一款 JavaScript 的編譯器，你可能會有疑問，JavaScript 不是可以直接在 Browser 上運行嗎？為何還需要編譯？事實上 JavaScript 從發行到現在，經過了許多版本的更新，常見的 ES6、ES7 都屬於較新的版本，最為穩定的版本為 ES5，兼容性也是最高的， Babel 的用意就是將較新版本的 JavaScript 編譯成穩定版本，以提高兼容性。此篇將介紹如何透過 babel-loader 編譯我們的 ES6+ 代碼，後面也會補充介紹 @babel/runtime 與 @babel/polyfill 組件的使用。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>babel-loader 安裝</li>
<li>babel-loader 基本使用</li>
<li>babel-loader 可傳遞選項</li>
<li>補充：@babel/runtime 與 @babel/polyfill 組件使用的必要</li>
<li>補充：@babel/runtime 使用方式</li>
<li>補充：@babel/polyfill 使用方式</li>
</ul>
<h2 id="babel-loader-安裝"><a href="#babel-loader-安裝" class="headerlink" title="babel-loader 安裝"></a>babel-loader 安裝</h2><blockquote>
<p>套件連結：<a href="https://github.com/babel/babel-loader" target="_blank" rel="external nofollow noopener noreferrer">babel-loader</a></p>
</blockquote>
<p>主要的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install babel-loader @babel/core @babel/preset-env -D</span><br></pre></td></tr></table></figure>

<p>package.json：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"@babel/core"</span>: <span class="string">"^7.9.0"</span>,</span><br><span class="line">    <span class="attr">"@babel/preset-env"</span>: <span class="string">"^7.9.0"</span>,</span><br><span class="line">    <span class="attr">"babel-loader"</span>: <span class="string">"^8.1.0"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.42.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Webpack 通過 babel-loader 調用 Babel，直接安裝即可，同時也必須安裝 @babel/core 與 @babel/preset-env，用作 Babel 核心與插件集。</p>
<h2 id="babel-loader-基本使用"><a href="#babel-loader-基本使用" class="headerlink" title="babel-loader 基本使用"></a>babel-loader 基本使用</h2><p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── js&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.js       # JavaScript 主檔案</span><br><span class="line">│   │</span><br><span class="line">│   └─── main.js          # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── index.html           # 引入 bundle.js 測試用檔案</span><br><span class="line">├─── webpack.config.js    # Webpack 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure>

<p>撰寫 ES6+ 版本代碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'Roya'</span>, <span class="string">'Owen'</span>, <span class="string">'Eric'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> index = arr.findIndex(<span class="function">(<span class="params">item</span>) =&gt;</span> item === <span class="string">'Owen'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Owen 排在第 <span class="subst">$&#123;index + <span class="number">1</span>&#125;</span> 順位`</span>);</span><br></pre></td></tr></table></figure>

<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 配置 babel-loader (第一步)</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">        <span class="comment">// 排除 node_modules 與 bower_components 底下資料 (第二步)</span></span><br><span class="line">        exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            <span class="comment">// 配置 Babel 解析器 (第三步)</span></span><br><span class="line">            presets: [<span class="string">'@babel/preset-env'</span>],</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通常在配置 Babel 時，我們都是習慣把 options 的內容撰寫在獨立的 <code>.babelrc</code> 檔案內，如果 Babel 的配置較為複雜，相比於撰寫在 <code>webpack.config.js</code> 內，使用 <code>.babelrc</code> 更能提高其辨識度，在之後的 @babel/runtime 與 @babel/polyfill 章節會再做補充，讓我們先暫時以此方式進行配置。</p>
<p>entry 入口處 (<code>src/main.js</code>) 引入 JavaScript 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./js/all'</span>; <span class="comment">// JavaScript 預設不需要附檔名</span></span><br></pre></td></tr></table></figure>

<p>至 <code>package.json</code> 新增編譯指令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --mode development"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行編譯指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>讓我們打開編譯完成的 <code>bundle.js</code> 檔案，看看 Babel 究竟做了什麼處理：</p>
<!-- prettier-ignore-start -->
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*!********************!*\</span></span><br><span class="line"><span class="comment">  !*** ./src/all.js ***!</span></span><br><span class="line"><span class="comment">  \********************/</span></span><br><span class="line"><span class="comment">/*! no static exports found */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"var arr = [\"Roya\", \"Owen\", \"Eric\"];\nvar index = arr.findIndex(function (item) &#123;\n  return item === \"Owen\";\n&#125;);\nconsole.log(\"Owen \\u6392\\u5728\\u7B2C \".concat(index + 1, \" \\u9806\\u4F4D\"));\n\n//# sourceURL=webpack:///./src/all.js?"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;),</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>看到編譯完成的代碼，你的第一個想法大概都是 WTF … 這是什麼鬼？不用擔心，Babel 只是將你的代碼優化為兼容性較高版本的代碼，你也不需要針對這一個檔案做任何修改，可以直接給 HTML 讀取，執行結果如同未編譯的 JavaScript 檔案，你只需要專注於目標的編程，不管你用多新版本的代碼來實現，Babel 都可以幫你改善兼容性等相關問題。</p>
<p>至 <code>./index.html</code> 引入打包而成的 <code>bundle.js</code> 檔案：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 其他省略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入打包生成的 JavaScript --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/bundle.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>查看結果：</p>
<p><img src="https://i.imgur.com/PbbKEpn.png" alt="babel-loader console"></p>
<p><img src="https://i.imgur.com/WbDDmyi.png" alt="babel-loader source"></p>
<p>如果你覺得 <code>bundle.js</code> 檔案閱讀起來很吃力，你也可以先將其引入至 <code>index.html</code> 內，之後再按 <code>F12</code> 切換至 <code>Source</code> 觀察編譯結果，可能會更好理解喔！</p>
<p>從上面結果可以得知，我們的 Babel 是有成功運行的，但這邊要注意的是，<strong>Babel 默認只針對 Syntax 做轉換</strong>，像是上面範例的 <code>findIndex</code> 實例就沒有被轉換，因為他不屬於 Syntax，關於這一個問題，可以使用 @babel/runtime 或 @babel/polyfill 進行處理，這點在下面會有補充說明，讓我們先以此方式進行。</p>
<h2 id="babel-loader-可傳遞選項"><a href="#babel-loader-可傳遞選項" class="headerlink" title="babel-loader 可傳遞選項"></a>babel-loader 可傳遞選項</h2><p>可參考 <a href="https://github.com/babel/babel-loader#options" target="_blank" rel="external nofollow noopener noreferrer">babel-loader Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li><p>presets：<code>Array</code><br>Babel 插件集，默認為 <code>none</code></p>
</li>
<li><p>cacheDirectory：<code>Boolean</code><br>用於利用緩存加載程序的結果，默認 <code>false</code></p>
</li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            presets: [<span class="string">'@babel/preset-env'</span>],</span><br><span class="line">            cacheDirectory: <span class="literal">true</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="補充：-babel-runtime-與-babel-polyfill-組件使用的必要"><a href="#補充：-babel-runtime-與-babel-polyfill-組件使用的必要" class="headerlink" title="補充：@babel/runtime 與 @babel/polyfill 組件使用的必要"></a>補充：@babel/runtime 與 @babel/polyfill 組件使用的必要</h2><div class="note danger">Babel 默認只針對 Syntax 做轉換，例如：箭頭函式、ES6 變數、Class 語法糖等等，而自帶的 API 與原生內置的 methods 需要透過 polyfill 後才能在瀏覽器正常運行。</div>

<p>當前使用 Babel 版本：<code>v7.9.0</code></p>
<hr>
<p>Babel 7 版本時，各種運行錯誤，官方 API 雖然完整，但各章節並沒有連貫性，操作下來也不知道問題在哪，在我們探討這兩個組件之前，我們先來解釋這兩個組件到底是要幫我們解決什麼問題。</p>
<p>將 <code>./src/js/all.js</code> 檔案，修改為如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* --- 箭頭函式、ES6 變數、ES6 陣列方法 --- */</span></span><br><span class="line"><span class="keyword">let</span> color = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> result = color.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- Class 語法糖 --- */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- Promise 物件 --- */</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve();</span><br></pre></td></tr></table></figure>

<p>針對上面這一個 JavaScript 檔案，我們使用之前配置好的 <code>webpack.config.js</code> 來編譯它，編譯結果如下：</p>
<p><img src="https://i.imgur.com/vfX4jwn.png" alt="babel compile"></p>
<p>聰明的你應該發現問題了，Babel 不是會幫我們處理兼容性的問題嗎？<code>Array.prototype.filter</code> 與 <code>Promise</code> 物件好像都沒有編譯到的感覺，不要懷疑！Babel 真的沒有幫我們編譯到；事實上，如果你採用預設的編譯環境，<strong>Babel 只會針對語法 (Syntax) 做編譯，底層的 API 與原型擴展都不會進行編譯</strong>，這也就代表兼容性的問題根本沒有解決，在 IE 11 等較舊瀏覽器上面，它還是不知道什麼是 Promise，運行時就會發生錯誤；在這邊還有一個問題，<strong>Babel 針對 Class 語法糖的處理，你會發現它新增了一個全域的 function 當作語法糖的呼叫，這樣子的處理會造成嚴重的全域汙染</strong>，如果你有多個 JavaScript 檔案，同時都進行編譯的動作，產生出來的 function 都會是一模一樣的，不僅造成檔案的肥大，也有可能發生全域汙染影響運行等問題；這時候就會需要 @babel/runtime 與 @babel/polyfill 的幫忙，在介紹這兩個組件時，我們先將 Babel 的設定移置專屬的設定檔，如下所示：</p>
<p>路徑 <code>./webpack.config.js</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          <span class="comment">// 將可傳遞選項移至 .babelrc</span></span><br><span class="line">          loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>將原有的可傳遞選項移除，並新增 <code>./.babelrc</code> 專屬配置檔：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"@babel/preset-env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時運行 <code>npm rum build</code> 指令，結果會是一模一樣的，在之後針對 Babel 所作的處理，我們都會使用 <code>.babelrc</code> 這一個檔案做修改，接下來讓我們開始正式介紹 @babel/runtime 與 @babel/polyfill。</p>
<h2 id="補充：-babel-runtime-使用方式"><a href="#補充：-babel-runtime-使用方式" class="headerlink" title="補充：@babel/runtime 使用方式"></a>補充：@babel/runtime 使用方式</h2><p>@babel/runtime 是由 Babel 提供的 polyfill 套件，由 core-js 和 regenerator 組成，core-js 是用於 JavaScript 的組合式標準化庫，它包含各種版本的 polyfills 實現；而 regenerator 是來自 facebook 的一個函式庫，主要用於實現 generator/yeild，async/await 等特性，我們先從安裝開始講起。</p>
<blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/@babel/runtime" target="_blank" rel="external nofollow noopener noreferrer">@babel/runtime</a>、<a href="https://www.npmjs.com/package/@babel/plugin-transform-runtime" target="_blank" rel="external nofollow noopener noreferrer">@babel/plugin-transform-runtime</a></p>
</blockquote>
<p>@babel/runtime：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install @babel/runtime</span><br></pre></td></tr></table></figure>

<p>@babel/plugin-transform-runtime：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install @babel/plugin-transform-runtime --save-dev</span><br></pre></td></tr></table></figure>

<p>在安裝 @babel/runtime 時，記得不要安裝錯誤，新版的是帶有 <code>@</code> 開頭的；同時也必須安裝 @babel/plugin-transform-runtime 這個套件，babel 在運行時是依賴 plugin 去做取用，這兩個套件雖然不是相依套件，但實際使用時缺一不可，在後面會有相關說明，在這邊我們先把這兩個套件裝好就可以了。</p>
<p>修改 <code>./.babelrc</code> 內容為下面範例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"@babel/preset-env"</span>],</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/plugin-transform-runtime"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"corejs"</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我們以之前的 JavaScript 檔案進行示範，執行 <code>npm run build</code> 指令進行編譯，結果如下：</p>
<p><img src="https://i.imgur.com/tPSUfkg.png" alt="babel 搭配 @babel-runtime"></p>
<p>從編譯後的結果可以得知，之前提到的 Class 語法糖全域汙染問題已經解決了，透過 @babel/plugin-transform-runtime 這個套件，它會幫我們分析是否有 polyfill 的需求，並自動透過 require 的方式，向 @babel/runtime 拿取 polyfill，簡單來講，<strong>@babel/runtime 提供了豐富的 polyfill 供組件使用，開發者可以自行 require，但自行 require 太慢了，使用 @babel/plugin-transform-runtime 可以自動分析並拿取 @babel/runtime 的 polyfill</strong>，這也是為什麼這兩個套件缺一不可的原因。</p>
<p>可能有些人還是有疑問，透過 require 的方式為什麼就能避免全域污染的問題？事實上，當初我也很困惑，結果恍然大悟，終於理解了，簡單來講，當初是因為 babel 會在全域環境宣告 function，只要同時有 1 個檔案以上需要編譯時，這些 function 就會相遇干擾，實際運行就會發生錯誤，透過 @babel/runtime 直接 require 的方式進行取用，最後編譯出來的檔案就不會汙染到全域環境，而是生成許多的 require 指令，<strong>Node.js 默認是從緩存中載入模組，一個模組被加載一次之後，就會在緩存中維持一個副本，如果遇到重複取用問題，會直接向緩存拿取副本，這也就代表每個模組在緩存中止存在一個實例</strong>。</p>
<p>仔細觀察，Babel 還是沒有幫我們編譯 Promise 物件，那是因為我們還沒有解放 @babel/runtime 這一個套件全部力量，由上面範例，你會發現我在 plugin 中傳遞了一個 corejs 選項，預設是關閉的，可傳遞的選項為：</p>
<table>
<thead>
<tr>
<th align="left">corejs 選項</th>
<th align="left">安裝指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">false</td>
<td align="left">npm install <span>-<span><span>-save<span> @babel/runtime</span></span></span></span></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">npm install <span>-<span><span>-save<span> @babel/runtime-corejs2</span></span></span></span></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">npm install <span>-<span><span>-save<span> @babel/runtime-corejs3</span></span></span></span></td>
</tr>
</tbody></table>
<p>事實上 @babel/runtime 有許多的擴展版本，在之前的範例中，我們都是將 corejs 給關閉，這也就導致它並沒有幫我們編譯底層的 API 與相關的方法，這次我們就來使用各版本進行編譯，記得要執行相對應的安裝指令喔！</p>
<p>修改 <code>./.babelrc</code> 內容為下面範例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"@babel/preset-env"</span>],</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/plugin-transform-runtime"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"corejs"</span>: <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>corejs2 版本編譯結果：</p>
<p><img src="https://i.imgur.com/FfUCwFU.png" alt="babel 搭配 @babel-runtime-corejs2 結果"></p>
<p>corejs3 版本編譯結果：</p>
<p><img src="https://i.imgur.com/RLBrTw1.png" alt="babel 搭配 @babel-runtime-corejs3 結果 "></p>
<p>從上面結果可以得知，<strong>corejs2 版本主要針對底層 API 做編譯，如 Promise、Fetch 等等；corejs3 版本主要針對底層 API 和相關實例方法，如 Array.pototype.filter，Array.pototype.map 等等</strong>，簡單來講，如果你要將兼容性的問題徹底解決，就得使用 corejs3 版本，到了這邊，我們之前所提到 Babel 的種種問題都已經獲得解決。</p>
<div class="note warning">使用 @babel/runtime 能夠在不汙染全域環境下提供相對應的 polyfill，擁有自動識別功能，在某些情況下，編譯出來的檔案大小可能比使用 @babel/polyfill 來的小，適合開發組件庫或對環境較為嚴格的專案</div>

<h2 id="補充：-babel-polyfill-使用方式"><a href="#補充：-babel-polyfill-使用方式" class="headerlink" title="補充：@babel/polyfill 使用方式"></a>補充：@babel/polyfill 使用方式</h2><p>@babel/polyfill 與 @babel/runtime 一直以來這兩者的差別都很模糊，網上的文章大多也都是複製官方的說明文檔，並沒有實際去使用，造成開發者一知半解的疑慮，這一次我們就來討論 @babel/polyfill 究竟要如何使用。先從安裝開始說起：</p>
<p>Babel 版本 &lt; <code>v7.4.0</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install @babel/polyfill</span><br></pre></td></tr></table></figure>

<p>Babel 版本 &gt;= <code>v7.4.0</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install core-js regenerator-runtime/runtime</span><br></pre></td></tr></table></figure>

<p>從 Babel &gt;= 7.4.0 後，@babel/polyfill 組件庫已被棄用，事實上 @babel/polyfill 本身就是由 stable 版本的 core-js 和 regenerator-runtime 組成，我們可以直接下載這兩個組件庫當作 @babel/polyfill 來使用，官方也推薦此做法，這邊要注意的是 regenerator-runtime 為 @babel/runtime 的相依套件，可以自行檢查是否有正確安裝。</p>
<p>修改 <code>./.babelrc</code> 內容為下面範例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"useBuiltIns"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"corejs"</span>: <span class="number">3</span> // 當前 core-js 版本</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我們使用之前的 JavaScript 檔案進行示範，執行 <code>npm run build</code> 指令進行編譯，結果如下：</p>
<p><img src="https://i.imgur.com/vfX4jwn.png" alt="babel 編譯結果"></p>
<p>編譯結果就如同單純使用 Babel 一樣，只有針對語法 (Syntax) 做編譯，那是因為我們尚未開啟 polyfill 的功能，可通過更改 <code>useBuiltIns</code> 來變更模式，可選模式為 <code>false</code>、<code>usage</code>、<code>entry</code>，以下為各模式的編譯結果：</p>
<p>useBuiltIns：<code>usage</code>：</p>
<p><img src="https://i.imgur.com/fuvAyzJ.png" alt="babel useBuiltIns 更改為 usage"></p>
<p>很明顯的將 useBuiltIns 更改為 <code>usage</code>，就如同使用 @babel/runtime-corejs3 一樣，自動識別需要 require 的新語法，將兼容性問題徹底解決，不同的地方在於，@babel/runtime 在不汙染全域環境下提供 polyfill，而 @babel/polyfill 則是將需要兼容的新語法掛載到全局對象，這樣子的做法即會造成所謂的全局汙染，讓我們來看最後一個 useBuiltIns 選項。</p>
<p>useBuiltIns：<code>entry</code>：</p>
<div class="note warning">使用 entry 選項記得在前面 import core-js/stable 和 regenerator-runtime/runtime 組件庫</div>

<blockquote>
<p>代編譯檔案：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'core-js/stable'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'regenerator-runtime/runtime'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 箭頭函式、ES6 變數、ES6 陣列方法 --- */</span></span><br><span class="line"><span class="keyword">let</span> color = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> result = color.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- class 語法糖 --- */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- Promise 物件 --- */</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>完成編譯檔案</p>
</blockquote>
<p><img src="https://i.imgur.com/fK5FOyV.png" alt="babel useBuiltIns 更改為 entry"></p>
<p><code>entry</code> 這一個選項就簡單多了，沒有做任何的識別，直接將整個 ES 環境掛載到全局對象，確保瀏覽器可以兼容所有的新特性，但這樣子做的缺點也顯而易見，整個專案環境會較為肥大，你可能會好奇 <code>entry</code> 選項的必要，事實上 Babel 默認不會檢測第三方依賴組件，所以使用 <code>usage</code> 選項時，可能會出現引入第三方的代碼包未載入模組而引發的 Bug，這時就有使用 <code>entry</code> 的必要。</p>
<div class="note warning">@babel/polyfill 提供一次性載入或自動識別載入 polyfill 的功能，使用掛載全局對象的方法，達到兼容新特性目的，適合開發在專案環境，較不適合開發組件庫或工具包，存在汙染全局對象疑慮。</div>

<p>經過了一番對於 @babel/runtime 與 @babel/polyfill 的討論，相信各位已經了解兩者的差別，在這邊做一個總結：</p>
<ol>
<li><p>Babel 版本 &lt; <code>7.4.0</code>：</p>
<ul>
<li>開發組件庫、工具包，選擇 @babel/runtime</li>
<li>開發本地專案，選擇 @babel/polyfill</li>
</ul>
</li>
<li><p>Babel 版本 &gt;= <code>7.4.0</code></p>
<ul>
<li>配置較簡單，會汙染全域環境，選擇 @babel/polyfill</li>
<li>配置較繁瑣，不會汙染全域環境，選擇 @babel/runtime</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Babel</tag>
        <tag>w3HexSchool</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 前端打包工具 - 使用 clean-webpack-plugin 清除構建資料夾</title>
    <url>/2020-03-25-webpack-cleanwebpackplugin/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在我們每次編譯 Webpack 時，都必須刪除之前測試所建構的 dist 資料夾，以確保結果為最新狀態，可能有些人並沒有這個困擾，那是因為你並沒有在 filename 屬性加入 hash 值，此時編譯處理為取代其檔案，在一般開發中我們都會在檔案名稱加入 hash 值，避免快取機制發生的問題，此時由於檔案名稱的 hash 值不同，其編譯處理將轉為新增，dist 資料夾也就會遺留之前測試所建構出的檔案。此篇將介紹使用 clean-webpack-plugin 在每次編譯時刪除之前測試所建構出的檔案，接著才生成編譯結果。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>clean-webpack-plugin 安裝</li>
<li>clean-webpack-plugin 基本使用</li>
<li>clean-webpack-plugin 可傳遞選項</li>
<li>補充：cleanOnceBeforeBuildPatterns 使用技巧</li>
</ul>
<h2 id="clean-webpack-plugin-安裝"><a href="#clean-webpack-plugin-安裝" class="headerlink" title="clean-webpack-plugin 安裝"></a>clean-webpack-plugin 安裝</h2><blockquote>
<p>套件連結：<a href="https://github.com/johnagan/clean-webpack-plugin" target="_blank" rel="external nofollow noopener noreferrer">clean-webpack-plugin</a></p>
</blockquote>
<p>主要的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install clean-webpack-plugin -D</span><br></pre></td></tr></table></figure>

<p>過程會使用到的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install css-loader mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure>

<p>package.json：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"clean-webpack-plugin"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^3.4.2"</span>,</span><br><span class="line">    <span class="attr">"mini-css-extract-plugin"</span>: <span class="string">"^0.9.0"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.42.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>為了避免有任何誤會，請同時安裝 CSS 相關 loader 以及 clean-webpack-plugin，這一個 Plugin 主要是針對資料夾做操作，並不是針對特定檔案做操作，確保測試所建構出的檔案能夠完整被刪除。</p>
<h2 id="clean-webpack-plugin-基本使用"><a href="#clean-webpack-plugin-基本使用" class="headerlink" title="clean-webpack-plugin 基本使用"></a>clean-webpack-plugin 基本使用</h2><div class="note warning">此次範例會搭配 css-loader 與 mini-css-extract-plugin 一起使用，相關文章連結：<a href="https://awdr74100.github.io/2020-02-26-webpack-cssloader-styleloader/" target="_blank">css-loader</a>、<a href="https://awdr74100.github.io/2020-03-02-webpack-minicssextractplugin/" target="_blank">mini-css-extract-plugin</a></div>

<p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.css      # CSS 主檔案</span><br><span class="line">│   │</span><br><span class="line">│   └─── main.js          # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── webpack.config.js    # Webpack 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure>

<div class="note warning">前面為示範之前所提到的遺留測試所建構檔案問題。</div>

<p>撰寫 CSS 範例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#2525b1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>entry 入口處 (<code>src/main.js</code>) 引入 CSS 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./css/all.css'</span>; <span class="comment">// 使用 ESM 方式引入</span></span><br></pre></td></tr></table></figure>

<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[hash].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/[name].[hash].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>至 <code>package.json</code> 新增編譯指令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --mode development"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行編譯指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>隨意修改 CSS 使 hash 值更動：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#49bd79</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次執行 <code>npm run build</code> 指令，以下為編譯後的目錄結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       ├─── main.341ff16a50939fca12a9.css</span><br><span class="line">|       └─── main.592df2c6643f48d39238.css</span><br><span class="line">│   │</span><br><span class="line">│   ├─── main.341ff16a50939fca12a9.js</span><br><span class="line">|   └─── main.592df2c6643f48d39238.js</span><br></pre></td></tr></table></figure>

<p>在我們每次有任何修改檔案行為時，hash 值都會有所改變，這也就導致了 <code>dist</code> 資料夾有殘留測試所建構檔案問題，正常來講不應該有這些檔案才對，當然你也可以手動刪除，但你使用的可是自動化工具阿！當然也要用自動化的方式來解決，讓我們來導入 clean-webpack-plugin 看看效果如何。</p>
<p>修改 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="comment">// 載入 clean-webpack-plugin (第一步)</span></span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[hash].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/[name].[hash].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 創建實例 (第二步)</span></span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再次執行 <code>npm run build</code> 指令，並查看編譯結果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── main.341ff16a50939fca12a9.css</span><br><span class="line">│   │</span><br><span class="line">│   └─── main.341ff16a50939fca12a9.js</span><br></pre></td></tr></table></figure>

<p>從上面結果可以得知，我們的 <code>dist</code> 資料夾殘留的檔案都被刪除了，整個資料夾都是全新的狀態，<strong>clean-webpack-plugin 是以同步的方式刪除檔案</strong>，也就代表刪除資料夾後才會進行生成 <code>dist</code> 資料夾動作，不存在刪除資料夾時就生成檔案問題。</p>
<p>你可能會好奇，以往在使用類似功能的 del 套件時，都必須指定所要刪除得資料夾路徑，為什麼 clean-webpack-plugin 不用呢？只是單純的創建實例就可以自動幫我們刪除 dist 資料夾，太神奇了吧！關於這點將在下面做補充，</p>
<h2 id="clean-webpack-plugin-可傳遞選項"><a href="#clean-webpack-plugin-可傳遞選項" class="headerlink" title="clean-webpack-plugin 可傳遞選項"></a>clean-webpack-plugin 可傳遞選項</h2><p>可參考 <a href="https://github.com/johnagan/clean-webpack-plugin#options-and-defaults-optional" target="_blank" rel="external nofollow noopener noreferrer">clean-webpack-plugin Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li>verbase：<code>Boolean</code><br>將日誌寫入控制台，默認為 <code>false</code></li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">      verbose: <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="補充：cleanOnceBeforeBuildPatterns-使用技巧"><a href="#補充：cleanOnceBeforeBuildPatterns-使用技巧" class="headerlink" title="補充：cleanOnceBeforeBuildPatterns 使用技巧"></a>補充：cleanOnceBeforeBuildPatterns 使用技巧</h2><p>事實上，clean-webpack-plugin 預設的刪除目錄為 <code>output.path</code> 指定的目錄，也就是絕對路徑下的 <code>dist</code> 資料夾，透過 <code>cleanOnceBeforeBuildPatterns</code> 這一個可傳遞選項指定並刪除目錄下的所有檔案，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">      cleanOnceBeforeBuildPatterns: [<span class="string">'**/*'</span>], <span class="comment">// 預設值 (相對於 output.path 指定目錄下)</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也因為這一個可傳遞選項，促使 clean-webpack-plugin 在每次編譯前刪除指定目錄下的文件，這邊要注意的是，你可以在 <code>output.path</code> 目錄下指定刪除任何的檔案，但沒辦法使用相對路徑方式刪除目錄之外的檔案，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">      cleanOnceBeforeBuildPatterns: [<span class="string">'**/*'</span>, <span class="string">'../*.json'</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面寫法代表著在每次編譯前即刪除 <code>output.path</code> 下的所有檔案以及 <code>output.path</code> 上一層目錄下的所有 <code>.json</code> 檔案，但這樣子的寫法是行不通的，編譯過程會報錯，如果你想要刪除 <code>output.path</code> 目錄之外的文件，需使用絕對路徑寫法，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">      cleanOnceBeforeBuildPatterns: [<span class="string">'**/*'</span>, path.resolve(__dirname, <span class="string">'*.json'</span>)],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有時我們想要在刪除的範圍內保留特定檔案，比如說上面範例中的 <code>package.json</code> 與 <code>package-lock.json</code>，我們可以使用 <code>!</code> 排除文件，如下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">      cleanOnceBeforeBuildPatterns: [</span><br><span class="line">        <span class="string">'**/*'</span>,</span><br><span class="line">        path.resolve(__dirname, <span class="string">'*.json'</span>),</span><br><span class="line">        <span class="string">`!<span class="subst">$&#123;path.resolve(__dirname, <span class="string">'package*'</span>)&#125;</span>`</span>,</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有 <code>cleanOnceBeforeBuildPatterns</code> 的存在，想當然也有 <code>cleanAfterEveryBuildPatterns</code> 的存在，使用方式一模一樣，差別只在於一個是編譯前進行處理，一個是編譯後進行處理，各位可自行嘗試，下面為 <code>cleanAfterEveryBuildPatterns</code> 的範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">      cleanAfterEveryBuildPatterns: [], <span class="comment">// 預設值 (不刪除任何檔案)</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 前端打包工具 - 使用 html-webpack-plugin 生成 HTML 文件</title>
    <url>/2020-03-23-webpack-htmlwebpackplugin/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前介紹 Webpack 的各種 loader 時，最後都得手動生成 HTML 文件並引入相關的靜態檔案，這樣不是很矛盾嗎？Webpack 可是自動化工具阿！怎會有這麼個缺陷？不用擔心，那是因為我們還沒使用 html-webpack-plugin 這一個插件，html-webpack-plugin 可以幫助我們指定任意的 HTML 模板，並透過傳遞選項方式，生成對應的 HTML 文件，同時也會將 entry 內的所有靜態文件做引入動作，解決手動引入的困擾。此篇將介紹如何透過 html-webpack-plugin 生成自動引入靜態檔案的 HTML 文件。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>html-webpack-plugin 安裝</li>
<li>html-webpack-plugin 基本使用</li>
<li>html-webpack-plugin 可傳遞選項</li>
<li>補充：使用自帶的 lodash.template 進行撰寫</li>
<li>補充：依照 chunk 載入不同檔案</li>
<li>補充：壓縮並優化 HTML</li>
</ul>
<h2 id="html-webpack-plugin-安裝"><a href="#html-webpack-plugin-安裝" class="headerlink" title="html-webpack-plugin 安裝"></a>html-webpack-plugin 安裝</h2><blockquote>
<p>套件連結：<a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="external nofollow noopener noreferrer">html-webpack-plugin</a></p>
</blockquote>
<p>主要的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install html-webpack-plugin -D</span><br></pre></td></tr></table></figure>

<p>過程會使用到的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install css-loader mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure>

<p>package.json：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^3.4.2"</span>,</span><br><span class="line">    <span class="attr">"html-webpack-plugin"</span>: <span class="string">"^4.0.3"</span>,</span><br><span class="line">    <span class="attr">"mini-css-extract-plugin"</span>: <span class="string">"^0.9.0"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.42.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>為了模擬一般開發常見的環境，請同時安裝 css-loader 與 mini-css-extract-plugin 用以處理 CSS 檔案，最後我們會透過 html-webpack-plugin 將這些靜態檔案做自動引入的動作，同時生成以 <code>templete</code> 可傳遞選項指定模板的 HTML 文件。</p>
<h2 id="html-webpack-plugin-基本使用"><a href="#html-webpack-plugin-基本使用" class="headerlink" title="html-webpack-plugin 基本使用"></a>html-webpack-plugin 基本使用</h2><div class="note warning">此次範例會搭配 css-loader 與 mini-css-extract-plugin 一起使用，相關文章連結：<a href="https://awdr74100.github.io/2020-02-26-webpack-cssloader-styleloader/" target="_blank">css-loader</a>、<a href="https://awdr74100.github.io/2020-03-02-webpack-minicssextractplugin/" target="_blank">mini-css-extract-plugin</a></div>

<p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.css      # CSS 主檔案</span><br><span class="line">│   │</span><br><span class="line">│   ├─── index.html       # HTML 主檔案</span><br><span class="line">│   └─── main.js          # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── webpack.config.js    # Webpack 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure>

<p>撰寫 CSS 範例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#2525b1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至 <code>./src/index.html</code> 撰寫 HTML 模板範例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-primary"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你可以依照習慣隨意編寫你的 HTML 檔案，且不需要做任何的引入動作，這點在後面會說明，讓我們繼續看下去。</p>
<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="comment">// 載入 html-webpack-plugin (第一步)</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'static/js/[name].[hash].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'static/css/[name].[hash].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 創建實例 (第二步)</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 配置 HTML 模板路徑與生成名稱 (第三步)</span></span><br><span class="line">      template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我們可以刻意的將打包後的靜態檔案指定放置在不同的資料夾下，同時也須配置 html-webpack-plugin 的 <code>templete</code> 與 <code>filename</code> 選項，<code>templete</code> 選項可將我們 <code>src/index.html</code> 檔案作為模板文件，簡單來講就是自動引入靜態檔案的目標文件，而 <code>filename</code> 選項則是用來配置目標文件生成時的名稱。</p>
<p>entry 入口處 (<code>src/main.js</code>) 引入 CSS 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./css/all.css'</span>; <span class="comment">// 使用 ESM 方式引入</span></span><br></pre></td></tr></table></figure>

<p>至 <code>package.json</code> 新增編譯指令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --mode development"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行編譯指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>此時打包生成的 <code>dist</code> 資料夾結構應如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── static&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── css</span><br><span class="line">│           │</span><br><span class="line">│           └─── main.f25bdf99993c55b0e375.css</span><br><span class="line">│       │</span><br><span class="line">│       └─── js</span><br><span class="line">│           │</span><br><span class="line">│           └─── main.f25bdf99993c55b0e375.js</span><br><span class="line">│   │</span><br><span class="line">│   └─── index.html</span><br></pre></td></tr></table></figure>

<p>查看 <code>./dist/index.html</code> 檔案結果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"static/css/main.f25bdf99993c55b0e375.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-primary"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"static/js/main.f25bdf99993c55b0e375.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>有沒有覺得很神奇？打包後的 <code>dist/index.html</code> 居然自動幫我們引入了所有的靜態檔案，包含 CSS、JavaScript 等等，增加任何位數的 hash 值也都沒問題，html-webpack-plugin 能夠自動去幫我們做辨識，解決手動引入的困擾。</p>
<p>你可能在思考 html-webpack-plugin 的功能就只有這些嗎？當然不只！還有包含類似 ejs 模板語言的編寫方式以及依照 chunk 載入不同檔案等等，這些都將在下面進行補充，一般人最常使用的功能大概就是自動引入靜態資源功能了，其實這個方法是依靠 <code>inject</code> 可傳遞選項來完成的，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      inject: <span class="literal">true</span>, <span class="comment">// 預設為 true</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="html-webpack-plugin-可傳遞選項"><a href="#html-webpack-plugin-可傳遞選項" class="headerlink" title="html-webpack-plugin 可傳遞選項"></a>html-webpack-plugin 可傳遞選項</h2><p>可參考 <a href="https://github.com/jantimon/html-webpack-plugin#options" target="_blank" rel="external nofollow noopener noreferrer">html-webpack-plugin Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li><p>meta：<code>Object</code><br>以 <code>name</code>:<code>content</code> 方式插入 <code>meta</code> 標籤，默認為 <code>{}</code></p>
</li>
<li><p>favicon：<code>String</code><br>添加 favicon 圖示至 HTML，默認為 <code>&quot;&quot;</code></p>
</li>
<li><p>minify：<code>Boolean | Object</code><br>將 HTML 進行壓縮，根據當前環境選擇是否啟用，即 <code>mode</code> 選項</p>
</li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      meta: &#123;</span><br><span class="line">        viewport: <span class="string">'width=device-width, initial-scale=1.0'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      favicon: <span class="string">'./src/img/favicon.ico'</span>,</span><br><span class="line">      minify: <span class="literal">true</span>, <span class="comment">// 下方有更詳細的說明</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="補充：使用自帶的-lodash-template-進行撰寫"><a href="#補充：使用自帶的-lodash-template-進行撰寫" class="headerlink" title="補充：使用自帶的 lodash.template 進行撰寫"></a>補充：使用自帶的 lodash.template 進行撰寫</h2><p>在前面有提到 html-webpack-plugin 可使用類似 ejs 模板語言進行撰寫，html-webpack-plugin 官方後台是使用 <code>lodash.template</code> 模板語言，你可以把它想像成類似 ejs 的模板語言，但不包含 <code>include</code> 等方法。下面為 express 搭配 ejs 模板語言範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.render(<span class="string">'index'</span>, &#123; <span class="attr">title</span>: <span class="string">'這是首頁'</span>, <span class="attr">content</span>: <span class="string">'這是內容'</span>, <span class="attr">vip</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">title</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">content</span> %&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">vip</span>) &#123; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>你是 VIP 用戶<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> &#125; <span class="attr">else</span> &#123; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>你不是 VIP 用戶<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>從上面範例可以看出，ejs 主要可透過相關語法動態載入內容，語法如下：</p>
<ul>
<li><code>&lt;%= value %&gt;</code>：將值輸出到模板中 (轉譯成字串)</li>
<li><code>&lt;%- value %&gt;</code>：將值輸出到模板中 (轉譯成完整片段)</li>
<li><code>&lt;% if () { %&gt;</code>…<code>&lt;% } %&gt;</code>：JavaScript 表達式</li>
<li><a href="https://ejs.co/" target="_blank" rel="external nofollow noopener noreferrer">其他</a>…</li>
</ul>
<p>而 html-webpack-plugin 本身就以搭載 lodash.template 作為模板引擎，撰寫方式與 ejs 大致上相同，差別在於讀取其值語法不同而已，讓我們先從傳遞封裝屬性的物件開始說起。</p>
<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      title: <span class="string">'這是標題'</span>,</span><br><span class="line">      content: <span class="string">'這是內容'</span>,</span><br><span class="line">      link: <span class="string">'https://awdr74100.github.io/'</span>,</span><br><span class="line">      product: [<span class="string">'鉛筆'</span>, <span class="string">'原子筆'</span>, <span class="string">'橡皮擦'</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>至 <code>./src/index.html</code> 動態載入 ejs 傳遞內容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">htmlWebpackPlugin.options.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-primary"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">htmlWebpackPlugin.options.content</span> %&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%= htmlWebpackPlugin.options.link %&gt;"</span>&gt;</span>主頁連結<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%</span> <span class="attr">htmlWebpackPlugin.options.product.forEach</span>(<span class="attr">item</span> =&gt;</span> &#123; %&gt;</span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">item</span> %&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%</span> &#125;) %&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>執行 <code>npm run build</code> 指令，並查看編譯結果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>這是標題<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"static/css/main.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-primary"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>這是內容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://awdr74100.github.io/"</span>&gt;</span>主頁連結<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>鉛筆<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>原子筆<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>橡皮擦<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"static/js/main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>事實上，寫在 <code>HtmlWebpackPlugin({})</code> 內的任何屬性，包含 <code>filename</code>、<code>templete</code> 等等，都可以使用以下語法讀取其值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">htmlWebpackPlugin.options.鍵;</span><br></pre></td></tr></table></figure>

<p>如果你很熟悉 ejs 模板語言，那你對於上面的寫法一定不陌生，唯一要注意的是，html-webpack-plugin 內建的 lodash.template 只支援部分的 ejs 功能，像是 <code>include()</code> 等方法使用即會報錯，因為並不支援。</p>
<h2 id="補充：依照-chunk-載入不同檔案"><a href="#補充：依照-chunk-載入不同檔案" class="headerlink" title="補充：依照 chunk 載入不同檔案"></a>補充：依照 chunk 載入不同檔案</h2><p>html-webpack-plugin 還有一個很棒的功能在於依照 chunk 載入不同檔案，每一個 html-webpack-plugin 實例都代表了一個 HTML 檔案，我們可針對各自的 HTML 檔案依造 chunk 載入不同的 entry 內容，讓我們從新增 HTML 與入口檔案開始說起，如下所示：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> webpack-demo/</span><br><span class="line"> │</span><br><span class="line"> ├─── src/</span><br><span class="line"> │   │</span><br><span class="line"> │   ├─── index.html       # HTML 主檔案</span><br><span class="line"><span class="addition">+│   ├─── contact.html     # HTML 主檔案</span></span><br><span class="line"> │   ├─── main.js          # entry 入口檔案(main)</span><br><span class="line"><span class="addition">+│   └─── contact.js       # entry 入口檔案(contact)</span></span><br></pre></td></tr></table></figure>

<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/main.js'</span>,</span><br><span class="line">    contact: <span class="string">'./src/contact.js'</span>, <span class="comment">// 新增名為 contact 的 chunk</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 新增一個實例</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/contact.html'</span>,</span><br><span class="line">      filename: <span class="string">'contact.html'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>執行 <code>npm run build</code> 指令，並查看編譯結果：</p>
<ul>
<li>index.html 編譯結果：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首頁<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"static/css/main.d39882878d291f6d7aef.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"static/css/contact.d39882878d291f6d7aef.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"static/js/main.d39882878d291f6d7aef.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"static/js/contact.d39882878d291f6d7aef.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>contact.html 編譯結果：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>聯絡<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"static/css/main.d39882878d291f6d7aef.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"static/css/contact.d39882878d291f6d7aef.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"static/js/main.d39882878d291f6d7aef.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"static/js/contact.d39882878d291f6d7aef.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>基於預設配置，html-webpack-plugin 會將所有 chunk 對應的 bundle 內容附加在所有的 HTML 文件上，如果我們想要單獨配置 HTML 文件的 chunk 內容，有以下兩種方法：</p>
<ol>
<li>配置 <code>chunks</code> 選項</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      chunks: [<span class="string">'main'</span>], <span class="comment">// 僅添加名為 main 的 chunk</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      chunks: [<span class="string">'contact'</span>], <span class="comment">// 僅添加名為 contact 的 chunk</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>chunks</code> 選項是以陣列的方式進行撰寫，我們可自由的訂製需載入的 chunk 內容。</p>
<hr>
<ol start="2">
<li>配置 <code>excludeChunks</code> 選項</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      excludeChunks: [<span class="string">'contact'</span>], <span class="comment">// 排除名為 contact 的 chunk</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      excludeChunks: [<span class="string">'main'</span>], <span class="comment">// 排除名為 main 的 chunk</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前面有說過 html-webpack-plugin 預設會將所有 chunk 進行載入，我們可配置 <code>excludeChunks</code> 選項排除不必載入的 chunk，此方法一樣可達到與配置 <code>chunks</code> 相同的效果。</p>
<p>執行 <code>npm run build</code> 指令，並查看編譯結果：</p>
<ul>
<li>index.html 編譯結果：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首頁<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"static/css/main.d39882878d291f6d7aef.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"static/js/main.d39882878d291f6d7aef.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>contact.html 編譯結果：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>聯絡<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"static/css/contact.d39882878d291f6d7aef.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"static/js/contact.d39882878d291f6d7aef.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>這邊補充一點，有時候我們的 chunk 有所謂的順序性，假設 contact 需再 main 前面來說好了，我們可以將 <code>chunksSortMode</code> 改為 <code>manual</code>，此時 html-webpack-plugin 就會依造配置的 <code>chunks</code> 順序進行載入，如下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      chunksSortMode: <span class="string">'manual'</span>, <span class="comment">// 將排序改為手動模式 (即根據 chunks 進行排序)</span></span><br><span class="line">      chunks: [<span class="string">'contact'</span>, <span class="string">'main'</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="補充：壓縮並優化-HTML"><a href="#補充：壓縮並優化-HTML" class="headerlink" title="補充：壓縮並優化 HTML"></a>補充：壓縮並優化 HTML</h2><p>Webpack 在 <code>mode</code> 為 <code>production</code> 時預設會使用 <a href="https://webpack.js.org/plugins/terser-webpack-plugin/" target="_blank" rel="external nofollow noopener noreferrer">TerserWebpackPlugin</a> 將 JavaScript 做壓縮處理，其餘包含像是 CSS、HTML 之類的資源都不會有任何的動作，這些我們都得自己處理，HTML 相比 CSS 需額外安裝套件進行壓縮來的較為方便，所有的操作在 html-webpack-plugin 就都能夠完成，參考以下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      minify: <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不要懷疑就是這麼簡單，但通常我們不會直接將 <code>minify</code> 設為 <code>true</code>，這樣會導致在開發時增加除錯的困難度，較推薦的作法為 <code>development</code> 環境時不啟用壓縮，而 <code>production</code> 環境時啟用，參考以下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      minify: process.env.NODE_ENV == <span class="string">'development'</span> ? <span class="literal">false</span> : <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>事實上這正好也是 html-webpack-plugin 預設的配置，以一般的情況來說，我們不太需要碰到 <code>minify</code> 這個屬性，除非有自定義壓縮的需求，參考以下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">      removeComments: <span class="literal">true</span>,</span><br><span class="line">      removeRedundantAttributes: <span class="literal">true</span>,</span><br><span class="line">      removeScriptTypeAttributes: <span class="literal">true</span>,</span><br><span class="line">      removeStyleLinkTypeAttributes: <span class="literal">true</span>,</span><br><span class="line">      useShortDoctype: <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>html-webpack-plugin 內部是使用 <a href="https://github.com/DanielRuf/html-minifier-terser#options-quick-reference" target="_blank" rel="external nofollow noopener noreferrer">html-minifier-terser</a> 進行壓縮處理，上面是 <code>minify</code> 設為 <code>true</code> 時預設所設置的處理，還有更多的細項可供設置，詳細可參考上方連結，這邊示範將 HTML 中的 <code>&lt;script&gt;</code> 代碼塊內容進行壓縮：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      minifyJS: <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>這邊補充一點，如何使用了自定義方式進行設置，原先的屬性並不會被合併掉，如果你真的不想要預設的那些設置，可以針對各項將其設為 <code>false</code>。</p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>w3HexSchool</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 前端打包工具 - 客製化 Bootstrap 樣式並進行編譯</title>
    <url>/2020-03-28-webpack-includebootstrap/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Bootstrap 目前已經算是前端必備的技能了，相信大部分人在使用時都是以 CDN 的方式進行載入，但這樣子的作法等同於將整個官方預編譯好的 Bootstrap 進行載入，當我們需要客製化 Bootstrap 樣式時，必定得採取其他方法。此篇將介紹如何使用 npm 方式載入 Bootstrap，並透過 sass-loader 編譯屬於我們自己的客製化樣式。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>相關套件安裝</li>
<li>客製並編譯 Bootstrap 預設變數</li>
<li>客製並編譯 Bootstrap 載入元件</li>
<li>載入 jQuery 與 Popper.js 相依套件</li>
</ul>
<h2 id="相關套件安裝"><a href="#相關套件安裝" class="headerlink" title="相關套件安裝"></a>相關套件安裝</h2><blockquote>
<p>套件連結：<a href="https://translate.google.com.tw/?hl=zh-TW" target="_blank" rel="external nofollow noopener noreferrer">bootstrap</a></p>
</blockquote>
<p>主要的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install bootstrap -P</span><br></pre></td></tr></table></figure>

<p>過程會使用到的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install autoprefixer css-loader html-webpack-plugin mini-css-extract-plugin node-sass postcss-loader sass-loader -D</span><br></pre></td></tr></table></figure>

<p>package.json：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"bootstrap"</span>: <span class="string">"^4.4.1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"autoprefixer"</span>: <span class="string">"^9.7.5"</span>,</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^3.4.2"</span>,</span><br><span class="line">    <span class="attr">"html-webpack-plugin"</span>: <span class="string">"^4.0.3"</span>,</span><br><span class="line">    <span class="attr">"mini-css-extract-plugin"</span>: <span class="string">"^0.9.0"</span>,</span><br><span class="line">    <span class="attr">"node-sass"</span>: <span class="string">"^4.13.1"</span>,</span><br><span class="line">    <span class="attr">"postcss-loader"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    <span class="attr">"sass-loader"</span>: <span class="string">"^8.0.2"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.42.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bootstrap 4 主要由 SCSS 建構而成，當你使用 npm 方式進行安裝時，在下載下來的 package 內即包含未編譯的 SCSS 原始檔案，我們可以針對這一個原始檔案進行客製化並編譯它，在這邊使用 sass-loader 套件進行編譯，由於 Bootstrap 官方的預編譯版本有使用到 autoprefixer 插件以便自動在構建時向某些 CSS 屬性增加前輟詞，我們在處理編譯後檔案時，也必須參照此作法，所以同時安裝了 postcss-loader 與 autoprefixer 套件。</p>
<h2 id="客製並編譯-Bootstrap-預設變數"><a href="#客製並編譯-Bootstrap-預設變數" class="headerlink" title="客製並編譯 Bootstrap 預設變數"></a>客製並編譯 Bootstrap 預設變數</h2><div class="note warning">此次範例會搭配 sass-loader、postcss-loader、css-loader、mini-css-extract-plugin、html-webpack-plugin 一起使用，相關文章連結：<a href="https://github.com/webpack-contrib/sass-loader" target="_blank" rel="external nofollow noopener noreferrer">sass-loader</a>、<a href="https://github.com/postcss/postcss-loader" target="_blank" rel="external nofollow noopener noreferrer">postcss-loader</a>、<a href="https://awdr74100.github.io/2020-02-26-webpack-cssloader-styleloader/" target="_blank">css-loader</a>、<a href="https://awdr74100.github.io/2020-03-02-webpack-minicssextractplugin/" target="_blank">mini-css-extract-plugin</a>、<a href="https://awdr74100.github.io/2020-03-23-webpack-htmlwebpackplugin/" target="_blank">html-webpack-plugin</a></div>

<p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── scss&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── helpers</span><br><span class="line">│           │</span><br><span class="line">│           └─── _variables.scss    # 新增並修改 Bootstrap 預設變數</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.scss     # SCSS 主檔案</span><br><span class="line">│   │</span><br><span class="line">│   ├─── index.html       # HTML 主檔案</span><br><span class="line">│   └─── main.js          # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── webpack.config.js    # Webpack 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure>

<div class="note warning">推薦使用懶人覆蓋法，將 ./node_modules/bootstrap/scss/_variables.scss 另存新檔至本地端</div>

<p>新增 <code>./src/scss/helpers/_variables.scss</code> 並修改預設變數(須查詢預設變數名稱)：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 查詢 node_modules/bootstrap/scss/_variables.scss 預設變數並新增到本地檔案 */</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$primary</span>: <span class="number">#174ea0</span>; <span class="comment">// 隨意修改變數</span></span><br><span class="line"><span class="variable">$success</span>: <span class="number">#2e662e</span>;</span><br></pre></td></tr></table></figure>

<p>新增 <code>./src/scss/helpers/_variables.scss</code> 並修改預設變數(懶人覆蓋法)：</p>
<!-- prettier-ignore-start -->
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 另存新檔 node_modules/bootstrap/scss/_variables.scss 預設變數並修改 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他省略 ...</span></span><br><span class="line"><span class="variable">$primary</span>:       <span class="number">#174ea0</span>; <span class="comment">// $blue !default;</span></span><br><span class="line"><span class="variable">$success</span>:       <span class="number">#2e662e</span>; <span class="comment">// $green !default;</span></span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>根據官方文檔說明，Bootstrap 4 中的每個 SCSS 變數都包含 <code>!default</code> 標誌，允許您在自己的 SCSS 中覆蓋變數的預設值，而無需修改 Bootstrap 的原始碼。唯一要注意的是<strong>新變數必須在導入 Bootstrap 的 SCSS 主文件之前</strong>，否則無法成功，如下範例：</p>
<p>路徑：<code>./src/scss/all.scss</code></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* --- Required (使用模塊解析) --- */</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'~bootstrap/scss/functions'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/variables'</span>; <span class="comment">// 使用本地檔案</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'~bootstrap/scss/mixins'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- Bootstrap 主檔案 (使用模塊解析) --- */</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'~bootstrap/scss/bootstrap'</span>;</span><br></pre></td></tr></table></figure>

<p>在 Gulp 的環境中，我們會使用 <code>includePaths</code> 選項傳遞需遍歷的路徑，好讓解析引擎讀取正確的內容，在 sass-loader 中，也可以傳遞 <code>includePaths</code> 選項，畢竟解析引擎都是使用 Node-Sass，但在這邊我們不使用這個方法，直接以 sass-loader 中的 <code>~</code> 符號告知此不是相對路徑內容，而是指向 <code>resolve.modules</code> 路徑的模組，以下為 <code>resolve.modules</code> 的預設配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    modules: [<span class="string">'node_modules'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>至 <code>./src/index.html</code> 撰寫 HTML 模板範例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-primary"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"text-success"</span>&gt;</span>World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.s[ac]ss$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              plugins: [<span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)],</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">'sass-loader'</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/[name].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>配置檔的部分不太需要注意到什麼事情，如果你想要使用 <code>includePaths</code> 的方式載入 Bootstrap，可增加 <code>sassOptions</code> 選項進而配置當前解析器的可傳遞選項。</p>
<p>建立 <code>.browserslistrc</code> 並輸入官方編譯版本：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt;= 1%</span><br><span class="line">last 1 major version</span><br><span class="line">not dead</span><br><span class="line">Chrome &gt;= 45</span><br><span class="line">Firefox &gt;= 38</span><br><span class="line">Edge &gt;= 12</span><br><span class="line">Explorer &gt;= 10</span><br><span class="line">iOS &gt;= 9</span><br><span class="line">Safari &gt;= 9</span><br><span class="line">Android &gt;= 4.4</span><br><span class="line">Opera &gt;= 30</span><br></pre></td></tr></table></figure>

<p>依造官方 <a href="https://getbootstrap.com/docs/4.4/getting-started/browsers-devices/" target="_blank" rel="external nofollow noopener noreferrer">Browsers and devices</a> 文檔說明，使用 Autoprefixer 可搭配 <a href="https://github.com/browserslist/browserslist" target="_blank" rel="external nofollow noopener noreferrer">Browserslist</a> 進行 CSS Prefix 支援裝置設定，上面為官方預編譯各裝置支援版本。</p>
<p>entry 入口處 (<code>src/main.js</code>) 引入 SCSS 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./scss/all.scss'</span>;</span><br></pre></td></tr></table></figure>

<p>至 <code>package.json</code> 新增編譯指令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --mode development"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行 <code>npm run build</code> 查看結果：</p>
<p><img src="https://i.imgur.com/pRjaVan.png" alt="sass-loader 編譯 bootstap 結果"></p>
<p>從上面結果可以得知，Bootstrap 已成功被我們編譯，且預設樣式也被客製化了，簡單來講，我們可以針對從 package 拉出來的 <code>_variables.scss</code> 檔案進行客製化，過程如同使用 sass-loader 一般，只需要注意路徑是否正確載入即可。</p>
<h2 id="客製並編譯-Bootstrap-載入元件"><a href="#客製並編譯-Bootstrap-載入元件" class="headerlink" title="客製並編譯 Bootstrap 載入元件"></a>客製並編譯 Bootstrap 載入元件</h2><p>Bootstrap 最為人詬病的問題大概就是 package 實在是太大了，雖然可透過壓縮方式進行縮小化，但與 <a href="https://purecss.io/" target="_blank" rel="external nofollow noopener noreferrer">Pure.css</a> 等同類型框架相比還是太大了，內含的許多元件在實際開發時，幾乎都用不太到，造成空間的浪費；我們可以嘗試客製 Bootstrap 載入元件，以減少 package 的大小，讓我們先從 Bootstrap 架構開始說明：</p>
<p>Bootstrap 組成架構：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路徑：node_modules/bootstrap/scss/bootstrap.scss</span></span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'functions'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'variables'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'mixins'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'root'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'reboot'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'type'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'images'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'code'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'grid'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'tables'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'forms'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'buttons'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'transitions'</span>;</span><br><span class="line"><span class="comment">// 以下省略 ...</span></span><br></pre></td></tr></table></figure>

<p>Bootstrap 是一個標準的 OOCSS 範例，也因為使用此設計準則，我們可以很輕鬆的移除沒有使用到的元件。請先將 Bootstrap 主檔案內容複製到 <code>./src/scss/all.scss</code> 內，接著註釋掉不需使用的元件，如下範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路徑：./src/scss/all.scss</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Required</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'~bootstrap/scss/functions'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'~bootstrap/scss/variables'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'~bootstrap/scss/mixins'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自訂需載入的元件</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'~bootstrap/scss/forms'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'~bootstrap/scss/buttons'</span>;</span><br><span class="line"><span class="comment">// @import "transitions";</span></span><br><span class="line"><span class="comment">// @import "dropdown";</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'~bootstrap/scss/button-group'</span>;</span><br><span class="line"><span class="comment">// ... 以下省略</span></span><br></pre></td></tr></table></figure>

<p><code>webpack.config.js</code> 檔案內容如同前面範例，這邊要注意的是，<code>function</code>、<code>variables</code>、<code>mixins</code> 是必要載入的檔案，所有元件都須依賴這三個檔案。</p>
<p>執行指定任務</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>最後觀察編譯後 CSS 檔案，你會發現檔案縮小了很多，這就是客製化 Bootstrap 載入元件的方法，在每次開發後可自行載入須使用的元件，有利於減少 CSS 檔案大小。</p>
<h2 id="載入-jQuery-與-Popper-js-相依模組"><a href="#載入-jQuery-與-Popper-js-相依模組" class="headerlink" title="載入 jQuery 與 Popper.js 相依模組"></a>載入 jQuery 與 Popper.js 相依模組</h2><p>在前面安裝 Bootstrap 時，可能會跳出依賴模組未安裝的問題，如下所示：</p>
<p><img src="https://i.imgur.com/gAUTawv.png" alt="bootstrap 依賴模組未安裝"></p>
<p>Bootstrap 的某些元件如 navbar、alert 需要依賴 jQuery 與 Popper.js 來動作，相信各位對這兩個模組不陌生，以往我們都是採用 CDN 方式引入，這邊我們改採用 npm 方式載入，這邊要注意的是，我們只需要下載 jQuery 即可，Popper.js 已經封裝在 <code>bootstrap.bundle.js</code> 內，直接做載入就能使用。</p>
<blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/jquery" target="_blank" rel="external nofollow noopener noreferrer">jquery</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install jquery -P</span><br></pre></td></tr></table></figure>

<p>entry 入口處 (<code>src/main.js</code>) 引入 Bootstrap 所需模組：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'jquery'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'bootstrap/dist/js/bootstrap.bundle'</span>;</span><br></pre></td></tr></table></figure>

<p>請注意以上寫法，如同前面所說，當相對路徑不存在檔案時，Webpack 會自動幫我們解析 <code>resolve.modules</code> 指向的路徑是否有此模組，由於我們未配置 <code>resolve.modules</code> 選項，所以預設配置為指向 node_modules 資料夾內。</p>
<p>這邊還有一個重點是關於 Bootstrap 路徑的問題，你可能會想，我是否可以使用以下寫法呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'jquery'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'bootstrap'</span>;</span><br></pre></td></tr></table></figure>

<p>答案是不可以的，因為 Bootstrap 預設載入路徑為 <code>bootstrap/dist/js/bootstrap.js</code>，此檔案並沒有包含 Popper.js，我們必須手動指向以封裝的檔案，也就是 <code>bootstrap.bundle.js</code>，且這邊所指的載入，就只是單純的載入 <code>bootstrap.js</code> 與 <code>Popper.js</code>，關於樣式表的部分，還是得手動添加。</p>
<p>至 <code>./src/index.html</code> 新增 Bootstrap 元件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"navbar navbar-expand-lg navbar-light bg-light"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"navbar-brand"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Navbar<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"navbar-toggler"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">"button"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">data-toggle</span>=<span class="string">"collapse"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">data-target</span>=<span class="string">"#navbarSupportedContent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">aria-controls</span>=<span class="string">"navbarSupportedContent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">aria-expanded</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">aria-label</span>=<span class="string">"Toggle navigation"</span></span></span><br><span class="line"><span class="tag">      &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"navbar-toggler-icon"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"collapse navbar-collapse"</span> <span class="attr">id</span>=<span class="string">"navbarSupportedContent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"navbar-nav mr-auto"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"nav-item dropdown"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">"nav-link dropdown-toggle"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">href</span>=<span class="string">"#"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">id</span>=<span class="string">"navbarDropdown"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">role</span>=<span class="string">"button"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">data-toggle</span>=<span class="string">"dropdown"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">aria-haspopup</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">aria-expanded</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            &gt;</span></span><br><span class="line">              Dropdown</span><br><span class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dropdown-menu"</span> <span class="attr">aria-labelledby</span>=<span class="string">"navbarDropdown"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"dropdown-item"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Action<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"dropdown-item"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Another action<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dropdown-divider"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"dropdown-item"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Something else here<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>執行 <code>npm rnu build</code> 並查看結果：</p>
<p><img src="https://i.imgur.com/rkI1RWD.png" alt="webpack 打包 jquery 與 popper.js 成功"></p>
<p>我們可隨意新增需 JavaScript 運行的 Bootstrap 元件至 HTML 上，以便測試是否有成功動作。</p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Node.js</tag>
        <tag>Bootstrap</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 前端打包工具 - 使用 purgecss-webpack-plugin 清除多餘的 CSS</title>
    <url>/2020-03-30-webpack-purgecsswebpackplugin/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇文章中，介紹了如何使用 Webpack 打包客製化的 Bootstrap 樣式，但在這邊還有一個問題，那就是打包出來的 CSS 太肥了，這也是 Bootstrap 為人所詬病的原因，我們根本不需要這麼多的樣式，可能一半以上的 CSS 都沒有使用到，當時的解決辦法是手動移除預設載入的 component，但我們使用的可是 Webpack 自動化工具阿！，當然也要以自動化方式進行處理。此篇將介紹如何使用 purgecss-webpack-plugin 清除多餘的 CSS 代碼，大幅縮減檔案大小。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>purgecss-webpack-plugin 安裝</li>
<li>purgecss-webpack-plugin 基本使用</li>
<li>purgecss-webpack-plugin 可傳遞選項</li>
<li>補充：清除多餘的 Bootstrap 樣式</li>
<li>補充：PurifyCSS 線上縮減服務</li>
</ul>
<h2 id="purgecss-webpack-plugin-安裝"><a href="#purgecss-webpack-plugin-安裝" class="headerlink" title="purgecss-webpack-plugin 安裝"></a>purgecss-webpack-plugin 安裝</h2><blockquote>
<p>套件連結：<a href="https://purgecss.com/plugins/webpack.html" target="_blank" rel="external nofollow noopener noreferrer">purgecss-webpack-plugin</a>、<a href="https://www.npmjs.com/package/glob" target="_blank" rel="external nofollow noopener noreferrer">glob</a></p>
</blockquote>
<p>主要的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install purgecss-webpack-plugin glob -D</span><br></pre></td></tr></table></figure>

<p>過程會使用到的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install html-webpack-plugin css-loader mini-css-extract-plugin sass-loader node-sass postcss-loader autoprefixer -D ; npm install bootstrap jquery -P</span><br></pre></td></tr></table></figure>

<p>package.json：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"autoprefixer"</span>: <span class="string">"^9.7.5"</span>,</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^3.4.2"</span>,</span><br><span class="line">    <span class="attr">"glob"</span>: <span class="string">"^7.1.6"</span>,</span><br><span class="line">    <span class="attr">"html-webpack-plugin"</span>: <span class="string">"^4.0.3"</span>,</span><br><span class="line">    <span class="attr">"mini-css-extract-plugin"</span>: <span class="string">"^0.9.0"</span>,</span><br><span class="line">    <span class="attr">"node-sass"</span>: <span class="string">"^4.13.1"</span>,</span><br><span class="line">    <span class="attr">"postcss-loader"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    <span class="attr">"purgecss-webpack-plugin"</span>: <span class="string">"^2.1.0"</span>,</span><br><span class="line">    <span class="attr">"sass-loader"</span>: <span class="string">"^8.0.2"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.42.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"bootstrap"</span>: <span class="string">"^4.4.1"</span>,</span><br><span class="line">    <span class="attr">"jquery"</span>: <span class="string">"^3.4.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本篇將延續<strong><a href="https://awdr74100.github.io/2020-03-28-webpack-includebootstrap/">客製化 Bootstrap 樣式並進行編譯</a></strong>文章做說明，請先將專案所需套件進行安裝，為了更為方便操作 purgecss-webpack-plugin，此次也會同時引入 glob 套件，關於 glob 的使用方式，在下面會連同 purgecss-webpack-plugin 做說明。</p>
<h2 id="purgecss-webpack-plugin-基本使用"><a href="#purgecss-webpack-plugin-基本使用" class="headerlink" title="purgecss-webpack-plugin 基本使用"></a>purgecss-webpack-plugin 基本使用</h2><div class="note warning">本篇在前面會先介紹 purgecss-webpack-plugin 與 glob 的基本使用方式，關於清除 Bootstrap 多餘樣式的部分，將在後面做補充</div>

<p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── scss&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.scss     # SCSS 主檔案</span><br><span class="line">│   │</span><br><span class="line">│   ├─── index.html       # HTML 主檔案</span><br><span class="line">│   └─── main.js          # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── webpack.config.js    # Webpack 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure>

<p>至 <code>./src/scss/all.scss</code> 撰寫樣式：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-success</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-danger</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="comment">// 載入 purgecss-webpack-plugin (第一步)</span></span><br><span class="line"><span class="keyword">const</span> PurgecssPlugin = <span class="built_in">require</span>(<span class="string">'purgecss-webpack-plugin'</span>);</span><br><span class="line"><span class="comment">// 載入 glob (第二步)</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.s[ac]ss$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              plugins: [<span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)],</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">'sass-loader'</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/[name].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 創建實例 (第三步)</span></span><br><span class="line">    <span class="keyword">new</span> PurgecssPlugin(&#123;</span><br><span class="line">      <span class="comment">// 配置需解析檔案 (第四步)</span></span><br><span class="line">      paths: glob.sync(<span class="string">`<span class="subst">$&#123;path.resolve(__dirname, <span class="string">'src'</span>)&#125;</span>/**/*`</span>, &#123;</span><br><span class="line">        nodir: <span class="literal">true</span>, <span class="comment">// 過濾資料夾結果 (第五步)</span></span><br><span class="line">      &#125;),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>事實上，Webpack 的 Plugin 配置方式都大同小異，purgecss-webpack-plugin 也不例外，這邊比較特別的是 <code>paths</code> 這個可傳遞選項，此選項主要用於傳入需分析的檔案路徑，為了方便，這邊我們使用 glob 套件來匹配檔案路徑，我們可以嘗試開一個檔案並且引入 glob 模組試試看：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = glob.sync(<span class="string">`<span class="subst">$&#123;path.resolve(__dirname, <span class="string">'src'</span>)&#125;</span>/**/*`</span>, &#123;</span><br><span class="line">  nodir: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 編譯結果</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  'C:/Users/a7894/Desktop/webpack-demo/src/index.html',</span></span><br><span class="line"><span class="comment">  'C:/Users/a7894/Desktop/webpack-demo/src/main.js',</span></span><br><span class="line"><span class="comment">  'C:/Users/a7894/Desktop/webpack-demo/src/scss/all.scss'</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>從上面結果可以得知，glob 套件主要用於獲取指定匹配的檔案路徑，如果你有使用過 Gulp，因該很熟悉才對，因為 Gulp 的底層就是使用 glob 來獲取所要處理的檔案。當我們拿到所要分析的檔案路徑，就可以把這個路徑陣列丟給 <code>paths</code> 選項去做分析，這就是我們上面在做的事情。</p>
<p>至 <code>./src/index.html</code> 撰寫 HTML 模板範例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-primary"</span>&gt;</span>Primary<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>請注意，我們的 HTML 模板只有使用到 <code>.text-primary</code> 這個 class 樣式，並沒有使用到其他的 CSS 樣式，以合理的角度來說，這些沒有使用到的 CSS 都應該被 purgecss-webpack-plugin 移除掉才對。</p>
<p>entry 入口處 (<code>src/main.js</code>) 引入 SCSS 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./scss/all.scss'</span>;</span><br></pre></td></tr></table></figure>

<p>至 <code>package.json</code> 新增編譯指令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --mode development"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行編譯指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>此時打包生成的 <code>dist/css/main.css</code> 檔案內容如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是很神奇！沒有使用到的 CSS 樣式都被移除了，你可能在想，動態新增的樣式也可以被成功辨識嗎？會不會也被移除？讓我們直接來試試看。</p>
<p>修改 <code>./src/index.html</code> 模板範例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-primary"</span>&gt;</span>Primary<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Danger<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn"</span>&gt;</span>切換顏色<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>動態新增 class 樣式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路徑：./src/main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./scss/all.scss'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- toggleClass --- */</span></span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'.btn'</span>);</span><br><span class="line"><span class="keyword">const</span> str = <span class="built_in">document</span>.querySelector(<span class="string">'h1'</span>);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> className = <span class="string">'text-danger'</span>;</span><br><span class="line">  <span class="keyword">if</span> (str.classList.contains(className)) &#123;</span><br><span class="line">    str.classList.remove(className);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    str.classList.add(className);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>執行 <code>npm rum build</code> 並查看結果：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-danger</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>動態載入的樣式也難不倒 PurgeCSS，由於在配置 purgecss-webpack-plugin 時，我們也有傳入 JavaScript 檔案的路徑，這也就使 PurgeCSS 全部都幫我們分析完成了，如果當時沒有傳入檔案的路徑，可能就會發生遺漏樣式的問題，這點大家可以在自己測試看看。</p>
<h2 id="purgecss-webpack-plugin-可傳遞選項"><a href="#purgecss-webpack-plugin-可傳遞選項" class="headerlink" title="purgecss-webpack-plugin 可傳遞選項"></a>purgecss-webpack-plugin 可傳遞選項</h2><p>可參考 <a href="https://purgecss.com/plugins/webpack.html#options" target="_blank" rel="external nofollow noopener noreferrer">purgecss-webpack-plugin Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li><p>paths：<code>Array</code><br>指定要由 PurgeCSS 分析的檔案路徑，默認為 <code>null</code></p>
</li>
<li><p>whitelist：<code>Array</code><br>指定不該被刪除的 CSS 樣式 (具體名稱)，默認為 <code>null</code></p>
</li>
<li><p>whitelistPatterns：<code>Array</code><br>指定不該被刪除的 CSS 樣式 (正規表達式)，默認為 <code>null</code></p>
</li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PurgecssPlugin = <span class="built_in">require</span>(<span class="string">'purgecss-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> PurgecssPlugin(&#123;</span><br><span class="line">      paths: glob.sync(<span class="string">`<span class="subst">$&#123;path.resolve(__dirname, <span class="string">'src'</span>)&#125;</span>/**/*`</span>, &#123;</span><br><span class="line">        nodir: <span class="literal">true</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">      whitelist: [<span class="string">'a'</span>], <span class="comment">// a&#123;&#125;、.a&#123;&#125;、#a&#123;&#125; 相關樣式增加至白名單</span></span><br><span class="line">      whitelistPatternsChildren: [<span class="regexp">/^a/</span>], <span class="comment">// a&#123;&#125;、.a&#123;&#125;、#a&#123;&#125; 相關樣式增加至白名單</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="補充：清除多餘的-Bootstrap-樣式"><a href="#補充：清除多餘的-Bootstrap-樣式" class="headerlink" title="補充：清除多餘的 Bootstrap 樣式"></a>補充：清除多餘的 Bootstrap 樣式</h2><p>當我們了解 PurgeCSS 的處理流程，對於移除 Bootstrap 多餘樣式來說就沒什麼問題了，但其中還是有些小陷阱需要大家注意，讓我們直接開始吧！</p>
<p>至 <code>./src/scss/all.scss</code> 載入 Bootstrap：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* --- 客製化樣式 --- */</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'~bootstrap/scss/functions'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/variables'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'~bootstrap/scss/mixins'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- Bootstrap 主檔案 --- */</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'~bootstrap/scss/bootstrap'</span>;</span><br></pre></td></tr></table></figure>

<p>至 <code>./src/index.html</code> 新增 Bootstrap 元件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"navbar navbar-expand-lg navbar-light bg-light"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"navbar-brand"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Navbar<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"navbar-toggler"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">"button"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">data-toggle</span>=<span class="string">"collapse"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">data-target</span>=<span class="string">"#navbarSupportedContent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">aria-controls</span>=<span class="string">"navbarSupportedContent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">aria-expanded</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">aria-label</span>=<span class="string">"Toggle navigation"</span></span></span><br><span class="line"><span class="tag">      &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"navbar-toggler-icon"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"collapse navbar-collapse"</span> <span class="attr">id</span>=<span class="string">"navbarSupportedContent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"navbar-nav mr-auto"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"nav-item dropdown"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">"nav-link dropdown-toggle"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">href</span>=<span class="string">"#"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">id</span>=<span class="string">"navbarDropdown"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">role</span>=<span class="string">"button"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">data-toggle</span>=<span class="string">"dropdown"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">aria-haspopup</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">aria-expanded</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            &gt;</span></span><br><span class="line">              Dropdown</span><br><span class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dropdown-menu"</span> <span class="attr">aria-labelledby</span>=<span class="string">"navbarDropdown"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"dropdown-item"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Action<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"dropdown-item"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Another action<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dropdown-divider"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"dropdown-item"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Something else here<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>entry 入口處 (<code>src/main.js</code>) 引入 Bootstrap 所需模組：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./scss/all.scss'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bootstrap require</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'jquery'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'bootstrap/dist/js/bootstrap.bundle'</span>;</span><br></pre></td></tr></table></figure>

<p><code>webpack.config.js</code> 如同之前所配置，讓我們直接進行編譯並查看結果：</p>
<p><img src="https://i.imgur.com/MMlqUVD.png" alt="PurgeCSS 未分析 jquery 與 poopr"></p>
<p>此時你會發現動態載入的樣式並不存在 <code>dist/css/main.css</code> 內，聰明的你應該發現問題了，那就是 Bootstrap 依賴的 JavaScript 我們並沒有傳入去做分析，導致動態載入的代碼被移除了；解決方式也很簡單，那就是把他們通通傳入去做分析，這邊我們改使用 glob-all 套件取得多個檔案路徑：</p>
<blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/glob-all" target="_blank" rel="external nofollow noopener noreferrer">glob-all</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install glob-all -D</span><br></pre></td></tr></table></figure>

<p>glob-all 與 glob 套件使用方式大同小異，glob-all 可由陣列方式傳入匹配路徑，詳細可看官方文檔。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob-all'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> PurgecssPlugin(&#123;</span><br><span class="line">      paths: glob.sync(</span><br><span class="line">        [</span><br><span class="line">          <span class="string">`<span class="subst">$&#123;path.resolve(__dirname, <span class="string">'src'</span>)&#125;</span>/**/*`</span>,</span><br><span class="line">          path.resolve(__dirname, <span class="string">'node_modules/jquery/dist/jquery.slim.js'</span>),</span><br><span class="line">          path.resolve(__dirname, <span class="string">'node_modules/bootstrap/dist/js/bootstrap.bundle.js'</span>),</span><br><span class="line">        ],</span><br><span class="line">        &#123;</span><br><span class="line">          nodir: <span class="literal">true</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      ),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在這邊我們新增了 <code>bootstrap.bundle.js</code> 與 <code>jquery</code> 的檔案路徑用以讓 PurgeCSS 分析，再次執行編譯並查看結果：</p>
<p><img src="https://i.imgur.com/rkI1RWD.png" alt="PurgeCSS 成功分析 Bootstrap 的 CSS 與 JS"></p>
<p>大功告成！</p>
<h2 id="補充：PurifyCSS-線上縮減服務"><a href="#補充：PurifyCSS-線上縮減服務" class="headerlink" title="補充：PurifyCSS 線上縮減服務"></a>補充：PurifyCSS 線上縮減服務</h2><blockquote>
<p>連結：<a href="https://purifycss.online/" target="_blank" rel="external nofollow noopener noreferrer">PurifyCSS</a></p>
</blockquote>
<p>PurifyCSS 是一款基於 PurgeCSS 所設計的應用，可由線上分析方式提供優化後得代碼，以下為示範：</p>
<p><img src="https://i.imgur.com/pslx6K4.png" alt="PurifyCSS 服務"></p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Node.js</tag>
        <tag>Bootstrap</tag>
        <tag>w3HexSchool</tag>
        <tag>Webpack</tag>
        <tag>PurgeCSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 前端打包工具 - 使用 webpack-dev-server 實現以 Live Reload 或 HMR 方式進行開發</title>
    <url>/2020-03-26-webpack-webpackdevserver/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Gulp 的環境中，我們會導入 Browsersync 套件方便以 Live Reload 方式做開發，在 Webpack 中也有類似的套件，名為 webpack-dev-server，與傳統 Live Reload 工具較為不同的是，除了支援 Live Reload 方式以外，同時也支援 HMR (Hot Module Replacement) 特性，再不刷新 Browser 的情況下注入修改過後的代碼，達到不丟失應用狀態下即時更新畫面。此篇將介紹如何使用 webpack-dev-server 以 Live Reload 或 HMR 方式進行開發，途中也會補充 publicPath 與 contentBase 這兩個坑人的選項正確用法。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>webpack-dev-server 安裝</li>
<li>webpack-dev-server 基本使用</li>
<li>webpack-dev-server 可傳遞選項</li>
<li>補充：開啟 HMR 支持</li>
<li>補充：允許本地網路下設備進行訪問</li>
</ul>
<h2 id="webpack-dev-server-安裝"><a href="#webpack-dev-server-安裝" class="headerlink" title="webpack-dev-server 安裝"></a>webpack-dev-server 安裝</h2><blockquote>
<p>套件連結：<a href="https://github.com/webpack/webpack-dev-server" target="_blank" rel="external nofollow noopener noreferrer">webpack-dev-server</a></p>
</blockquote>
<p>主要的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install webpack-dev-server -D</span><br></pre></td></tr></table></figure>

<p>過程會使用到的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install css-loader html-webpack-plugin mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure>

<p>package.json：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^3.4.2"</span>,</span><br><span class="line">    <span class="attr">"html-webpack-plugin"</span>: <span class="string">"^4.0.3"</span>,</span><br><span class="line">    <span class="attr">"mini-css-extract-plugin"</span>: <span class="string">"^0.9.0"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.42.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span>,</span><br><span class="line">    <span class="attr">"webpack-dev-server"</span>: <span class="string">"^3.10.3"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>請先將一般開發環境所需的 loader 與 plugin 進行安裝，最後也必須安裝 webpack-dev-server 用以作為此次討論的目標。</p>
<h2 id="webpack-dev-server-基本使用"><a href="#webpack-dev-server-基本使用" class="headerlink" title="webpack-dev-server 基本使用"></a>webpack-dev-server 基本使用</h2><div class="note warning">此次範例會搭配 css-loader、html-webpack-plugin、mini-css-extract-plugin 一起使用，相關文章連結：<a href="https://awdr74100.github.io/2020-02-26-webpack-cssloader-styleloader/" target="_blank">css-loader</a>、<a href="https://awdr74100.github.io/2020-03-23-webpack-htmlwebpackplugin/" target="_blank">html-webpack-plugin</a>、<a href="https://awdr74100.github.io/2020-03-02-webpack-minicssextractplugin/" target="_blank">mini-css-extract-plugin</a></div>

<p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.css      # CSS 主檔案</span><br><span class="line">│   │</span><br><span class="line">│   └─── js&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.js       # JavaScript 主檔案</span><br><span class="line">│   │</span><br><span class="line">│   ├─── index.html       # HTML 主檔案</span><br><span class="line">│   └─── main.js          # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── webpack.config.js    # Webpack 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure>

<p>撰寫 CSS 範例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#2525b1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>撰寫 JavaScript 範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span><br></pre></td></tr></table></figure>

<p>至 <code>./src/index.html</code> 撰寫 HTML 模板範例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-primary"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div class="note warning">此段落不需要配置任何有關 webpack-dev-server 的設定</div>

<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/[name].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>你一定看過很多文章寫說需要配置 <code>devServer.contentBase</code> 選項，才能夠正確指定伺服器需啟動根目錄為何，這完全是錯誤的解釋，在上面範例中，我們沒有配置任何的 <code>devServer</code> 選項，全部都已預設方式配置，讓我們來看結果如何。</p>
<p>entry 入口處 (<code>src/main.js</code>) 引入 CSS、JavaScript 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./css/all.css'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./js/all'</span>;</span><br></pre></td></tr></table></figure>

<p>至 <code>package.json</code> 新增編譯指令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"webpack-dev-server --mode development"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --mode development"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>請注意上面指令的寫法，以往我們都是使用 <code>webpack</code> 來執行編譯，這邊可新增內容為 <code>webpack-dev-server</code> 的 <code>dev</code> 指令進行以 webpack-dev-server 開啟 localhost 的動作。</p>
<p>執行 <code>dev</code> 指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>手動輸入 <code>localhost:8080</code> 開啟本地伺服器：</p>
<p><img src="https://i.imgur.com/34bUNUB.png" alt="webpack-dev-server 開啟結果"></p>
<p>成功運行！我們可以從上面結果得知，使用 <code>webpack-dev-server</code> 能夠開啟一個本地伺服器，預設的 port 為 8080，且支援 Live Reload，你可以自由的更改 CSS、JavaScript、HTML 檔案，Browser 會自動刷新所有內容，以後都不用按 F5 囉。</p>
<p>此時你可能會去找 <code>dist</code> 的資料夾是否有成功編譯後的檔案，答案是沒有的，使用 webpack-dev-server 會將打包後的檔案暫存在記憶體內，並不會打包出實體的檔案，你可以把它想像成在記憶體內的 <code>dist</code> 資料夾，實體的 <code>dist</code> 資料夾結構為何，記憶體內的 <code>dist</code> 資料夾結構就為何；由於我們使用了 html-webpack-plugin 將指定模板進行打包，所以我們的實體/記憶體 <code>dist</code> 資料夾在根目錄就會有自動引入靜態檔案的 <code>index.html</code>，本地伺服器預設就是將這一個檔案進行載入，也就跑出了上面的畫面。</p>
<p>讓我們回來探討 webpack-dev-server 的 <code>devServer</code> 選項作用為何，請先新增以下內容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 其他省略</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: <span class="number">9000</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>port</code><ul>
<li>用來設定本地伺服器的端口，預設為 8080</li>
<li>命令列：webpack-dev-server <span>-</span><span>-</span>port 9000</li>
</ul>
</li>
<li><code>open</code><ul>
<li>伺服器啟動後是否自動打開瀏覽器，預設為 false</li>
<li>命令列：webpack-dev-server <span>-</span><span>-</span>open</li>
</ul>
</li>
</ul>
<p>上面這兩個選項蠻好理解的，且我平常也都會設定，免除手動開啟伺服器的困擾。讓我們來看其他選項：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 其他省略</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    publicPath: <span class="string">'/assets/'</span>,</span><br><span class="line">    contentBase: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>publicPath</code><ul>
<li>打包生成的靜態文件在記憶體中的位置 (若 devServer.publicPath 沒有設置，則參考 output.publicPath 的值，若兩者都沒有設置，預設為 <code>/</code> )</li>
</ul>
</li>
<li><code>contentBase</code><ul>
<li>告訴伺服器從何處提供原始內容。僅當你要提供靜態文件時才需要配置 (devServer.publicPath 優先於此選項使用，預設為當前執行目錄)</li>
</ul>
</li>
</ul>
<p>上面這兩個選項就有點抽象了，讓我們直接執行 <code>npm run dev</code> 查看結果：</p>
<p>位置：<code>localhost:8080</code></p>
<p><img src="https://i.imgur.com/y3LdnUC.png" alt="webpack-dev-server devServer.publicPath 無法取得"></p>
<p>位置：<code>localhost:8080/assets/</code></p>
<p><img src="https://i.imgur.com/SxB251Q.png" alt="webpack-dev-server devServer.publicPath 成功取得"></p>
<p>我們可以從上面結果得知，伺服器的存取位置被改變了，以下是模擬存在記憶體的資料夾結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">localhost&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── assets&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── main.css</span><br><span class="line">│   │</span><br><span class="line">│   └─── js&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── main.js</span><br><span class="line">│   │</span><br><span class="line">│   └─── index.html</span><br></pre></td></tr></table></figure>

<p>相信大家已經猜的到 <code>devServer.publicPath</code> 的功能了，它會在記憶體中的 <code>dist</code> 資料夾增加一層 <code>assets</code> 目錄，這也導致預設的 <code>localhost:8080</code> 找不到任何檔案，需要到下一層的目錄才找的到 <code>index.html</code> 這一支檔案，也就是 <code>localhost:8080/assets/</code> 內，這邊要注意的是如果你沒有配置 <code>devServer.publicPath</code> 選項，預設會向 <code>output.publicPath</code> 取值，如果兩者都沒有配置，預設值為 <code>/</code>，這也是為什麼一開始都沒有配置任何 <code>devServer</code> 選項時，能夠直接在 <code>localhost:8080</code> 看到畫面的原因。</p>
<p>至於 <code>devServer.contentBase</code> 是最常被誤解的選項，你可能看過很多人都是像上面範例一樣配置，但這樣子是完全沒有意義的，<code>devServer.contentBase</code> 主要用來使 webpack-dev-server 在開啟伺服器時如果找不到 <code>index.html</code> 檔案，就轉而載入指定的內容，像是範例中的 <code>dist</code> 資料夾，根本不存在這一個資料夾，載入時也就引發了 express 的 middleware 提示 (webpack-dev-server 是基於 Node.js 中的 express 建構出來)，這也是為什麼上面範例中 <code>localhost:8080</code> 會跳出 <code>Cannot GET /</code> 的原因，伺服器找不到存在於 <code>/</code> 的 <code>index.html</code> 檔案，轉而向 <code>devServer.contentBase</code> 取得內容，但根本不存在 <code>webpack-demo/dist</code> 這一個資料夾，導致同樣也找不到內容，就直接跳錯誤了，你可以嘗試把配置改成如下內容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: path.resolve(__dirname, <span class="string">'node_modules'</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index789.html'</span>, <span class="comment">// 將 index.html 改為 index789.html</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>位置：<code>localhost:8080</code></p>
<p><img src="https://i.imgur.com/mjYgGce.png" alt="webpack-dev-server devServer.contentPath 無法取得"></p>
<p>位置：<code>localhost:8080/index789.html</code></p>
<p><img src="https://i.imgur.com/XYo10pE.png" alt="webpack-dev-server devServer.contentPath 成功取得"></p>
<p>如同我們前面所講到的，<code>devServer.contentBase</code> 選項主要用來使伺服器在 <code>devServer.publicPath</code> 目錄下找不到 <code>index.html</code> 檔案時，轉而載入的內容，由於我們指定了 <code>node_modules</code> 目錄，這也就導致在 <code>localhost:8080</code> 根路徑時，載入的是 <code>node_modules</code> 目錄的內容，<code>localhost:8080/index789.html</code> 載入的才是正確內容。</p>
<p>經過了上面的介紹，相信各位已經了解 <code>devServer</code> 常見的配置了，當我們不配置 <code>publicPath</code> 與 <code>contentBase</code> 選項且 html-webpack-plugin 的 <code>filename</code> 為 <code>index.html</code> 時，伺服器取得的資料夾結構就如同實體編譯出來的資料夾結構，這也是為什麼當初不配置任何 <code>devServer</code> 選項能夠成功開啟伺服器並且指向正確目錄的原因。</p>
<h2 id="webpack-dev-server-可傳遞選項"><a href="#webpack-dev-server-可傳遞選項" class="headerlink" title="webpack-dev-server 可傳遞選項"></a>webpack-dev-server 可傳遞選項</h2><p>可參考 <a href="https://webpack.js.org/configuration/dev-server/#devserverstats-" target="_blank" rel="external nofollow noopener noreferrer">webpack-dev-server Configuration</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li><p>clientLogLevel：<code>silent</code> | <code>trace</code> | <code>debug</code> | <code>info</code> | <code>warn</code> | <code>error</code> | <code>none</code> | <code>warning</code><br>控制台需顯示何種狀態下的訊息，默認為 <code>info</code></p>
</li>
<li><p>compress：<code>Boolean</code><br>啟用 <a href="https://betterexplained.com/articles/how-to-optimize-your-site-with-gzip-compression/" target="_blank" rel="external nofollow noopener noreferrer">gzip</a> 壓縮，默認為 <code>false</code></p>
</li>
<li><p>overlay：<code>Boolean</code> | <code>Object: { errors : boolean, warnings : boolean}</code><br>出現錯誤或警告時，在瀏覽器全屏顯示內容，默認為 <code>false</code></p>
</li>
<li><p>stats：<code>none</code> | <code>errors-only</code> | <code>minimal</code> | <code>normal</code> | <code>verbose</code> | <code>Object</code><br>精準控制要顯示的 bundle 訊息，可使用集成配置或自訂配置，可參考 <a href="https://webpack.js.org/configuration/stats/" target="_blank" rel="external nofollow noopener noreferrer">stats 文檔</a>，默認為 <code>normal</code></p>
</li>
<li><p>host：<code>String</code><br>指定要使用的主機，默認為 <code>localhost</code></p>
</li>
<li><p>useLocalIp：<code>Boolean</code><br>使用本地 IP 打開瀏覽器，默認為 <code>false</code></p>
</li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    clientLogLevel: <span class="string">'silent'</span>,</span><br><span class="line">    compress: <span class="literal">true</span>,</span><br><span class="line">    overlay: <span class="literal">true</span>,</span><br><span class="line">    stats: <span class="string">'errors-only'</span>,</span><br><span class="line">    host: <span class="string">'0.0.0.0'</span>, <span class="comment">// 允許本地網路下設備進行訪問</span></span><br><span class="line">    useLocalIp: <span class="literal">true</span>, <span class="comment">// 直接以本地 IP 打開瀏覽器</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="補充：開啟-HMR-支持"><a href="#補充：開啟-HMR-支持" class="headerlink" title="補充：開啟 HMR 支持"></a>補充：開啟 HMR 支持</h2><p>在上面所有的操作中，我們都是以 Live Reload 方式進行，所謂的 Live Reload 就是只說在刷新瀏覽器時注入修改過後的代碼，達到即時更新的目的，雖然說已經很好用了，但是在某些情況下還是有點小抱怨，比如說 Live Reload 並不能夠保存應用的狀態 (states)，當刷新頁面後，應用之前的狀態也會丟失，因為它是以重新載入的方式處理修改過後的代碼，這在於某些情況下，真的很不方便，開發體驗也較差，你可以把它想像成傳統頁面與 SPA 頁面之間的差異。</p>
<p>也因為上面所提到的問題，webpack-dev-server 的出現就是為了解決這一個問題，它兼容 Live Reload 方式進行開發，同時也支援了 HMR (Hot Module Replacement) 方式開發，所謂的 HMR 就是指在不刷新畫面的狀態下，注入修改過後的代碼，你可以把它想像成在 Chrome 的開發者工具直接修改 Style 樣式一般，提供開發的體驗以及效率。Webpack 預設是使用 Live Reload，我們可透過配置方式開啟 HMR 功能，讓我們直接開始吧！</p>
<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    hot: <span class="literal">true</span>, <span class="comment">// 開啟 HMR 支持</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>當你啟用 <code>devServer.hot</code> 選項時，Webpack 會自動引入 <code>webpack.HotModuleReplacementPlugin</code>，代表說我們不需要手動引入這一個 Plugin，只需要單純的開啟 <code>hot</code> 選像即可。</p>
<p>entry 入口處 (<code>src/main.js</code>) 引入 HMR JavaScript API：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其他省略 ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 開啟 HMR 支持 (全部模組)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切記一定要在 entry 入口處增加上面這段代碼，以完全啟用 HMR 功能。</p>
<p>到了這邊我們可以先執行 <code>npm run dev</code> 查看結果：</p>
<p><img src="https://i.imgur.com/v4MnYuL.gif" alt="webpack-dev-server 開啟 HMR 支持"></p>
<p>以上測試是基於修改 <code>./src/js/all.js</code> 檔案而成，可以發現 HMR 確實成功啟用了，再不更新頁面的狀態下注入打包過後的新代碼，開發體驗提高不少，但這邊還有一個問題，就是修改 <code>./src/css/all.css</code> 檔案時，並沒有任何反應，那是因為我們還沒有開啟 mini-css-extract-plugin 的 HMR 支持，操作如下：</p>
<div class="note warning">style-loader 預設就已經開啟 HMR 支持，不需要特別做設定</div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: MiniCssExtractPlugin.loader,</span><br><span class="line">            options: &#123;</span><br><span class="line">              hmr: <span class="literal">true</span>, <span class="comment">// 開啟 HMR 支持</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>執行 <code>npm run dev</code> 查看結果：</p>
<p><img src="https://i.imgur.com/7qMS2rR.gif" alt="mini-css-extract-plugin 開啟 HMR 支持"></p>
<p>這邊還有一個最尷尬的情況，那就是 html-webpack-plugin 不支持 HMR 方式進行，這也是為什麼修改 <code>./src/index.html</code> 時完全沒有反應的原因，解決辦法就是將 index.html 當成 Live Reload 方式進行，操作如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.expores = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./src/index.html'</span>,</span><br><span class="line">    watchContentBase: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前面有講解到關於 <code>contentBase</code> 的使用技巧，而 <code>watchContentBase</code> 這一個選項就是用來更改 <code>contentBase</code> 作用的，當你開啟這一個選項，它會幫你監控指定目錄或檔案是否有更動，如果有，即刷新頁面。當然如果你使用的是像 vue-loader 等方式進行畫面渲染的話，就沒有這一個問題，因為都會通過 entry 入口處，而 html-webpack-plugin 是以抓取模板的方式進行處理，並不會通過 entry，這也導致了無法支援 HMR，說實在的，真的很可惜阿。</p>
<h2 id="補充：允許本地網路下設備進行訪問"><a href="#補充：允許本地網路下設備進行訪問" class="headerlink" title="補充：允許本地網路下設備進行訪問"></a>補充：允許本地網路下設備進行訪問</h2><p>這邊補充關於同個網路下的設備如何訪問 webpack-dev-server，這是一個我蠻常使用的技巧，好讓網站在正式上線前能夠透過不同裝置查看是否符合預期效果，在開始介紹之前，<strong>請確保你想訪問的設備與當前 webpack-dev-server 執行的設備在同個區網下</strong>，讓我們先從配置開始說明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.expores = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    host: <span class="string">'0.0.0.0'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>將 <code>host</code> 設置為 <code>0.0.0.0</code> 的目的在於監聽本機所有能訪問的 IP 地址，這邊你可以把它理解為將本機中的 <code>IPv4</code> 位址設為外部可訪問，此時開啟伺服器會跳出以下畫面：</p>
<p><img src="https://i.imgur.com/X79xFMt.png" alt="將 host 設為 0.0.0.0"></p>
<p>到這邊我們就已經成功一半了，剩下的一半為透過 <code>IPv4</code> 位址訪問伺服器，這邊我們可輸入 <code>ipconfig</code> 查詢 <code>IPv4</code> 位址：</p>
<p><img src="https://i.imgur.com/BdC2CuW.png" alt="查詢 IPv4 位址"></p>
<p>接著輸入 <code>IPv4</code> 位址與端口號碼即可訪問到伺服器：</p>
<p><img src="https://i.imgur.com/saCnIPI.png" alt="成功訪問到伺服器"></p>
<p>在同個網路下的設備也是透過這個 <code>IPv4</code> 位址與端口號碼訪問伺服器，如果你嫌上面步驟麻煩，也可設置 <code>useLocalIp</code> 選項：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.expores = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    host: <span class="string">'0.0.0.0'</span>,</span><br><span class="line">    useLocalIp: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>這樣它預設就會運行在本機中的 <code>IPv4</code> 位址，你也不需要特地去找 <code>IPv4</code> 位址，前面只是在告訴你如何尋找 <code>IPv4</code> 位址而已，通常我也是直接使用這一個選項，真正達到懶人的境界。</p>
<p>這邊補充關於前端在串接 API 時，同個網路下的設備可能發生的問題：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:3000&#x2F;login</span><br></pre></td></tr></table></figure>

<p>通常我們前端在開發時所串接的 API 都是跑在本地端的，雖然說直接以 deploy 上去的伺服器來串接會比較方便，但可能有耗損流量的問題，我自己是習慣跑在 <code>localhost</code> 就對了，這時候就得注意區網下設備是無法訪問到 <code>localhost</code> 的，因為 <code>localhost</code> 預設是指向 <code>127.0.0.1</code>，代表只有本機可以訪問，我們所要做的就是將 API 的位址更改為外部可訪問的位址，即前面的 <code>host</code> 設置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.listen(port, <span class="string">'0.0.0.0'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`開啟 port 為 <span class="subst">$&#123;port&#125;</span> 的 localhost`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>這邊拿 Express 來說明，上面是一個很基本的開啟 localhost 方法，第一個參數為 <code>port</code>，第二個參數為 <code>host</code>，將 <code>host</code> 設置為 <code>0.0.0.0</code> 即可與 webpack-dev-server 有同樣的效果，其實在 Express 不需要特別去做設置，因為預設的 <code>host</code> 就是 <code>0.0.0.0</code>，這邊只是要強調如何更改 <code>host</code> 選項而已，接著前端的 API 可改由以下訪問：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.1.107:3000&#x2F;login</span><br></pre></td></tr></table></figure>

<p>這邊就能避免本機可訪問 API，區網下設備無法訪問 API 的問題</p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 前端打包工具 - 依照指定環境挑選適合的 SourceMap 類型</title>
    <url>/2020-04-02-webpack-devtool/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相比於 Gulp 需使用套件才能生成 SourceMap，Webpack 只需簡單的開啟 devtool 選項即可生成 SourceMap，且提供了多達 10 種以上的類型供開發者使用，簡直太強大。此篇將介紹如何在 Webpack 開啟 devtool 選項用以生成 SourceMap，並說明在各式 SourceMap 類型下，該如何針對 development (開發環境) 與 production (生產環境) 做最合適的挑選。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>相關套件安裝</li>
<li>初始環境建構</li>
<li>sourcemap 類型差異</li>
<li>sourcemap 類型結論</li>
<li>sass-loader 開啟 sourcemap 支援</li>
<li>postcss-loader 開啟 sourcemap 支持</li>
</ul>
<h2 id="相關套件安裝"><a href="#相關套件安裝" class="headerlink" title="相關套件安裝"></a>相關套件安裝</h2><p>過程會使用到的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install babel-loader @babel/core @babel/preset-env @babel/plugin-transform-runtime clean-webpack-plugin html-webpack-plugin webpack webpack-cli webpack-dev-server -D ; npm install @babel/runtime-corejs3 -P</span><br></pre></td></tr></table></figure>

<p>package.json：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"@babel/core"</span>: <span class="string">"^7.9.0"</span>,</span><br><span class="line">    <span class="attr">"@babel/plugin-transform-runtime"</span>: <span class="string">"^7.9.0"</span>,</span><br><span class="line">    <span class="attr">"@babel/preset-env"</span>: <span class="string">"^7.9.0"</span>,</span><br><span class="line">    <span class="attr">"babel-loader"</span>: <span class="string">"^8.1.0"</span>,</span><br><span class="line">    <span class="attr">"clean-webpack-plugin"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    <span class="attr">"html-webpack-plugin"</span>: <span class="string">"^4.0.4"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.42.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span>,</span><br><span class="line">    <span class="attr">"webpack-dev-server"</span>: <span class="string">"^3.10.3"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"@babel/runtime-corejs3"</span>: <span class="string">"^7.9.2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Webpack 中生成 sourcemap 不需要安裝任何套件，配置即可使用，但為了模擬一般開發情境，請先安裝過程所需套件，避免可能造成的疑惑，同時也請安裝 babel-loader 相關套件，主要用來模擬 sourcemap 所謂的<strong>打包後代碼</strong>、<strong>轉換後代碼</strong>、<strong>原始源代碼</strong>情境。</p>
<h2 id="初始環境建構"><a href="#初始環境建構" class="headerlink" title="初始環境建構"></a>初始環境建構</h2><p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── js&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.js       # JavaScript 主檔案</span><br><span class="line">│   │</span><br><span class="line">│   ├─── index.html       # HTML 主檔案</span><br><span class="line">│   └─── main.js          # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── webpack.config.js    # Webpack 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure>

<p>至 <code>./src/index.html</code> 撰寫 HTML 模板範例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>至 <code>./src/js/all.js</code> 撰寫 JavaScript 範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'Roya'</span>, <span class="string">'Eric'</span>, <span class="string">'Owen'</span>];</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">  str += <span class="string">`&lt;li&gt;序位 <span class="subst">$&#123;key + <span class="number">1</span>&#125;</span>，姓名為 <span class="subst">$&#123;value&#125;</span>&lt;/li&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 檢查是否正確</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.list'</span>).innerHTML = str;</span><br></pre></td></tr></table></figure>

<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/[name].[hash].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: <span class="number">9000</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            presets: [<span class="string">'@babel/preset-env'</span>],</span><br><span class="line">            plugins: [</span><br><span class="line">              [</span><br><span class="line">                <span class="string">'@babel/plugin-transform-runtime'</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                  corejs: <span class="number">3</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">              ],</span><br><span class="line">            ],</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>entry 入口處 (<code>src/main.js</code>) 引入 JavaScript 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./js/all'</span>;</span><br></pre></td></tr></table></figure>

<p>至 <code>package.json</code> 新增編譯指令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"webpack-dev-server"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sourcemap-類型差異"><a href="#sourcemap-類型差異" class="headerlink" title="sourcemap 類型差異"></a>sourcemap 類型差異</h2><p>sourcemap 的生成主要依靠 devtool 選項，讓我們先來看官方是如何介紹的：</p>
<table>
<thead>
<tr>
<th>devtool</th>
<th>建構速度</th>
<th>重新建構速度</th>
<th>是否生成 <code>.map</code> 檔案</th>
<th>品質 (指向)</th>
</tr>
</thead>
<tbody><tr>
<td>false</td>
<td>+++</td>
<td>+++</td>
<td>no</td>
<td>打包後的代碼</td>
</tr>
<tr>
<td>eval</td>
<td>+++</td>
<td>+++</td>
<td>no</td>
<td>生成後的代碼</td>
</tr>
<tr>
<td>cheap-eval-source-map</td>
<td>+</td>
<td>++</td>
<td>no</td>
<td>轉換過的代碼 (僅限行)</td>
</tr>
<tr>
<td>cheap-module-eval-source-map</td>
<td>○</td>
<td>++</td>
<td>no</td>
<td>原始源代碼 (僅限行)</td>
</tr>
<tr>
<td>eval-source-map</td>
<td>–</td>
<td>+</td>
<td>no</td>
<td>原始源代碼</td>
</tr>
<tr>
<td>cheap-source-map</td>
<td>+</td>
<td>○</td>
<td>yes</td>
<td>轉換過的代碼 (僅限行)</td>
</tr>
<tr>
<td>cheap-module-source-map</td>
<td>○</td>
<td>-</td>
<td>yes</td>
<td>原始源代碼 (僅限行)</td>
</tr>
<tr>
<td>source-map</td>
<td>–</td>
<td>–</td>
<td>yes</td>
<td>原始源代碼</td>
</tr>
<tr>
<td>hidden-source-map</td>
<td>–</td>
<td>–</td>
<td>yes</td>
<td>原始源代碼</td>
</tr>
<tr>
<td>nosources-source-map</td>
<td>–</td>
<td>–</td>
<td>yes</td>
<td>無原始源代碼內容</td>
</tr>
</tbody></table>
<div class="note warning">+++ 非常快速，++ 快速，+，較快，○ 普通，- 偏慢，-- 很慢</div>

<p>當初看到這個圖表，整個人很矇，完全不知道在寫什麼，經過了反覆的測試，發現其實重點可放在每一個 sourcemap 的品質 (指向)，讓我們舉幾個簡單的例子：</p>
<p>將 <code>devtool</code> 設為 <code>false</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devtool: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>編譯並查看 console 指向結果：</p>
<p><img src="https://i.imgur.com/3OdWBeO.png" alt="將 devtool 設為 false"></p>
<p>從上面結果會發現，當我們把 <code>devtool</code> 設為 <code>false</code> 時，console 的指向為<strong>打包後的代碼</strong>，也就是 <code>dist/js/main.js</code> 中，代表不使用任何的 sourcemap 類型，通常不會有人選擇配置此選項，雖然看起來代碼的指向是我們預期的，但它指向的可是打包生成的 <code>main.js</code> 檔案阿！<strong>行數肯定是不正確的</strong>，同時也無法追蹤是哪一個原始模組發出提示或警告的問題。</p>
<p>將 <code>devtool</code> 設為 <code>eval</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devtool: <span class="string">'eval'</span>, <span class="comment">// production 環境下，此類型為預設值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>編譯並查看 console 指向結果：</p>
<p><img src="https://i.imgur.com/fPMm0mN.png" alt="將 devtool 設為 eval"></p>
<p>從上面結果可以得知，當我們把 <code>devtool</code> 選項設為 <code>eval</code> 時，console 的指向為<strong>生成後的代碼</strong>，你會看到一堆類似 <code>var xxx_WEBPACK_IMPORTED_MODULE_X</code> 的宣告，<strong>因為它並沒有從 loader 獲取 sourcemap，造成行數顯示錯誤</strong>，此類型不適合我們在 development 環境使用。</p>
<p>將 <code>devtool</code> 設為 <code>cheap-eval-source-map</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devtool: <span class="string">'cheap-eval-source-map'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>編譯並查看 console 指向結果：</p>
<p><img src="https://i.imgur.com/Y9alATh.png" alt="將 devtool 設為 cheap-eval-source-map"></p>
<p>從上面結果可以得知，當我們把 <code>devtool</code> 選項設為 <code>cheap-eval-source-map</code> 時，console 的指向為<strong>轉換過的代碼</strong>，你可以把它想像成已經被 babel-loader 與 corejs 處理過後的代碼，但裡面 <code>import</code> 的模組還尚未被解析，類似 Gulp 使用相同套件的編譯結果，此類型同樣不適合我們在 development 環境使用，最好的指向因該是直接呈現我們放在 <code>src/js/all.js</code> 的檔案內容才對。</p>
<p>將 <code>devtool</code> 設為 <code>cheap-module-eval-source-map</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devtool: <span class="string">'cheap-module-eval-source-map'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>編譯並查看 console 指向結果：</p>
<p><img src="https://i.imgur.com/ApIHjDg.png" alt="將 dedvtool 設為 cheap-module-eval-source-map"></p>
<p>從上面結果可以得知，當我們把 <code>devtool</code> 選項設為 <code>cheap-module-eval-source-map</code> 時，console 的指向為<strong>原始源代碼</strong>，也就是 <code>src/js/all.js</code> 檔案內容，使類型非常適合我們在 development 環境使用，兼具速度與其指向正確性，但這邊要注意的是，<strong>此類型的 sourcemap 選項只包含行的指向，並不包含列的指向</strong>，如果有列指向的需求，可使用 <code>eval-source-map</code>。</p>
<p>將 <code>devtool</code> 設為 <code>eval-source-map</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devtool: <span class="string">'eval-source-map'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>編譯並查看 console 指向結果：</p>
<p><img src="https://i.imgur.com/DS7n0Bq.png" alt="將 devtool 設為 eval-source-map"></p>
<p><code>eval-source-map</code> 類型與 <code>cheap-module-eval-source-map</code> 大同小異，差別在於 <code>eval-source-map</code> 連同列也幫我們做了指向，可仔細觀察兩者鼠標的指向，通常我們不太會在意列的指向，畢竟行的指向已經能夠幫我們找出原始資料的位置了，除非你懶得再指向的行找尋目標，那 <code>eval-source-map</code> 會很適合你，不過我建議在 development 環境使用 <code>cheap-module-eval-source-map</code> 就夠了，清楚的指向原始源資料，速度也不會太差。</p>
<h2 id="sourcemap-類型結論"><a href="#sourcemap-類型結論" class="headerlink" title="sourcemap 類型結論"></a>sourcemap 類型結論</h2><p>當我們在 development 環境選擇 sourcemap 類型時，最先該追求的是指向的正確性，像是 <code>eval</code> 與 <code>cheap-eval-source-map</code> 類型就較不符合，選擇 <code>cheap-module-eval-source-map</code> 與 <code>eval-source-map</code> 類型才是王道，其次追求的是重新建構的速度，通常在開發時，我們會反覆的進行測試，這點就顯得極為重要。</p>
<ul>
<li>development 環境最佳選擇為 <code>cheap-module-eval-source-map</code></li>
</ul>
<p>以上介紹的 sourcemap 類型都不會生成實體 <code>.map</code> 檔案，也因為這個原因，才使得每一類型速度都不會太差，在 production 環境我們需要有實體的 <code>.map</code> 檔案，用以讓開發者在需要 sourcemap 時才進行加載，藉此解決 <code>bundle.js</code> 因 sourcemap 附加在檔案內造成體積過大的問題，這邊我不推薦任何有關 <code>inline</code> 的 sourcemap 類型，原理如同 url-loader 額度設定太高一樣。</p>
<ul>
<li>production 環境推薦可使用 <code>source-map</code>、<code>hidden-source-map</code>、<code>nosources-source-map</code></li>
</ul>
<hr>
<p>備註：</p>
<ul>
<li>在 Webpack 4 中，development 環境預設 sourcemap 類型為 <code>eval</code></li>
<li>在 Webpack 4 中，production 環境預設 sourcemap 類型為 <code>false</code></li>
</ul>
<h2 id="sass-loader-開啟-sourcemap-支援"><a href="#sass-loader-開啟-sourcemap-支援" class="headerlink" title="sass-loader 開啟 sourcemap 支援"></a>sass-loader 開啟 sourcemap 支援</h2><p>在前面我們都是針對 JavaScript 開啟 sourcemap 支援，想必大家更為好奇的應該是如何開啟 Sass/SCSS 的 sourcemap 支援吧？開啟方式相當的簡單，讓我們先將專案結構更改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── scss&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── component</span><br><span class="line">│           │</span><br><span class="line">│           └─── _card.scss</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.scss     # SCSS 主檔案</span><br><span class="line">│   │</span><br><span class="line">│   ├─── index.html       # HTML 主檔案</span><br><span class="line">│   └─── main.js          # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── webpack.config.js    # Webpack 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure>

<p>安裝 sass-loader、css-loader、style-loader 相關套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install sass-loader node-sass css-loader style-loader -D</span><br></pre></td></tr></table></figure>

<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devtool: <span class="literal">false</span>,</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/[name].[hash].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: <span class="number">9000</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.s[ac]ss$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: <span class="literal">true</span>, <span class="comment">// 開啟 sourcemap 支持</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: <span class="literal">true</span>, <span class="comment">// 開啟 sourcemap 支持</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sass-loader 搭配 style-loader 開啟 sourceMap 相對簡單，只需要開啟除了 style-loader 以外的 <code>sourcecMap</code> 選項即可，這邊要注意的是，sass-loader 搭配 style-loader 是不受 <code>devtool</code> 選項控制的，如果你將 <code>devtool</code> 設為 <code>false</code>，一樣也能生成 sourcemap，結果如下：</p>
<p><img src="https://i.imgur.com/s7MjSkR.png" alt="sass-loader 搭配 style-loader 開啟 sourcemap 支持"></p>
<p>接下來換 sass-loader 搭配 mini-css-extract-plugin，請先安裝套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure>

<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devtool: <span class="string">'source-map'</span>, <span class="comment">// 只有此類型的 sourcemap 完全支援</span></span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/[name].[hash].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: <span class="number">9000</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.s[ac]ss$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: <span class="literal">true</span>, <span class="comment">// 開啟 sourcemap 支持</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: <span class="literal">true</span>, <span class="comment">// 開啟 sourcemap 支持</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/[name].[hash].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sass-loader 搭配 mini-css-extract-plugin 同樣開啟除了 mini-css-extract-plugin 的 <code>sourceMap</code> 選項即可支持 sourcemap，但與 style-loader 不同的地方在於，mini-css-extract-plugin 會受到 <code>devtool</code> 選項影響生成，在這邊必須選擇 <code>source-map</code> 類型才能正確生成 sourcemap，效果如下：</p>
<p><img src="https://i.imgur.com/s7MjSkR.png" alt="sass-loader 搭配 style-loader 開啟 sourcemap 支持"></p>
<h2 id="postcss-loader-開啟-sourcemap-支持"><a href="#postcss-loader-開啟-sourcemap-支持" class="headerlink" title="postcss-loader 開啟 sourcemap 支持"></a>postcss-loader 開啟 sourcemap 支持</h2><p>如果你的專案有導入 PostCSS，一樣開啟 <code>sourceMap</code> 選項即可獲得 sourcemap 支持，配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devtool: <span class="string">'source-map'</span>,</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/[name].[hash].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: <span class="number">9000</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.s[ac]ss$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: <span class="literal">true</span>, <span class="comment">// 開啟 sourcemap 支持</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              plugins: [<span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)],</span><br><span class="line">              sourceMap: <span class="literal">true</span>, <span class="comment">// 開啟 sourcemap 支持</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: <span class="literal">true</span>, <span class="comment">// 開啟 sourcemap 支持</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/[name].[hash].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 前端打包工具 - 使用 SplitChunksPlugin 抽離公用模組</title>
    <url>/2020-04-06-webpack-splitchunksplugin/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般在做各種開發時，我們很常引入一些 npm 套件加快功能的實現，比如說 AJAX 行為就很適合使用 axios 套件來完成，當我們使用 Webpack 進行打包時，相關的 npm 套件也會通通被打包進 bundle.js 內，但這樣的行為對效能來說是較不友善的，原因為 bundle.js 實在是太肥大了，正確的作法應該是將 node_modules 內的模組單獨打包成一個檔案，避免載入時間過長的問題。此篇將介紹如何使用 SplitChunksPlugin 抽離 node_modules 內模組使之成為獨立的檔案，後面也會介紹當我們在開發多頁式應用時，如何以 SplitChunksPlugin 抽離公用模組用以解決重複程式碼的問題。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>相關套件安裝</li>
<li>SplitChunksPlugin 基本使用</li>
<li>SplitChunksPlugin 可傳遞選項</li>
<li>補充：Dynamic import()</li>
<li>補充：解決 MPA 所造成的重複代碼問題</li>
<li>補充：抽離 Webpack 運行時代碼</li>
</ul>
<h2 id="相關套件安裝"><a href="#相關套件安裝" class="headerlink" title="相關套件安裝"></a>相關套件安裝</h2><p>過程會使用到的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install html-webpack-plugin clean-webpack-plugin webpack webpack-cli -D ; npm install axios -P</span><br></pre></td></tr></table></figure>

<p>package.json：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"clean-webpack-plugin"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    <span class="attr">"html-webpack-plugin"</span>: <span class="string">"^4.0.4"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.42.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"axios"</span>: <span class="string">"^0.19.2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Webpack 4 中，SplitChunksPlugin 已預設裝載，我們不需要進行任何安裝動作，配置即可使用，事實上，SplitChunksPlugin 本身就已經開啟了，但預設配置是針對較為”特別”的情境才有作用，這才導致我們沒有感覺 SplitChunksPlugin 已經作用在當前還環境，為了保證結果如同預期，請先安裝上面所陳列的相關套件。</p>
<h2 id="SplitChunksPlugin-基本使用"><a href="#SplitChunksPlugin-基本使用" class="headerlink" title="SplitChunksPlugin 基本使用"></a>SplitChunksPlugin 基本使用</h2><p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── js&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       ├─── a.js         # JavaScript 模組 (1)</span><br><span class="line">│       └─── b.js         # JavaScript 模組 (2)</span><br><span class="line">│   │</span><br><span class="line">│   ├─── index.html       # HTML 主檔案</span><br><span class="line">│   └─── main.js          # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── webpack.config.js    # Webpack 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure>

<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// optimization.splitChunks 預設配置</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'async'</span>,</span><br><span class="line">      minSize: <span class="number">30000</span>,</span><br><span class="line">      <span class="comment">// minRemainingSize: 0, (Webpack 5 才有此選項)</span></span><br><span class="line">      maxSize: <span class="number">0</span>,</span><br><span class="line">      minChunks: <span class="number">1</span>,</span><br><span class="line">      maxAsyncRequests: <span class="number">6</span>,</span><br><span class="line">      maxInitialRequests: <span class="number">4</span>,</span><br><span class="line">      automaticNameDelimiter: <span class="string">'~'</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          priority: <span class="number">-10</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          priority: <span class="number">-20</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>SplitChunksPlugin 不需要進行下載，直接可在 <code>optimization</code> 選項內進行配置，在前面有說過 Webpack 預設是有開啟 SplitChunksPlugin 的，但只針對”特殊”情境才有作用，這點下面會在說明，讓我們繼續完成編譯動作。</p>
<p>entry 入口處 (<code>src/main.js</code>) 引入 JavaScript 模組：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./js/a'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./js/b'</span>;</span><br></pre></td></tr></table></figure>

<p>JavaScript 模組 (1)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br></pre></td></tr></table></figure>

<p>JavaScript 模組 (2)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br></pre></td></tr></table></figure>

<p>至 <code>package.json</code> 新增編譯指令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --mode development"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行編譯指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>此時打包生成的 <code>dist</code> 資料夾結構如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── main.js</span><br><span class="line">│   └─── index.html</span><br></pre></td></tr></table></figure>

<p>過程如同之前所介紹的，什麼事都沒有發生，讓我們將 SplitChunksPlugin 配置更改如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'initial'</span>, <span class="comment">// 全域配置</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再次執行編譯並查看結果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── vendors~main.js</span><br><span class="line">│   ├─── main.js</span><br><span class="line">│   └─── index.html</span><br></pre></td></tr></table></figure>

<p>此刻的你一定很錯亂，怎會突然新增了一個名為 <code>vendors~main.js</code> 的檔案，且檔案內容正好是 node_modules 內的相關模組 (此為 axios 套件)，太神奇了吧！讓我們先從剛剛修改的 <code>chunks</code> 選項開始說起：</p>
<ul>
<li>chunks：<code>async</code> | <code>initial</code> | <code>all</code><br>選擇那些類型的 chunk 是需要被優化的，默認為 <code>async</code></li>
</ul>
<p>當初我在認識 <code>chunks</code> 選項時，是直接以實作的方式去學習，因為官方文檔完全說的不清不楚阿！且如果你搜尋相關的文章，你會發現大部分都是直接翻譯官方文檔，我完全不懂這樣子的意義在哪？經過了反覆的嘗試，得出以下結論：</p>
<ul>
<li><code>async</code>：只處理 <a href="https://webpack.js.org/guides/lazy-loading/" target="_blank" rel="external nofollow noopener noreferrer">Lazy Loading</a> 的 chunks，例如 <code>import(xxx)</code> 語法載入的模組</li>
<li><code>initial</code>：只處理同步加載的 chunk，例如 <code>import xxx</code> 語法載入的模組</li>
<li><code>all</code>：兼容以上兩種方式，通通進行處理</li>
</ul>
<p>我們在 entry 內的所有模組都是使用 <code>import</code> 方式進行載入，這才導致 SplitChunksPlugin 在預設配置下沒有任何反應，因為 <code>chunks</code> 預設配置是 <code>async</code>，關於 <code>async</code> 的實際應用將會在下面補充介紹。理解了 <code>chunks</code> 是做什麼用，接下來換最為重要的 <code>cacheGroups</code> 選項部分：</p>
<ul>
<li><code>cacheGroups</code>：定義 chunks 所屬的緩存組</li>
<li><code>{cacheGroups}</code>：緩存組名稱，可由 <code>name</code> 屬性更改</li>
<li><code>cacheGroups.{cacheGroups}.priority</code>：緩存組優先級，默認為 <code>0</code></li>
<li><code>cacheGroups.{cacheGroups}.test</code>：控制當下緩存組匹配的 chunk，省略它會選擇所有 chunk</li>
<li><code>cacheGroups.{cacheGroups}.filename</code>：僅當 chunk 為同步加載時，才允許覆蓋文件名</li>
<li><code>cacheGroups.{cacheGroups}.enforce</code>：忽略全域的<a href="https://webpack.js.org/plugins/split-chunks-plugin/#splitchunkscachegroupscachegroupenforce" target="_blank" rel="external nofollow noopener noreferrer">部分選項</a></li>
</ul>
<p><code>cacheGroups</code> 選項是使用 SplitChunksPlugin 成功與否的關鍵，這邊要注意的是上面提到的選項，都是 <code>cacheGroups</code> 專屬可配置的區域選項，有沒有注意到我說的是區域選項？事實上，<code>cacheGroups</code> 同層的選項都是屬於全域選項，也就是說你也可以在 <code>cacheGroups</code> 內配置 <code>chunks</code> 選項，一樣可以作用，且預設就已提供兩個 <code>cacheGroups</code> 供我們使用，為什麼前面單純的將 <code>chunks</code> 選項更改為 <code>initial</code> 就可以將 node_modules 內的模組抽離成獨立檔案，答案是不是呼之欲出了？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'initial'</span>, <span class="comment">// 將 async 改為 initial</span></span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          priority: <span class="number">-10</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          priority: <span class="number">-20</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>沒錯！就是依靠預設配置的 <code>vendors</code> 這一個 <code>cacheGroups</code>，為什麼之前採預設配置都沒有反應，就是因為 <code>vendors</code> 參考的全域 <code>chunks</code> 配置屬性為 <code>async</code>，但我們是採用同步加載方式引入模組，當然會沒有反應，此時將 <code>chunks</code> 改為 <code>initial</code> 即可正常啟動抽離 chunk 的動作，但一般我們並不會使用預設的 <code>cacheGroups</code>，通常都會新增客製的 <code>cacheGroups</code> 做使用，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          chunks: <span class="string">'initial'</span>,</span><br><span class="line">          name: <span class="string">'vendors'</span>,</span><br><span class="line">          enforce: <span class="literal">true</span>,</span><br><span class="line">          priority: <span class="number">10</span>, <span class="comment">// 預設為 0，必須大於預設 cacheGroups</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面是一個抽離 node_modules 相關模組使之成為獨立檔案的標準寫法，我們並沒有更改預設的全域配置，直接以區域配置進行客製化，將符合正規表達式的 chunk 抽離出來，且 chunk 的載入方式須為同步載入，忽略全域的部分選項，最後將 chunk 名稱更改為 vendors，此時的編譯結果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── vendors.js</span><br><span class="line">│   ├─── main.js</span><br><span class="line">│   └─── index.html</span><br></pre></td></tr></table></figure>

<p>大功告成！如果 entry 內有任何引入 node_modules 模組的檔案，此模組都會被單獨打包進 vendors.js 內，如果你想要針對特定檔案進行抽離，只需要在正規表達式做撰寫即可，你也可以新增不同的 <code>cacheGroups</code> 專門針對不同要求做打包，優化整體的檔案結構。</p>
<p>介紹到這邊，已經把最重要的 <code>cacheGroups</code> 與 <code>chunks</code> 屬性給釐清了，可能有人會問，那其他的屬性呢？像是 <code>minSize</code>、<code>maxSize</code>、<code>minChunks</code> 等等，是做什麼用的？事實上，這幾個選項就如同字面上的意思，舉個例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      minSize: <span class="number">70000</span>, <span class="comment">// 限制最小大小 ( byte )</span></span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          chunks: <span class="string">'initial'</span>,</span><br><span class="line">          name: <span class="string">'vendors'</span>,</span><br><span class="line">          enforce: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面這種寫法是不影響 vendors 這個 <code>cacheGroups</code> 的，因為我們啟用了 <code>enforce</code> 選項，代表不參考全域的屬性，正確的寫法應該如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          chunks: <span class="string">'initial'</span>,</span><br><span class="line">          name: <span class="string">'vendors'</span>,</span><br><span class="line">          enforce: <span class="literal">true</span>,</span><br><span class="line">          minSize: <span class="number">70000</span>, <span class="comment">// 限制最小大小 ( byte )</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此時如果 node_modules 內的套件並沒有超過 70 KB，也就不會進入這一個 <code>cacheGroups</code>，自然就不會產生 vendors 這個檔案，各位可自行試試看剩餘這這些選項，其實都大同小異，最重要的 <code>cacheGroups</code> 與 <code>chunks</code> 觀念學會比較重要。</p>
<h2 id="SplitChunksPlugin-可傳遞選項"><a href="#SplitChunksPlugin-可傳遞選項" class="headerlink" title="SplitChunksPlugin 可傳遞選項"></a>SplitChunksPlugin 可傳遞選項</h2><p>可參考 <a href="https://webpack.js.org/plugins/split-chunks-plugin/" target="_blank" rel="external nofollow noopener noreferrer">SplitChunksPlugin Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li><p>automaticNameDelimiter：<code>String</code><br>指定用於生成名稱的連結符號，默認為 <code>~</code></p>
</li>
<li><p>minChunks：<code>Number</code><br>在做抽離代碼動作前，chunks 的最小引用次數，默認為 <code>1</code></p>
</li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      automaticNameDelimiter: <span class="string">'@'</span>,</span><br><span class="line">      minChunks: <span class="number">2</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="補充：Dynamic-import"><a href="#補充：Dynamic-import" class="headerlink" title="補充：Dynamic import()"></a>補充：Dynamic import()</h2><p>在前面有提到 <code>chunks</code> 選項預設的 <code>async</code> 不太適合我們當前的使用情境，因為我們是以靜態的方式載入模組，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./js/a'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./js/b'</span>;</span><br></pre></td></tr></table></figure>

<p>這次我們來介紹如何動態載入模組，並搭配 <code>async</code> 選項做使用，請先將 entry 入口處更改如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 靜態載入</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>; <span class="comment">// 請記得安裝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 動態載入</span></span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: 'a' */</span> <span class="string">'./js/a'</span>);</span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: 'b' */</span> <span class="string">'./js/b'</span>);</span><br></pre></td></tr></table></figure>

<p>有別於使用 <code>import</code> 靜態載入模組，<code>import()</code> 在某些情況下可能帶來更高的效能，這邊要注意的是，必須以上面的寫法來載入模組，註解處是用已告知此模組的 chunkName，如果把註解給移除，預設的 chunkName 為數字，較為不直覺，建議還是直接定義 chunkName 比較好，</p>
<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>這邊就只是單純的配置相關選項，前面有提到 <code>chunks</code> 預設的值為 <code>async</code>，我們不需要進行任何配置，預設就以作用 vendors 這一個 <code>cacheGroups</code>，讓我們直接進行編譯看看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── a.js</span><br><span class="line">│   ├─── b.js</span><br><span class="line">│   ├─── vendors~a~b.js</span><br><span class="line">│   ├─── main.js</span><br><span class="line">│   └─── index.html</span><br></pre></td></tr></table></figure>

<p>從編譯結果可以得知，確實 node_modules 內的 axios 套件被抽離成 <code>vendors~a~b.js</code> 檔案，因為 <code>a.js</code> 與 <code>b.js</code> 是以動態載入的方式引入模組，檔案內的模組也就跟著作用，這邊有一點要注意的是，你會發現動態載入的模組也被抽離成獨立檔案了，這是基於 Webpack 預設的配置，與 SplitChunksPlugin 沒有關係。</p>
<p>上面就是預設配置的 <code>async</code> 結果，眼尖的朋友應該發現其中的問題了，那就是 jQuery 也被打包進 main.js 內了，並沒有被抽離出來，原理如同之前所介紹的，SplitChunksPlugin 預設配置的 <code>async</code> 只針對動態載入的模組，如果我們需要同時處理動態與非動態載入的模組，可使用 <code>all</code> 選項，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'all'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此時的編譯結果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   ├─── a.js</span><br><span class="line">│   ├─── b.js</span><br><span class="line">│   ├─── vendors~a~b.js   # 非同步載入的 axios 套件</span><br><span class="line">│   ├─── vendors~main.js  # 同步載入的 jquery 套件</span><br><span class="line">│   ├─── main.js</span><br><span class="line">│   └─── index.html</span><br></pre></td></tr></table></figure>

<p>從上面結果可以得知，node_modules 內的模組都已經被抽離成獨立檔案了，因為 <code>all</code> 選項會同時處理動態與非動態載入的模組，你可能現在在想，為什麼 SplitChunksPlugin 預設的 <code>chunks</code> 選項不直接設為 <code>all</code> 呢？就不用這麼麻煩了啊！我是認為另外兩個選項在某些情境下還是有存在的必要，並不是說哪一個選項最好，還是得看當下情境較適合哪一個選項而定，並且，<code>all</code> 所產生的效果並非所有情境下都需要。</p>
<h2 id="補充：解決-MPA-所造成的重複代碼問題"><a href="#補充：解決-MPA-所造成的重複代碼問題" class="headerlink" title="補充：解決 MPA 所造成的重複代碼問題"></a>補充：解決 MPA 所造成的重複代碼問題</h2><p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── js&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       ├─── a.js         # JavaScript 模組 (1)</span><br><span class="line">│       └─── b.js         # JavaScript 模組 (2)</span><br><span class="line">│   │</span><br><span class="line">│   ├─── contact.html     # HTML 檔案 (contact)</span><br><span class="line">│   ├─── contact.js       # entry 入口檔案 (contact)</span><br><span class="line">│   ├─── index.html       # HTML 主檔案 (index)</span><br><span class="line">│   └─── main.js          # entry 入口檔案 (index)</span><br><span class="line">│</span><br><span class="line">├─── webpack.config.js    # Webpack 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure>

<p>a.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</span><br><span class="line"><span class="keyword">import</span> fun <span class="keyword">from</span> <span class="string">'./c'</span>;</span><br></pre></td></tr></table></figure>

<p>b.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">import</span> fun <span class="keyword">from</span> <span class="string">'./c'</span>;</span><br></pre></td></tr></table></figure>

<p>c.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>main.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./js/a'</span>;</span><br></pre></td></tr></table></figure>

<p>contact.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./js/b'</span>;</span><br></pre></td></tr></table></figure>

<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/main.js'</span>,</span><br><span class="line">    contact: <span class="string">'./src/contact.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/contact.html'</span>,</span><br><span class="line">      filename: <span class="string">'contact.html'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上是 MPA (Multi-Page Application) 基本的開發流程，讓我們直接進行編譯看看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── contact.html</span><br><span class="line">│   ├─── contact.js</span><br><span class="line">│   ├─── index.html</span><br><span class="line">│   └─── index.js</span><br></pre></td></tr></table></figure>

<p>從上面的編譯結果可以得知，確實相關的代碼都有成功被打包進去，但這邊有一個問題是，兩個頁面存在相同的代碼，也就是 <code>c.js</code> 的檔案內容，這樣會導致頁面加載到不必要的流量，關於這一個問題，我們一樣可以使用 SplitChunksPlugin 來解決，配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        <span class="comment">// 抽離 node_modules</span></span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          chunks: <span class="string">'initial'</span>,</span><br><span class="line">          name: <span class="string">'vendors'</span>,</span><br><span class="line">          priority: <span class="number">20</span>,</span><br><span class="line">          enforce: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 抽離公用模組</span></span><br><span class="line">        common: &#123;</span><br><span class="line">          chunks: <span class="string">'initial'</span>,</span><br><span class="line">          minSize: <span class="number">0</span>,</span><br><span class="line">          name: <span class="string">'common'</span>,</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          priority: <span class="number">10</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>記得將全域的 <code>minSize</code> 與 <code>minChunks</code> 透過區域配置方式給覆蓋掉，避免無法進入 common 這個 <code>cacheGroups</code>。</p>
<p>此時的編譯結果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── common.js        # 存在所有 node_modules 套件</span><br><span class="line">│   ├─── common.js        # 只存在 c.js</span><br><span class="line">│   ├─── contact.html</span><br><span class="line">│   ├─── contact.js</span><br><span class="line">│   ├─── index.html</span><br><span class="line">│   └─── index.js</span><br></pre></td></tr></table></figure>

<p>這邊要注意！html-webpack-plugin 預設是載入所有 chunk 的，我們需要再各自頁面排除其他不相干的 chunk，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      chunks: [<span class="string">'main'</span>], <span class="comment">// 僅包含名為 main 的 chunk</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/contact.html'</span>,</span><br><span class="line">      filename: <span class="string">'contact.html'</span>,</span><br><span class="line">      chunks: [<span class="string">'contact'</span>], <span class="comment">// 僅包含名為 contact 的 chunk</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>大功告成！</p>
<h2 id="補充：抽離-Webpack-運行時代碼"><a href="#補充：抽離-Webpack-運行時代碼" class="headerlink" title="補充：抽離 Webpack 運行時代碼"></a>補充：抽離 Webpack 運行時代碼</h2><p>Webpack 有 runtime 的概念，也就是在我們每次編譯後產生的檔案中落落長的那段代碼，為了盡可能的優化 Browser 緩存，我們可以將這段 runtime 代碼單獨抽離出來，這樣在某些文件發生改變後，一些與之相關的文件 hash 值並不會也隨之改變。</p>
<p>通過配置 <code>runtimeChunk</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    runtimeChunk: <span class="string">'multiple'</span>, <span class="comment">// or true</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上配置會為每個僅含有 runtime 的入口起點添加一個而外的 chunk，此時編譯結果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── common.js</span><br><span class="line">│   ├─── contact.html</span><br><span class="line">│   ├─── contact.js</span><br><span class="line">│   ├─── index.html</span><br><span class="line">│   ├─── main.js</span><br><span class="line">│   ├─── runtime~contact.js    # contact 的 runtime 文件</span><br><span class="line">│   ├─── runtime~main.js       # main 的 runtime 文件</span><br><span class="line">│   └─── vendors.js</span><br></pre></td></tr></table></figure>

<p>配置 <code>single</code> or <code>Object.name</code> 會創建一個在所有生成 chunk 之間共享的 runtime 文件，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    runtimeChunk: <span class="string">'single'</span>, <span class="comment">//  runtime 文件預設名稱為 runtime.js</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    runtimeChunk: &#123;</span><br><span class="line">      name: <span class="string">'manifest'</span>, <span class="comment">// runtime 文件名稱為 manifest.js</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在這邊我們使用自訂名稱的方式抽離 runtime 文件，此時編譯結果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── common.js</span><br><span class="line">│   ├─── contact.html</span><br><span class="line">│   ├─── contact.js</span><br><span class="line">│   ├─── index.html</span><br><span class="line">│   ├─── main.js</span><br><span class="line">│   ├─── manifest.js           # 共享的 runtime 文件</span><br><span class="line">│   └─── vendors.js</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>w3HexSchool</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 前端打包工具 - 使用 webpack-merge 區分 dev 與 prod 環境</title>
    <url>/2020-04-09-webpack-webpackmerge/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在介紹如何正確挑選當前環境的 SourceMap 類型時，有提到如何以三元運算的方式達到自動切換的效果，通常在實際開發中，我們會有多個需判斷當前環境用以切換配置的需求，如果此時還是一樣使用三元運算方式做切換，可能會造成結構混亂導致不易閱讀的問題。此篇將介紹如何使用 webpack-merge 合併各自環境的 Webpack 配置檔，達到在不造成結構混亂的前提下區分 dev 與 prod 環境。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>webpack-merge 安裝</li>
<li>webpack-merge 基本使用</li>
<li>webpack-merge 可傳遞選像</li>
<li>補充：cross-env 跨平台設置環境變數</li>
</ul>
<h2 id="webpack-merge-安裝"><a href="#webpack-merge-安裝" class="headerlink" title="webpack-merge 安裝"></a>webpack-merge 安裝</h2><blockquote>
<p>套件連結：<a href="https://github.com/survivejs/webpack-merge" target="_blank" rel="external nofollow noopener noreferrer">webpack-merge</a></p>
</blockquote>
<p>主要的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install webpack-merge -D</span><br></pre></td></tr></table></figure>

<p>過程會使用到的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install css-loader mini-css-extract-plugin style-loader webpack webpack-cli -D</span><br></pre></td></tr></table></figure>

<p>package.json：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^3.5.1"</span>,</span><br><span class="line">    <span class="attr">"mini-css-extract-plugin"</span>: <span class="string">"^0.9.0"</span>,</span><br><span class="line">    <span class="attr">"style-loader"</span>: <span class="string">"^1.1.3"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.42.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span>,</span><br><span class="line">    <span class="attr">"webpack-merge"</span>: <span class="string">"^4.2.2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在這邊我們示範在不使用三元運算的情況下，切換 style-loader 與 mini-css-extract-plugin 作用於不同環境，請先將所需套件進行安裝。</p>
<h2 id="webpack-merge-基本使用"><a href="#webpack-merge-基本使用" class="headerlink" title="webpack-merge 基本使用"></a>webpack-merge 基本使用</h2><p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── build&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── webpack.base.conf.js     # Webpack 共用配置檔 (等待合併)</span><br><span class="line">│   ├─── webpack.dev.conf.js      # 開發環境配置檔</span><br><span class="line">│   └─── webpack.prod.conf.js     # 生產環境配置檔</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.css      # CSS 主檔案</span><br><span class="line">│   │</span><br><span class="line">│   └─── main.js          # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure>

<p>配置 <code>build/webpack.base.conf.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  context: path.resolve(__dirname, <span class="string">'../'</span>), <span class="comment">// 編譯時的根目錄 (相對路徑尋找文件用)</span></span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// other common config</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以往我們都是將配置全部寫在單獨的檔案內，現在我們可以將不管是 development 還是 production 環境都會用到且不需要切換的配置拆分到 <code>webpack.base.conf.js</code> 檔案內，等等會說明如何透過 webpack-merge 合併這一支檔案，這邊要注意檔案路徑是否正確，為了方便，我們配置了 <code>context</code> 並指向上一層目錄也就是專案根目錄，預設為 <code>process.cwd()</code>。</p>
<p>配置 <code>build/webpack.dev.conf.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 載入 webpack-merge (第一步)</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="comment">// 載入需合併的配置檔 (第二步)</span></span><br><span class="line"><span class="keyword">const</span> baseWebpackConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base.conf'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置檔合併 (第三步)</span></span><br><span class="line"><span class="built_in">module</span>.exports = merge(baseWebpackConfig, &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-eval-source-map'</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// other development config</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在 development 的環境下，我們使用 style-loader 用做樣式表的處理，並且透過 webpack-merge 合併檔案，你會發現 webpack-merge 使用方式蠻簡單的，只需要以 <code>merge(等待合併檔案,{})</code> 語法做撰寫即可，最後記得一樣透過 <code>module.exports</code> 導出模塊，我們到最後會指定這一個檔案進行編譯。</p>
<p>配置 <code>webpack.prod.conf.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> baseWebpackConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base.conf'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(baseWebpackConfig, &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  devtool: <span class="string">'source-map'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'js/[name].[hash].js'</span>, <span class="comment">// 覆蓋 baseWebpackConfig 設定</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/[name].[hash].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// other production config</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在 production 的環境下，我們使用 mini-css-extract-plugin 用做樣式表的處理，這邊補充一點，<code>webpack.base.conf.js</code> 檔案的所有屬性都是可以被覆蓋的，也就是說，導出的檔案可新增任何被合併檔案的屬性，達到覆蓋的作用，比如上面範例的 <code>output.filename</code> 屬性。</p>
<p>至 <code>package.json</code> 新增編譯指令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --config ./build/webpack.prod.conf.js"</span>,</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"webpack --config ./build/webpack.dev.conf.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以往我們在新增編譯指令時，都不會使用到 <code>--config</code> 這個命令，因為預設讀取 Webpack 配置檔的路徑就是專案根目錄且名稱必須為 <code>webpack.config.js</code>，這也是為什麼我們不需要配置的原因，但在這邊由於路徑與名稱的都不同，我們必須告知 Webpack 去哪裡找我們的配置文件，以確保成功編譯，上面我們分別新增了 dev 與 prod 的配置檔路徑，如果都沒問題，就可以直接編譯並查看結果囉。</p>
<p>編譯結果：</p>
<p>development 環境：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── js&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── main.js</span><br></pre></td></tr></table></figure>

<p>production 環境：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       ├─── main.b16f5df8f355e075f0a9.css</span><br><span class="line">│       └─── main.b16f5df8f355e075f0a9.css.map</span><br><span class="line">│   │</span><br><span class="line">│   └─── js&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       ├─── main.b16f5df8f355e075f0a9.js</span><br><span class="line">│       └─── main.b16f5df8f355e075f0a9.js.map</span><br></pre></td></tr></table></figure>

<h2 id="補充：cross-env-跨平台設置環境變數"><a href="#補充：cross-env-跨平台設置環境變數" class="headerlink" title="補充：cross-env 跨平台設置環境變數"></a>補充：cross-env 跨平台設置環境變數</h2><p>這邊補充一下關於環境變數的陷阱，在 Webpack 4 中，當我們設置了 <code>mode</code> 選項後，會自動使用 <a href="https://webpack.js.org/plugins/define-plugin/" target="_blank" rel="external nofollow noopener noreferrer">DefinePlugin</a> 新增一個名為 <code>process.env.NODE_ENV</code> 的全域變數：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env.NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(<span class="string">'&lt;當前環境&gt;'</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此時我們可在 entry 內的環境讀取這個變數：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &gt; $ webpack --mode development</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(process.env); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.NODE_ENV); <span class="comment">// development</span></span><br></pre></td></tr></table></figure>

<p>請注意，DefinePlugin 只不過是幫我們在 entry 環境新增一個全域變數，並不是環境變數，如果你印出 <code>process.env</code> 的內容是找不到這個變數的。</p>
<p>這邊還有一個最大的雷點，那就是在 Webpack 配置檔是讀取不到這一個全域變數的，如同前面所說，DefinePlugin 只是在 “entry” 內新增這個全域變數，Webpack 配置檔自然是無法讀取到他的，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(process.env.NODE_ENV); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>針對以上問題，Linux 環境的開發者可直接在 CLI 指令時注入 <code>NODE_ENV</code> 這一個環境變數，如下所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"NODE_ENV=development webpack"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有沒有注意到我說的是 Linux 的開發者？如果你的系統是 Windows，使用以上方法是行不通的，Windows 不支持 NODE_ENV=development 這樣的設置方式，你可能看過有人使用以下作法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> NODE_ENV=development</span><br></pre></td></tr></table></figure>

<p>以上方法確實可以成功，但一遇到跨系統問題，還是會導致錯誤，這邊我推薦使用 <a href="https://www.npmjs.com/package/cross-env" target="_blank" rel="external nofollow noopener noreferrer">cross-env</a> 套件來完成，以下為範例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install cross-env -D</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"cross-env NODE_ENV=development webpack"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要在 <code>NODE_ENV</code> 前加入 <code>cross-env</code> 命令即可，是不是很簡單？此時 Webpack 配置檔就讀取的到環境變數囉：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(process.env.NODE_ENV); <span class="comment">// development</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 前端打包工具 - 使用 vue-loader 手動建置出 Vue CLI 環境</title>
    <url>/2020-04-13-webpack-vueloader/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>從 Vue CLI v3 開始引入了 webpack-chain 套件，同時針對配置進行了高度抽象化，我們不能以先前配置 Webpack 的方式進行撰寫，而是必須閱讀官方文件配置在專屬的 vue.config.js 檔案內才能起作用，是不是覺得這樣太麻煩了？不如我們依照自己習慣手動建置一個 Vue CLI 環境吧！此篇將介紹如何使用 vue-loader 並搭配先前所介紹的 loader 與 plugin 手動建置出 Vue CLI 環境。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>vue-loader 安裝</li>
<li>vue-loader 基本使用</li>
<li>vue-loader 可傳遞選項</li>
<li>補充：載入並使用 Vue Router</li>
</ul>
<h2 id="vue-loader-安裝"><a href="#vue-loader-安裝" class="headerlink" title="vue-loader 安裝"></a>vue-loader 安裝</h2><blockquote>
<p>套件連結：<a href="https://vue-loader.vuejs.org/guide/#vue-cli" target="_blank" rel="external nofollow noopener noreferrer">vue-loader</a>、<a href="https://github.com/vuejs/vue/tree/dev/packages/vue-template-compiler#options" target="_blank" rel="external nofollow noopener noreferrer">vue-templete-compiler</a>、<a href="https://vuejs.org/v2/guide/installation.html" target="_blank" rel="external nofollow noopener noreferrer">vue</a></p>
</blockquote>
<p>主要的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install vue-loader vue-template-compiler -D ; npm install vue -P</span><br></pre></td></tr></table></figure>

<p>過程會使用到的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install webpack webpack-cli webpack-merge webpack-dev-server url-loader file-loader html-webpack-plugin clean-webpack-plugin babel-loader @babel/core @babel/preset-env sass-loader node-sass postcss-loader autoprefixer css-loader style-loader mini-css-extract-plugin -D ; npm i core-js -P</span><br></pre></td></tr></table></figure>

<p>package.json：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"@babel/core"</span>: <span class="string">"^7.9.0"</span>,</span><br><span class="line">    <span class="attr">"@babel/preset-env"</span>: <span class="string">"^7.9.5"</span>,</span><br><span class="line">    <span class="attr">"autoprefixer"</span>: <span class="string">"^9.7.6"</span>,</span><br><span class="line">    <span class="attr">"babel-loader"</span>: <span class="string">"^8.1.0"</span>,</span><br><span class="line">    <span class="attr">"clean-webpack-plugin"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^3.5.2"</span>,</span><br><span class="line">    <span class="attr">"file-loader"</span>: <span class="string">"^6.0.0"</span>,</span><br><span class="line">    <span class="attr">"html-webpack-plugin"</span>: <span class="string">"^4.2.0"</span>,</span><br><span class="line">    <span class="attr">"mini-css-extract-plugin"</span>: <span class="string">"^0.9.0"</span>,</span><br><span class="line">    <span class="attr">"node-sass"</span>: <span class="string">"^4.13.1"</span>,</span><br><span class="line">    <span class="attr">"postcss-loader"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    <span class="attr">"sass-loader"</span>: <span class="string">"^8.0.2"</span>,</span><br><span class="line">    <span class="attr">"style-loader"</span>: <span class="string">"^1.1.3"</span>,</span><br><span class="line">    <span class="attr">"url-loader"</span>: <span class="string">"^4.1.0"</span>,</span><br><span class="line">    <span class="attr">"vue-loader"</span>: <span class="string">"^15.9.1"</span>,</span><br><span class="line">    <span class="attr">"vue-template-compiler"</span>: <span class="string">"^2.6.11"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.42.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span>,</span><br><span class="line">    <span class="attr">"webpack-dev-server"</span>: <span class="string">"^3.10.3"</span>,</span><br><span class="line">    <span class="attr">"webpack-merge"</span>: <span class="string">"^4.2.2"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"core-js"</span>: <span class="string">"^3.6.5"</span>,</span><br><span class="line">    <span class="attr">"vue"</span>: <span class="string">"^2.6.11"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>當你安裝 vue-loader 的同時，也請記得安裝 vue-template-compiler，vue-loader 主要得依靠其套件進行編譯 <code>.vue</code> 檔的動作，最後當然少不了我們的 vue 主套件，同樣也須進行安裝。</p>
<blockquote>
<p>每當 vue 有新版本發布時，一個相對應的 vue-template-compiler 也會隨之發布。兩者的版本必須保持同步，這樣 vue-loader 才能正常生成兼容 runtime 的代碼。這意味著你每次升級專案中的 vue 時，也必須同時升級 vue-template-compiler。</p>
</blockquote>
<h2 id="vue-loader-基本使用"><a href="#vue-loader-基本使用" class="headerlink" title="vue-loader 基本使用"></a>vue-loader 基本使用</h2><p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── build&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── webpack.base.conf.js     # Webpack 共用配置檔 (等待合併)</span><br><span class="line">│   ├─── webpack.dev.conf.js      # 開發環境配置檔</span><br><span class="line">│   └─── webpack.prod.conf.js     # 生產環境配置檔</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── public&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── favicon.ico</span><br><span class="line">│   └─── index.html               # HTML 主檔案</span><br><span class="line">│</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── assets&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── img&#x2F;</span><br><span class="line">│           │</span><br><span class="line">│           └─── logo.png         # 測試圖片是否成功解析 ( Size &lt; 8KB )</span><br><span class="line">│       │</span><br><span class="line">│       └─── scss&#x2F;</span><br><span class="line">│           │</span><br><span class="line">│           └─── all.scss         # SCSS 主檔案</span><br><span class="line">│</span><br><span class="line">│   │</span><br><span class="line">│   ├─── App.vue                  # Vue 主檔案</span><br><span class="line">│   └─── main.js                  # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── .browserslistrc</span><br><span class="line">├─── babel.config.js</span><br><span class="line">├─── postcss.config.js</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure>

<p>配置 <code>build/webpack.base.conf.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  context: path.resolve(__dirname, <span class="string">'../'</span>),</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line">    filename: <span class="string">'static/js/[name].js'</span>,</span><br><span class="line">    publicPath: <span class="string">'/'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">'.vue'</span>, <span class="string">'.mjs'</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'@'</span>: path.resolve(__dirname, <span class="string">'../src'</span>),</span><br><span class="line">      <span class="string">'@img'</span>: path.resolve(__dirname, <span class="string">'../src/assets/img'</span>),</span><br><span class="line">      vue$: <span class="string">'vue/dist/vue.runtime.esm.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        loader: <span class="string">'vue-loader'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: <span class="number">8192</span>,</span><br><span class="line">              name: <span class="string">'static/img/[name].[ext]'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> VueLoaderPlugin(),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./public/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      favicon: <span class="string">'./public/favicon.ico'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    runtimeChunk: &#123;</span><br><span class="line">      name: <span class="string">'manifest'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          chunks: <span class="string">'all'</span>,</span><br><span class="line">          name: <span class="string">'vendors'</span>,</span><br><span class="line">          enforce: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">default</span>: <span class="literal">false</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 <code>webpack.base.conf.js</code> 的配置中，我們做了以下事情：</p>
<ul>
<li>配置 <a href="https://awdr74100.github.io/2020-03-16-webpack-babelloader/">babel-loader</a> 編譯並轉換 ES6+ 代碼，node_modules 內的套件除外</li>
<li>配置 <a href="https://awdr74100.github.io/2020-03-09-webpack-urlloader-fileloader/">url-loader</a> 將上限內的資源轉換為 Base64 編碼，超過上限的資源 fallback 給 <a href="https://awdr74100.github.io/2020-03-09-webpack-urlloader-fileloader/">file-loader</a> 處理</li>
<li>配置 <a href="https://awdr74100.github.io/2020-03-25-webpack-cleanwebpackplugin/">clean-webpack-plugin</a> 在每次編譯前刪除 <code>output.path</code> 的檔案，以保證編譯結果為最新</li>
<li>配置 <a href="https://awdr74100.github.io/2020-03-23-webpack-htmlwebpackplugin/">html-webpack-plugin</a> 將指定的本地模板自動引入相關資源並生成到 <code>output.path</code> 位置</li>
<li>配置 <a href="https://awdr74100.github.io/2020-04-06-webpack-splitchunksplugin/">SplitChunksPlugin</a> 將 node_modules 內的套件抽離成獨立檔案</li>
<li>配置 <a href="https://awdr74100.github.io/2020-04-06-webpack-splitchunksplugin/#%E8%A3%9C%E5%85%85%EF%BC%9A%E6%8A%BD%E9%9B%A2-Webpack-%E9%81%8B%E8%A1%8C%E6%99%82%E4%BB%A3%E7%A2%BC">runtimeChunk</a> 將 Webpack 運行時代碼抽離成獨立檔案</li>
<li>配置 vue-loader 提取單文件組件 (<a href="https://vue-loader.vuejs.org/zh/spec.html" target="_blank" rel="external nofollow noopener noreferrer">SFCs</a>) 的每個語言塊，並透過相關 loader 做對應的處理，最後將他們組裝成一個 ES Module</li>
</ul>
<p>這邊唯一沒有介紹過的就只有 vue-loader 了，讓我們來看它是如何如何配置的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 載入 vue-loader/lib/plugin (第一步)</span></span><br><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 配置 vue-loader (第二步)</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        loader: <span class="string">'vue-loader'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 創建實例 (第三步)</span></span><br><span class="line">    <span class="keyword">new</span> VueLoaderPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>vue-loader 與其他 loader 或 plugin 的配置方式相比大同小異，主要就是增加一個 rules 用以處理 <code>.vue</code> 檔，vue-loader 會將每一個語言塊提取出來並送至相關的 loader 去做處理，比如說 <code>&lt;style&gt;</code>、<code>&lt;templete&gt;</code> 等，也就是說，除了配置 vue-loader 以外，也須配置像是 css-loader 或 babel-loader 用以處理需解析的模塊。</p>
<p>這邊還有一點要注意的是，由於 vue-loader 本身就以搭配 vue-template-compiler 用做解析 <code>&lt;templete&gt;</code> 模塊，所以我們不必將整個 vue 包引入進來，而是選擇只包含運行時的構建版本即可，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      vue$: <span class="string">'vue/dist/vue.runtime.esm.js'</span>, <span class="comment">// 相比於 vue.esm.js 小 30% 左右</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>配置 <code>webpack.dev.conf.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> baseWebpackConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base.conf'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(baseWebpackConfig, &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-eval-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: <span class="number">9000</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    clientLogLevel: <span class="string">'warn'</span>,</span><br><span class="line">    compress: <span class="literal">true</span>,</span><br><span class="line">    overlay: <span class="literal">true</span>,</span><br><span class="line">    stats: <span class="string">'errors-only'</span>,</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.s[ac]ss$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在 <code>webpack.dev.conf.js</code> 的配置中，我們做了以下事情：</p>
<ul>
<li>配置 <a href="https://awdr74100.github.io/2020-04-09-webpack-webpackmerge/">webpack-merge</a> 將 <code>webpack.base.conf.js</code> 基礎配置合併進來</li>
<li>配置 <a href="https://awdr74100.github.io/2020-03-04-webpack-sassloader/">sass-loader</a> 編譯並轉換 Sass/SCSS 預處理器代碼</li>
<li>配置 <a href="https://awdr74100.github.io/2020-03-05-webpack-postcssloader/">postcss-loader</a> 搭配 autoprefixer 自動為 CSS 增加 Prefix</li>
<li>配置 <a href="https://awdr74100.github.io/2020-02-26-webpack-cssloader-styleloader/">css-loader</a> 將 CSS 透過 <code>@import</code> 或 <code>url()</code> 的方式載入到 JavaScript 內</li>
<li>配置 <a href="https://awdr74100.github.io/2020-02-26-webpack-cssloader-styleloader/">style-loader</a> 將 CSS 以 <code>&lt;style&gt;</code> 標籤的方式嵌入至 HTML 中</li>
<li>配置 <a href="https://awdr74100.github.io/2020-03-26-webpack-webpackdevserver/">devServer</a> 並開啟 HMR (Hot Module Replacement) 功能</li>
<li>將 <a href="https://awdr74100.github.io/2020-04-02-webpack-devtool/">devtool</a> 選為 development 環境較適合的 sourceMap 類型</li>
</ul>
<p>在開發環境我們選擇使用 style-loader 處理 CSS 樣式，預設的 Vue CLI 配置是使用 vue-style-loader，這兩個 loader 功能基本上是一樣的，只不過 vue-style-loader 有針對 SSR (Server-Side Rendering ) 做支持，且移除了部分的功能，詳細可參考<a href="https://github.com/vuejs/vue-style-loader#differences-from-style-loader" target="_blank" rel="external nofollow noopener noreferrer">官方文件</a>。</p>
<p>配置 <code>webpack.prod.conf.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> baseWebpackConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base.conf'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(baseWebpackConfig, &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  devtool: <span class="literal">false</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'static/js/[name].[hash].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.s[ac]ss$/i</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>, <span class="string">'sass-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'static/css/[name].[hash].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在 <code>webpack.prod.conf.js</code> 的配置中，我們做了以下事情：</p>
<ul>
<li>可參考 <code>webpack.dev.conf.js</code> 配置</li>
<li>配置 <a href="https://awdr74100.github.io/2020-03-02-webpack-minicssextractplugin/">mini-css-extract-plugin</a> 將 CSS 單獨抽離成獨立檔案</li>
<li>將 <a href="https://awdr74100.github.io/2020-04-02-webpack-devtool/">devtool</a> 選為 <code>false</code>，在 production 環境不生成 sourceMap</li>
</ul>
<p>Vue CLI v3 在生產環境預設是開啟 sourceMap 的，但我是偏好不開啟 sourceMap 的，存在風險的疑慮，如果想要在生產環境開啟 sourceMap 的話，只需要將 <code>devtool</code> 設為 <code>source-map</code> 即可。</p>
<p>配置 <code>./.browserslistrc</code> 檔案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">last 2 version</span><br><span class="line">&gt; 1%</span><br><span class="line">IE 10</span><br></pre></td></tr></table></figure>

<p>配置 <code>./babel.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@babel/preset-env'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        useBuiltIns: <span class="string">'usage'</span>,</span><br><span class="line">        corejs: <span class="number">3</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 Vue CLI 3 版本的 Babel 處理，預設是使用 @babel/polyfill 方式進行編譯，在這邊我們也使用相同方式進行處理，之前在 <a href="https://awdr74100.github.io/2020-03-16-webpack-babelloader/">babel-loader</a> 文章有提到關於 @babel/runtime 與 @babel/polyfill 的差異，有興趣的可以前去觀看。</p>
<p>配置 <code>./postcss.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [<span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>entry 入口處 (<code>src/main.js</code>) 引入並創建 Vue 實例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function">(<span class="params">h</span>) =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure>

<p>在 <code>main.js</code> 檔案中，我們新增了一個 Vue 實例，並透過 <code>$mount()</code> 手動掛載到指定的 DOM 元素上，與配置 <code>el</code> 的方式是沒有任何區別的，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function">(<span class="params">h</span>) =&gt;</span> h(App),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>比較困惑的可能是 <code>render</code> 這一段語法，事實上，它是下面寫法的縮寫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(App);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>改為 ES6 的函式縮寫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render(createElement) &#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(App);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>進一步改以箭頭函式縮寫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function">(<span class="params">h</span>) =&gt;</span> h(App),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>h</code> 這一個參數的作用就是生成一個 VNode 節點，<code>render</code> 函數得到這一個 VNode 節點之後，返回給 Vue 的 <code>mount</code> 函數渲染成真實的 DOM 節點，並掛載到根節點上。</p>
<p>而為什麼取作 <code>h</code> 呢？它來自 <code>hyperscript</code> 這個單字，這個單字通常用在 Virtual DOM 的實現中。Hyperscript 本身是指生成 HTML 結構的 Script 腳本，因為 HTML 是 HyperText Markup Language 的縮寫 (超文本標記語言)。</p>
<p>你可能會有疑問，在 <code>webpack.dev.conf.js</code> 配置中，不是有開啟 HMR 功能嗎？我們不需要加入以下語法嗎？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案是不用的，vue-loader 內部使用的 <a href="https://github.com/vuejs/vue-hot-reload-api" target="_blank" rel="external nofollow noopener noreferrer">vue-hot-reload-api</a> 已經幫我們做開啟的動作了，這也是為什麼 Vue CLI 預設就已開啟 HMR 功能，但你卻都找不到這段語法的原因。</p>
<p>至 <code>./src/App.vue</code> 撰寫範例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-primary"</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"logo"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        title: <span class="string">'Hello Vue'</span>,</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"scss"</span>&gt;</span></span><br><span class="line"><span class="css">  @<span class="keyword">import</span> <span class="string">'~@/assets/scss/all.scss'</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>關於 Vue 的語法就暫時不做說明，未來一樣會有一系列的文章專門在講解 Vue，敬請期待！為了測試 sass-loader 是否成功作用，我們刻意在 <code>App.vue</code> 中載入 SCSS 的主檔案，當然你也可以在 entry 檔案進行載入，全看個人喜好。</p>
<p>至 <code>./public/index.html</code> 撰寫 HTML 範例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>這邊唯一的重點就是記得要新增當時宣告的 <code>#app</code> 元素，用以讓 Vue 將內容掛載上去。在 Vue CLI 中，是使用 <a href="https://webpack.js.org/plugins/copy-webpack-plugin/" target="_blank" rel="external nofollow noopener noreferrer">copy-webpack-plugin</a> 引入 favicon.ico 圖示，在這邊不必這麼麻煩，我們直接使用 html-webpack-plugin 的 <code>favicon</code> 來完成即可。</p>
<p>至 <code>./src/assets/scss/all.scss</code> 撰寫 SCSS 範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: rgb(<span class="number">45</span>, <span class="number">124</span>, <span class="number">214</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.logo</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">'~@img/logo.png'</span>);</span><br><span class="line">  <span class="attribute">background-position</span>: center center;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: contain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至 <code>package.json</code> 新增編譯指令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"webpack-dev-server --config ./build/webpack.dev.conf.js"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --config ./build/webpack.prod.conf.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行 <code>npm run dev</code> 指令並查看結果：</p>
<p><img src="https://i.imgur.com/grGyrsW.png" alt="手動建置 Vue CLI 環境"></p>
<p>大功告成！我們已經手動建置出 Vue CLI 環境了。當初在學習 Vue 時，都是透過 Vue CLI 直接將環境給建構起來，但總是有些陌生感，Webpack 的配置也都搞不清楚作用是什麼，透過一陣子的學習，目前已經能夠針對專案需求，客製出 Webpack 的環境，滿滿的成就感阿！分享給大家。</p>
<h2 id="vue-loader-可傳遞選項"><a href="#vue-loader-可傳遞選項" class="headerlink" title="vue-loader 可傳遞選項"></a>vue-loader 可傳遞選項</h2><p>可參考 <a href="https://vue-loader.vuejs.org/options.html" target="_blank" rel="external nofollow noopener noreferrer">vue-loader Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li><p>compiler：<code>VueTemplateCompiler</code><br>單文件組件中 <code>&lt;templete&gt;</code> 塊的默認編譯器，默認為 <code>require(&#39;vue-template-compiler&#39;)</code></p>
</li>
<li><p>compilerOptions：<code>Object</code><br>當編譯器為 vue-template-compiler 時，可添加此選像自定義編譯器指令，默認為 <code>{}</code></p>
</li>
</ul>
<p>範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        loader: <span class="string">'vue-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          compiler: <span class="built_in">require</span>(<span class="string">'vue-template-compiler'</span>), <span class="comment">// 此為預設值</span></span><br><span class="line">          compilerOptions: &#123;</span><br><span class="line">            whitespace: <span class="string">'condense'</span>, <span class="comment">// Vue CLI v3 預設選項</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="補充：載入並使用-Vue-Router"><a href="#補充：載入並使用-Vue-Router" class="headerlink" title="補充：載入並使用 Vue Router"></a>補充：載入並使用 Vue Router</h2><p>當我們手動建置出 Vue CLI 環境時，要集成任何的 Vue Plugin 就難不倒我們了，這邊示範如何手動將 Vue Router 載入做使用，讓我們先從安裝開始：</p>
<blockquote>
<p>套件連結：<a href="https://router.vuejs.org/installation.html" target="_blank" rel="external nofollow noopener noreferrer">vue-router</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install vue-router -P</span><br></pre></td></tr></table></figure>

<p>新增 <code>./src/views/Home.vue</code> 撰寫以下內容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        title: <span class="string">'This is an home page'</span>,</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>新增 <code>./src/views/About.vue</code> 撰寫以下內容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        title: <span class="string">'This is an about page'</span>,</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>新增 <code>./src/router/index.js</code> 撰寫我們的路由：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'@/views/Home'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'Home'</span>,</span><br><span class="line">      component: Home,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/about'</span>,</span><br><span class="line">      name: <span class="string">'About'</span>,</span><br><span class="line">      component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "about" */</span> <span class="string">'@/views/About'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>這剛好也是 Vue CLI v3 版本的預設配置，提供了兩種方式加載元件，如果你想透過 <a href="https://router.vuejs.org/guide/advanced/lazy-loading.html" target="_blank" rel="external nofollow noopener noreferrer">Lazy Loading</a> 方式加載元件，可參考上面 About 元件的寫法。</p>
<p>掛載 router 實例至 Vue 實體上：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router, <span class="comment">// ES6 縮寫，等同於 router: router</span></span><br><span class="line">  render: <span class="function">(<span class="params">h</span>) =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure>

<p>執行 <code>npm run dev</code> 並查看結果：</p>
<p><img src="https://i.imgur.com/U2dp9dd.png" alt="結合 Vue Router"></p>
<p>大功告成！事實上，當你了解整個 Vue CLI 是如何建構出來的，那麼你對於這些基礎的配置應該是沒啥難度了，拍手 ~</p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>w3HexSchool</tag>
        <tag>Webpack</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 版本控制系統 - 環境安裝與基本指令</title>
    <url>/2020-04-16-git-install/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Git 是一個分散式的版本控制系統，可針對專案的不同版本進行操作。當初在學 Git 時是直接買書回來看，大概知道什麼時候該打什麼指令，但我還是認為自己的基礎不夠扎實，還不到業界的標準，如果你是應徵軟體相關的工作，這肯定是必備技能。此系列文章主要紀錄在各種情境下，該如何靈活使用 Git 管控我們的專案版本，到後半段的文章也會提及如何將專案部屬至遠端的 Git 伺服器，如 GitHub、Bitbucket 等，最後會以常見的 Work Flow，如 GitHub Fow 收尾，加深自己對 Git 的印象。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>為什麼需要使用 Git？</li>
<li>安裝 Git 至 Windows 環境下</li>
<li>使用者設定 / 全域與區域差別</li>
<li>初始化 Git Repository</li>
<li>Git 基本指令</li>
<li>設定 Git 指令縮寫</li>
<li>Git 指令回顧</li>
</ul>
<h2 id="為什麼需要使用-Git？"><a href="#為什麼需要使用-Git？" class="headerlink" title="為什麼需要使用 Git？"></a>為什麼需要使用 Git？</h2><p>假設你是一位 Web 開發人員，在做專案開發時可能會遇到以下情境：</p>
<p><img src="https://i.imgur.com/2oSCNHQ.png" alt="傳統版本控制"></p>
<p>為了保證之後可查看過往的開發紀錄，在每次新的開發時，我們都會直接另存新檔並將修改內容直接以標題顯示，老實講，我以前就是這樣幹的，我是一位有點強迫症的人，我喜歡在每次開發時都遍歷過往的紀錄，避免自己陷入曾發生的錯誤，但你不覺得這樣子顯得很不專業嗎？身為一位開發人員，居然用這麼傳統的方式辨別每次開發的過程，何不我們嘗試使用版本控制進行開發呢？</p>
<p><img src="https://i.imgur.com/dIsQMmS.png" alt="使用 Git 版本控制"></p>
<p>以上為 VSCode 中的 Git History 插件效果，是不是覺得很驚人？在也不需要另存新檔了，你可能會有疑問，這不就只是在每次開發時做一次紀錄嗎？我需要知道的是紀錄的內容阿！</p>
<p><img src="https://i.imgur.com/Oa2A1VI.png" alt="使用 Git 進行比對"></p>
<p>透過簡單的指令即可比對不同版本的差異，你是不是越來越有興趣了？讓我們再做一個示例：</p>
<ul>
<li>當前狀態 (master)：</li>
</ul>
<p><img src="https://i.imgur.com/hZOQ3Hx.png" alt="當前最新狀態"></p>
<ul>
<li>新增內文 (6cb782f)：</li>
</ul>
<p><img src="https://i.imgur.com/ZMA2SyS.png" alt="切換到指定狀態"></p>
<p>你沒有看錯，代碼被還原到指定的紀錄上了，但這不代表以後的紀錄被刪除了，你可以自由的切換當前專案的版本。有時候在團隊開發時，可能會有同一份檔案被修改的情況，以往我們都是用口述的方式進行討論，但現在不用這麼麻煩了，來看以下示例：</p>
<p><img src="https://i.imgur.com/mizZplS.png" alt="版本衝突"></p>
<p>當我們遇到版本衝突時，Git 會提示衝突的地方，我們只需要與夥伴溝通要使用誰的版本即可，是不是很方便？說了這麼多，讓我們直接開始使用 Git 吧！</p>
<h2 id="安裝-Git-至-Windows-環境下"><a href="#安裝-Git-至-Windows-環境下" class="headerlink" title="安裝 Git 至 Windows 環境下"></a>安裝 Git 至 Windows 環境下</h2><p>由於我本身是 Windows 的環境，故以下教學都是針對此環境進行。</p>
<blockquote>
<p>官方連結：<a href="https://git-scm.com/" target="_blank" rel="external nofollow noopener noreferrer">Git</a></p>
</blockquote>
<p><img src="https://i.imgur.com/ist48Oz.png" alt="Git 下載頁面"></p>
<p>安裝過程就一路給它按下去就對了，安裝完成後可以在滑鼠右鍵選單內容找到 <code>Git Bash Here</code> 與 <code>Git GUI Here</code> 選項，在這邊我們可以選擇 <code>Git Bash Here</code>，此時會跳出以下視窗：</p>
<p><img src="https://i.imgur.com/S1hTuvl.png" alt="Git Bash"></p>
<p>這個就是 Git 內建的命令提示字元，嚴格來講應該算是模擬 Linux 系統內的 Bash，我們所有的 Git 指令都會在這邊完成，當然你也可以使用 Windows 底下的 PowerShell 或 CMD，只要 Git 有成功安裝，隨你高興，我們可使用以下指令確認 Git 是否有成功安裝：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p>假設出現 Git 的版本號，即代表安裝成功，如下圖：</p>
<p><img src="https://i.imgur.com/1jNHeF0.png" alt="git --version"></p>
<h2 id="使用者設定-全域與區域差別"><a href="#使用者設定-全域與區域差別" class="headerlink" title="使用者設定 / 全域與區域差別"></a>使用者設定 / 全域與區域差別</h2><p>在觀看此文章段落之前，可以先至下一個段落實際把玩 Git 一番，這樣對此段落內容會比較有感覺。當我們在不設定當下使用者是誰的情況下，會跳出以下錯誤：</p>
<p><img src="https://i.imgur.com/J6iONlw.png" alt="使用者未設定"></p>
<p>就如同字面上的意思，當我們要提交一個 commit 時，必須告訴 Git 當下的使用者是誰，以保證未來可以追蹤此提交的使用者，這時可以輸入它給予的建議設定使用者，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"Roya"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.email <span class="string">'a78945612385238@gmail.com'</span></span><br></pre></td></tr></table></figure>

<p>上面這兩道指令主要用來設定使用者的姓名與信箱，此時可輸入以下指令檢查是否成功設定：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>

<p>如果出現 <code>user.name</code> 與 <code>user.email</code> 即代表設定成功。</p>
<p>這邊介紹另一種檢查的方法，至 <code>C:\Users\${USER}\.gitconfig</code> 查看內容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name &#x3D; Roya</span><br><span class="line">    email &#x3D; a78945612385238@gmail.com</span><br></pre></td></tr></table></figure>

<p>這一個檔案是 Git 的全域配置檔，還記得我們上面使用 <code>--global</code> 參數進行配置嗎？如果以全域方式設定使用者，在往後進行任何 Git 操作時，預設都會以這一個使用者為主，通常只在第一次使用 Git 時都才要設定，你也可以使用區域方式配置使用者，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --<span class="built_in">local</span> user.name <span class="string">'Eric'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --<span class="built_in">local</span> user.email <span class="string">'asdwef@gmail.com'</span></span><br></pre></td></tr></table></figure>

<p>區域配置的設定一樣會有專屬設定檔，專案資料夾內的 <code>/.git/config</code> 檔案就是了，同樣可檢查是否成功設定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name &#x3D; Eric</span><br><span class="line">    email &#x3D; asdwef@gmail.com</span><br></pre></td></tr></table></figure>

<p>當你在專案提交 commit 時，就會是使用區域配置的使用者而非全域配置的使用者，這點要注意！此時就能夠正常提交 commit 囉。</p>
<h2 id="初始化-Git-Repository"><a href="#初始化-Git-Repository" class="headerlink" title="初始化 Git Repository"></a>初始化 Git Repository</h2><p>接下來讓我們正式開始使用 Git 吧！首先請先新增一個空的資料夾：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir project</span><br></pre></td></tr></table></figure>

<p>假設這一個資料夾就是我們專案放置的地方，使用 <code>cd</code> 移至這個資料夾：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> project</span><br></pre></td></tr></table></figure>

<p>如果你的資料結構很複雜，也可以直接將專案資料夾拉進 bash 內：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\Users\a7894\Desktop\project</span><br></pre></td></tr></table></figure>

<p>接下來進行初始化 Git Repository 的動作，請輸入以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>此時會跳出已新增 <code>.git</code> 的提示，如下所示：</p>
<p><img src="https://i.imgur.com/QnJrqHG.png" alt="git init"></p>
<p>這一個 <code>.git</code> 檔案就是我們專案資料夾的 Repository，到了這邊已經完成讓 Git 針對此專案進行版控的動作</p>
<h2 id="Git-基本指令"><a href="#Git-基本指令" class="headerlink" title="Git 基本指令"></a>Git 基本指令</h2><p><img src="https://i.imgur.com/scWvYQ1.jpg" alt="git 運作流程"></p>
<p>讓我們借助<a href="https://www.hexschool.com/" target="_blank" rel="external nofollow noopener noreferrer">六角學院</a>所製作的流程圖說明 Git 是如何進行版控的，從上圖可以發現有四大部分需要我們了解，讓我們直接從實際應用操演一番。</p>
<p>新增 <code>index.html</code> 檔案：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> webpack-demo/</span><br><span class="line"> │</span><br><span class="line"><span class="addition">+├─── index.html</span></span><br></pre></td></tr></table></figure>

<p>輸入以下指令查看當前目錄狀態：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>這一道指令可能是你往後最常使用的指令，主要用來查看當前目錄的狀態，如下所示：</p>
<p><img src="https://i.imgur.com/7jvZNjc.png" alt="git status"></p>
<p>從 Git 的提示可以看出，我們的 <code>index.html</code> 檔案目前狀態是 <code>Untracked</code>，關於檔案狀態的部分會再之後的檔案復原獨立文章在做討論，這邊我們只需要記得一個重點就是，<strong>所有剛新增的檔案初始存在區域都是屬於工作目錄</strong>，也就是上圖的第一個地方，請注意，<strong>在沒有提交半次 commit 的檔案，都是不受 Git 所版控的</strong>，也就是說，每一次的工作流程，都必須跑到最後一次 commit 記錄發生時，才能使用檔案復原或切換這些上面曾經展示過的功能，現在讓我們跑下一個工作流程，也就是將工作目錄檔案提交至索引區，執行以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add index.html</span><br></pre></td></tr></table></figure>

<p>or (全部檔案)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>or (在 Git 2.x 之後，效果如同 <code>git add .</code>)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add --all</span><br></pre></td></tr></table></figure>

<p>此時一樣可透過 <code>git status</code> 查看目前狀態：</p>
<p><img src="https://i.imgur.com/grzPncJ.png" alt="git add index.html"></p>
<p>你會發現檔案的狀態又發生改變了，使用<strong>此命令主要是將存在工作目錄的檔案提交至索引內</strong>，也就是圖中的第二個部分，你可能會好奇這一個索引區域是幹嘛用的，以及目前我們到底成功提交 commit 了沒，答案是還沒，先來解釋索引的部分，在 Git 中，我們有時候會反悔當下的 commit，如果存在工作目錄的檔案只需要透過一道指令即可提交 commit，這就會造成多餘的 commit 產生，雖然一樣可透過指令回復並刪除指定的 commit，但相比於設立一個暫存區複雜許多，這一個索引區域本身就是一個暫存區域，主要是讓使用者檢查用，就這麼簡單，之後也會介紹如何將暫存區的檔案回復至工作目錄，接下來就是重頭戲了，執行以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">'新增 index.html'</span></span><br></pre></td></tr></table></figure>

<p>當我們執行了上面這道命令後，<strong>存在索引區的檔案就會被提交至本地數據庫</strong>，也就是圖中第三個部分，這邊的 <code>-m</code> 是指 message 的意思，你可以替這一次提交附加一個訊息，以供未來檢視，可能會有人問，我可以直接打 <code>git commit</code> 就好嗎？此時會跳到 Vim 的命令模式，如下圖：</p>
<p><img src="https://i.imgur.com/oD6TcQa.png" alt="Vie insert"></p>
<p>看來還是得輸入訊息，如果你發現不能打字，可以按 <code>i</code> 進行 insert 的操作，就可以輸入內容了，最後輸入 <code>:wq</code> 完成編輯，也就是 <code>:w</code> 儲存後再 <code>:q</code> 關閉檔案。<strong>不管是使用哪一種方式，絕對不能輸入空的訊息內容</strong>，就算輸入並儲存了，Git 也會提示由於提交訊息為空而中止提交，也就是保持在索引區狀態，這點要注意！</p>
<p>如果你認為預設的 Vim 編輯器不對你的胃口，你也可以更改為記事本或其他編輯器，下面為更改為 <code>VSCode</code> 編譯器的指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.editor <span class="string">'code --wait'</span></span><br></pre></td></tr></table></figure>

<p>到這邊一個基本的 Git 工作流程也就完成了，代表 commit 紀錄已經成功生成。此時可利用以下指令查看所有的 commit 紀錄：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>在使用 <code>git log</code> 指令時，如果加上額外參數，可以看到不一樣的輸出格式，例如加上 <code>--oneline</code> 或 <code>--graph</code> 或 <code>--all</code> 或 <code>-&lt;number&gt;</code>，可參考 <a href="https://git-scm.com/docs/git-log" target="_blank" rel="external nofollow noopener noreferrer">git-log Document</a> 自己慢慢玩，以下為一般輸出結果：</p>
<p><img src="https://i.imgur.com/mMaJ7rN.png" alt="git log"></p>
<p>如果你認為內建的日誌看起來很痛苦，你也可以使用 VSCode 中的 <a href="https://marketplace.visualstudio.com/items?itemName=donjayamanne.githistory" target="_blank" rel="external nofollow noopener noreferrer">Git History</a> 插件或像是 <a href="https://www.sourcetreeapp.com/" target="_blank" rel="external nofollow noopener noreferrer">Sourcetree</a> 等 GUI 圖形介面軟體，尤其是 Sourcetree 的部分，有關這一個軟體會在之後的文章單獨做介紹。</p>
<p>到了這邊，我們已經成功提交了第一個 commit 記錄了，你可以嘗試提交多一點的紀錄，以加深整個流程的印象，可能會有人問，那上面那張圖的第四個部分呢？怎沒有講到？事實上，本地端的 Git 操作就只包含前三個部分，所謂的遠端數據庫就是指像是 GitHub、GitLab、Bitbucket 等平台，這些的本體都是屬於 Git 伺服器，我們一樣可透過 Git 指令將指定目錄推上去，達到遠端存取的作用，但在學習遠端操作前，我們必須先了解 Git 一個相當重要的操作，也就是分支 (branch) 的部分，了解了分支的正確用法，在來使用遠端操作，吸收才會扎實。關於分支的部分，將在下一篇文章做介紹。</p>
<h2 id="設定-Git-指令縮寫"><a href="#設定-Git-指令縮寫" class="headerlink" title="設定 Git 指令縮寫"></a>設定 Git 指令縮寫</h2><p>我們在上面有提到關於 <code>git log</code> 可以加的參數，最後呈現的效果也會不同，但有一個最大的問題是，要打很多字阿！我們可以設定縮寫解決這一個問題：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global alias.s status</span><br></pre></td></tr></table></figure>

<p>此時輸入 <code>git s</code> 就會有 <code>git status</code> 的效果，是不是很方便？如果要增加參數，則必須以字串形式設定：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global alias.l <span class="string">'log --oneline --graph --all'</span></span><br></pre></td></tr></table></figure>

<p>同樣可至 <code>C:\Users\${USER}\.gitconfig</code> 檢查：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[alias]</span><br><span class="line">    s &#x3D; status</span><br><span class="line">    l &#x3D; log --oneline --graph --all</span><br></pre></td></tr></table></figure>

<h2 id="Git-指令回顧"><a href="#Git-指令回顧" class="headerlink" title="Git 指令回顧"></a>Git 指令回顧</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 檢查 Git 版本</span></span><br><span class="line">git --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增全域使用者 (姓名)</span></span><br><span class="line">git config --global user.name <span class="string">'name'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增全域使用者 (信箱)</span></span><br><span class="line">git config --global user.email <span class="string">'email'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增區域使用者 (姓名)</span></span><br><span class="line">git config --<span class="built_in">local</span> user.name <span class="string">'name'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增區域使用者 (信箱)</span></span><br><span class="line">git config --<span class="built_in">local</span> user.email <span class="string">'email'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢查使用者設定</span></span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全域 Git 設定檔</span></span><br><span class="line">C:\Users\<span class="variable">$&#123;USER&#125;</span>\.gitconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 專案 Git 設定檔</span></span><br><span class="line">/.git/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 Git Repositroy</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看當前目錄狀態</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將工作目錄檔案提交至索引區 (指定檔案)</span></span><br><span class="line">git add &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將工作目錄檔案提交至索引區 (全部檔案)</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將工作目錄檔案提交至索引區 (在 Git 2.x 之後，效果如同 git add .)</span></span><br><span class="line">git add --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將索引區檔案提交至本地數據庫</span></span><br><span class="line">git commit -m <span class="string">'message'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 將索引區檔案提交至本地數據庫 (開啟預設編輯器)</span></span><br><span class="line">git commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將預設的 Vim 編輯器改為 VSCode</span></span><br><span class="line">git config --global core.editor <span class="string">'code --wait'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目錄日誌</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目錄日誌 (精簡化)</span></span><br><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目錄日誌 (線路圖)</span></span><br><span class="line">git <span class="built_in">log</span> --graph</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目前日誌 (所有分支)</span></span><br><span class="line">git <span class="built_in">log</span> --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目前日誌 (限制輸出的提交數目 =&gt; 新到舊 =&gt; 可被覆蓋)</span></span><br><span class="line">git <span class="built_in">log</span> -&lt;number&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目錄日誌 (常用配置)</span></span><br><span class="line">git <span class="built_in">log</span> --oneline --graph --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全域設定縮寫</span></span><br><span class="line">git config --global alias.s status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全域設定縮寫 (添加參數)</span></span><br><span class="line">git config --global alias.l <span class="string">'log --oneline --graph --all'</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 版本控制系統 - 分支的建立與合併分支中的快轉機制</title>
    <url>/2020-04-17-git-branch/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上次介紹了 Git 基本的工作流程，這一次來介紹 Git 另一個強大的功能也就是分支 (branch) 的部分。你如果曾上網搜尋 Git 的圖片，你會發現別人的 Git 怎看起來都好複雜，一堆各種顏色的線，這些線就是屬於分支，通常在多人開發時，我們不太可能像之前所操作的，只在 master 這一條主線進行開發，我們會開一條分支專門處理專案的特定部分，最後當我們要做實際呈現時，才會將此分支合併到主線上面，而合併分支在 Git 又有所謂的快轉機制，即 fast-forward，該如何正確的建立分支與合併分支，本篇都會講到。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>分支的建立與合併</li>
<li>fast-forward 與 non-fast-forward 合併差異</li>
<li>重命名指定分支</li>
<li>刪除指定分支</li>
<li>HEAD 作用以及何謂 detached HEAD</li>
<li>Git 指令回顧</li>
</ul>
<h2 id="分支的建立與合併"><a href="#分支的建立與合併" class="headerlink" title="分支的建立與合併"></a>分支的建立與合併</h2><p>讓我們先新增一個專案並提交兩次 commit 紀錄：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir project</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> project</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">touch index.html</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'新增 index.html'</span></span><br><span class="line"></span><br><span class="line">touch all.css</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'新增 all.css'</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>git log</code> 查看目前 commit 紀錄：</p>
<p><img src="https://i.imgur.com/Bv2uj5G.png" alt="git log"></p>
<p>如果有看過上一篇文章的人，應該對上面流程很熟悉了才對，接下來進入重頭戲的部分，讓我們先來看目前本地存在那些分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<p>此時會顯示：</p>
<p><img src="https://i.imgur.com/E5h8awt.png" alt="git branch"></p>
<p>此道命令主要用於查看所有的分支，你就只會看到 <code>master</code> 這條分支，因為我們還尚未建立其他的分支，而 <code>master</code> 分支是初始化 Git 時，同時就被建立出來的，這也是為什麼目前線路圖都只有一條線的原因，接下來使用以下命令建立 <code>dev</code> 分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch dev</span><br></pre></td></tr></table></figure>

<p>此時使用 <code>git log --oneline --graph</code> 查看目前 commit 紀錄：</p>
<p><img src="https://i.imgur.com/gsKEHvq.png" alt="查看 commit 紀錄-1"></p>
<p>你會發現在我們第二個 commit 紀錄的中，新增了綠色字的 <code>dev</code> 分支，因為我們剛剛是在 <code>master</code> 分支的最新狀態下建立此分支，所以此分支的內容就會是與 <code>master</code> 一模一樣，這點要注意，你可以把它想像成一個當前狀態下的複製品，接下來我們要切換到 <code>dev</code> 進行某些操作，執行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout dev</span><br></pre></td></tr></table></figure>

<p>此時會發現右邊的分支名稱改變了：</p>
<p><img src="https://i.imgur.com/8pqcys4.png" alt="git checkout dev"></p>
<p>假設我們要在 <code>dev</code> 分支做某些事情：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch db.json</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'新增 db.json'</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>git log --oneline --graph</code> 查看：</p>
<p><img src="https://i.imgur.com/Gly684g.png" alt="查看 commit 紀錄-2"></p>
<p>你會發現新提交的 commit 紀錄上，只存在 <code>dev</code> 這一個分支，且 <code>HEAD</code> 也指向這一個紀錄上，關於 <code>HEAD</code> 的解釋，下面會再做說明，在來看到 <code>master</code> 分支的部分，它落後了 <code>dev</code> 一個 commit 紀錄，因為我們剛剛是在 <code>dev</code> 分支進行開發，才會導致這樣的結果，接下來我們切回到 <code>master</code> 分支看看，執行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/OUqK2x4.png" alt="切回到 master 分支"></p>
<p>有沒有發現到一個很神奇的事情？我們的 <code>db.json</code> 檔案不見了！因為 <code>master</code> 分支是不存在這一個 commit 的，如果此時你切換到 <code>dev</code> 分支，<code>db.json</code> 檔案就又會出現了，在這邊補充一個指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure>

<p>這道指令同時完成了 <code>git branch dev</code> 與 <code>git checkout dev</code> 的動作，就不用這麼麻煩需要先建立分支後在切換分支。我們繼續上面的進度，接下來進行合併的動作，執行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure>

<p>請注意，我們目前所在的分支是 <code>master</code>，利用 <code>master</code> 分支合併 <code>dev</code> 分支，結果如下：</p>
<p><img src="https://i.imgur.com/HzNb46g.png" alt="git merge dev"></p>
<p>使用 <code>git log --oneline --graph</code> 查看：</p>
<p><img src="https://i.imgur.com/rrg34x6.png" alt="查看 commit 紀錄-3"></p>
<p>你現在一定很困惑，這樣子的結果跟直接在 <code>master</code> 分支提交 commit 紀錄有何差別？確實是沒有差別的，因為我們採用的是 <code>fast-forward</code> 方式合併分支，在線路圖是看不到 <code>db.json</code> 是由 <code>dev</code> 所開發而成的，關於 <code>fast-forward</code> 機制，將在下面做介紹，在這邊我們只需要知道如何建立分支與合併分支就可以了。</p>
<h2 id="fast-forward-與-non-fast-forward-合併差異"><a href="#fast-forward-與-non-fast-forward-合併差異" class="headerlink" title="fast-forward 與 non-fast-forward 合併差異"></a>fast-forward 與 non-fast-forward 合併差異</h2><p>讓我們在次使用 <code>dev</code> 分支並提交兩次 commit 紀錄：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line"></span><br><span class="line">touch bugfix.txt</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'修復 bug'</span></span><br><span class="line"></span><br><span class="line">touch edit.txt</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'編輯文本'</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>git log --oneline --graph</code> 查看：</p>
<p><img src="https://i.imgur.com/0vvhbbb.png" alt="查看 commit 紀錄-4"></p>
<p>剛剛提到的問題是，當我們在此情況下切換到 <code>master</code> 分支並使用 <code>git merge dev</code> 合併 <code>dev</code> 分支，會導致無法紀錄 <code>dev</code> 分支做了什麼事情，這一次我們改使用以下指令試試看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge dev --no-ff</span><br></pre></td></tr></table></figure>

<p>此時會跳出提交 commit 才需輸入的訊息欄位：</p>
<p><img src="https://i.imgur.com/EYriIpE.png" alt="commit 提交訊息"></p>
<p>由於我已更改預設編輯器，你看到的可能是 Vim 的視窗，不過這都沒差，我們可以採用預設的訊息即可，接著儲存後關閉檔案，此時會跳出提交 commit 的訊息，如下所示：</p>
<p><img src="https://i.imgur.com/kluzaio.png" alt="git merge dev --no-ff"></p>
<p>你一定覺得很神奇，為什麼會跳出 commit 提交的訊息呢？不用緊張，先用 <code>git log</code> 壓壓驚：</p>
<p><img src="https://i.imgur.com/QsawRvA.png" alt="取消快轉機制"></p>
<p>神奇的事情發生了，線路圖多了一條分支的線路，也就是 <code>dev</code> 分支的線路圖，且在最新的 commit 紀錄上，新增了一個合併分支的 commit 紀錄，這樣子的結果才能夠清楚辨別哪些 commit 是由那些分支提交而成的，讓我們回過頭來說明何謂 <code>fast-forward</code> 快轉機制：</p>
<ul>
<li><code>fast-forward</code>：將被合併分支紀錄合併至請求合併分支內，意被合併分支紀錄將被刪除，不會有獨立線路可參照</li>
<li><code>non-fast-forward</code>：保留被合併分支的紀錄，意被合併分支紀錄不會被刪除，會有獨立線路可參照</li>
</ul>
<p>以實際層面來講呢，就是 <code>dev</code> 分支提交了許多次 commit 紀錄，但 <code>master</code> 分支沒有任何的變化，此時如果直接在 <code>master</code> 分支合併 <code>dev</code> 分支，預設就會採用 <code>fast-forward</code> 快轉合併，即會造成最初的結果，而使用 <code>--no-ff</code> 則是取消快轉機制，保留被合併分支的全部記錄，這樣就會產生剛剛實驗的結果。</p>
<p>你可能會想，那假設我在 <code>dev</code> 分支提交 commit 紀錄後，又回到 <code>master</code> 分支提交 commit 呢？我們直接來模擬這一個狀況：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line"></span><br><span class="line">touch all.js</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'新增 all.js'</span></span><br><span class="line"></span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">touch all.scss</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'新增 all.scss'</span></span><br></pre></td></tr></table></figure>

<p>這邊必須使用 <code>git log --oneline --graph --all</code> 檢查所有分支狀況：</p>
<p><img src="https://i.imgur.com/nT54FUb.png" alt="查看 commit 紀錄-5"></p>
<p>可能用內建的線路圖不是這麼好懂，推薦大家去下載 <a href="https://www.sourcetreeapp.com/" target="_blank" rel="external nofollow noopener noreferrer">Sourcetree</a> 工具，以下為 Sourcetree 顯示的效果：</p>
<p><img src="https://i.imgur.com/wj4q9T8.png" alt="Sourcetree 線路圖"></p>
<p>這樣看起來比較好懂，<code>master</code> 與 <code>dev</code> 都各提交了一次 commit，像在這種情況下，我們就不需要添加 <code>--no-ff</code> 選項，預設就以使用 <code>non-fast-forward</code>，直接執行 <code>git merge dev</code>：</p>
<p><img src="https://i.imgur.com/14gyq8r.png" alt="查看 commit 紀錄-6"></p>
<p>此時的線路圖就會是如同前面使用 <code>--no-ff</code> 一樣，這也就是 Git 內建的 fast-forward 快轉機制的各種變化，主要就是看你想呈現怎樣的線路圖，假設 <code>master</code> 分支在建立 <code>dev</code> 分支後沒有做任何動作，反而是 <code>dev</code> 提交了多次 commit，這時候如果你想要使用 <code>fast-forward</code> 快轉合併，直接下 <code>git merge dev</code> 就可以了，假設你想要保留分支的 commit 紀錄，就下 <code>git merge dev --no-ff</code> 取消快轉，此時就會呈現各分支的 commit 紀錄。另外一種情況是，在 <code>master</code> 建立了 <code>dev</code> 分支，且 <code>dev</code> 分支也提交了多次 commit 紀錄，但你發現了 Bug，回過頭來修復 <code>master</code> 分支，同時提交了 commit 紀錄，這時 <code>dev</code> 與 <code>master</code> 分支都有較新的 commit 紀錄，此時就不需要使用 <code>--no-ff</code>，因為兩個分支本身已擁有獨自的線路，直接下 <code>git merge dev</code> 就可以了。</p>
<h2 id="重命名指定分支"><a href="#重命名指定分支" class="headerlink" title="重命名指定分支"></a>重命名指定分支</h2><p>先來看一下目前有哪些分支：</p>
<p><img src="https://i.imgur.com/4QmXvpN.png" alt="查看目前有那些分支"></p>
<p>有時候當我們專案進行到一半會想要更改分支的名稱，此時可以使用以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -m dev development</span><br></pre></td></tr></table></figure>

<p>再次使用 <code>git branch</code> 查看目前所有分支：</p>
<p><img src="https://i.imgur.com/GxiZTVP.png" alt="已修改 dev 分支名稱"></p>
<p>此時分支名稱就已經被我們修改了，只需要透過 <code>-m</code> 參數即可修改分支名稱，前面為當前的分支名稱，後面為更改的名稱，且這種作法，就只是單純的改名稱而已，實際上是不影響任何 commit 紀錄的喔。</p>
<h2 id="刪除指定分支"><a href="#刪除指定分支" class="headerlink" title="刪除指定分支"></a>刪除指定分支</h2><p>通常刪除分支有兩種情況，第一種情況是分支尚未被合併至任何分支，如下所示：</p>
<p><img src="https://i.imgur.com/KS3t5iC.png" alt="新增 prod 分支"></p>
<p>從上面可以發現，我們新增了一個 <code>prod</code> 分支並提交一次 commit 紀錄，此時使用以下指令是無法刪除分支的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d prod</span><br></pre></td></tr></table></figure>

<p>會跳出以下錯誤：</p>
<p><img src="https://i.imgur.com/dCxRdfG.png" alt="need use git branch -D prod"></p>
<p>因為我們尚未將 <code>prod</code> 合併至任何分支，才會跳出此錯誤，如果你堅持要刪除這一個分支，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -D prod</span><br></pre></td></tr></table></figure>

<p><code>-D</code> 代表的是強制刪除的意思，那可能就有人會問 <code>-d</code> 是用在哪種情況呢？其實蠻好理解的，就是用在分支已被合併的強況下，我們可以嘗試刪除 <code>development</code> 分支：</p>
<p><img src="https://i.imgur.com/5K5ZAMo.png" alt="使用 git branch -d development"></p>
<p>此時 <code>development</code> 分支就被我們刪除囉，我們可以使用 <code>git log</code> 查看目前線路圖長啥樣：</p>
<p><img src="https://i.imgur.com/uDXOFMr.png" alt="查看 commit 紀錄-7"></p>
<p>你會發現就算分支被刪除了，commit 紀錄點還是在，因為我們所稱的分支只是指向某個 commit 的指標，刪除這個指標並不會造成那些 commit 消失。你可能會問，那我可以恢復剛剛刪除的 <code>development</code> 分支嗎？當然可以啊！記得我們剛剛刪除分支時跳出的 SHA-1 值嗎？就是 <code>2cf5b96</code> 這個東西，它其實就是告訴你這個分支最後存在哪一個 commit 節點，所以我們可以利用這一個值將分支附加到這一個 commit 節點上，執行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch development 2cf5b96</span><br></pre></td></tr></table></figure>

<p>這個指令的意思是「請幫我建立一個叫做 development 的分支，並讓它指向 2cf5b96 這個 commit」，就像是將新增的分支貼在這個 commit 紀錄上的意思，此時我們的分支就又回來囉：</p>
<p><img src="https://i.imgur.com/UgJmyeI.png" alt="查看 commit 紀錄-8"></p>
<p>這時你可能又會問，如果我剛剛沒有記得 <code>2cf5b96</code> 這個 SHA-1 的值呢？就不能回復了？答案是可以的，只不過得使用 <code>git reflog</code> 查看歷程記錄，找到剛剛這一個 SHA-1 值，關於這點將在以後的文章在做介紹。</p>
<h2 id="HEAD-作用以及何謂-detached-HEAD"><a href="#HEAD-作用以及何謂-detached-HEAD" class="headerlink" title="HEAD 作用以及何謂 detached HEAD"></a>HEAD 作用以及何謂 detached HEAD</h2><p>在這邊我們補充一下 HEAD 指標是做什麼用的，先來看我們目前的日誌：</p>
<p><img src="https://i.imgur.com/UgJmyeI.png" alt="查看 commit 紀錄-9"></p>
<p>在我們先前所做的任何嘗試時，你都會看到這一個 <code>HEAD</code> 的指標，也就是目前指向 master 的那一段藍色字，其實理解它非常簡單，<strong>HEAD 是主要用來指向我們目前狀態的東西</strong>，因為我們目前在 <code>master</code> 分支的最新 commit 紀錄上，所以它才會指向 <code>master</code>，假設我們切換到 <code>development</code> 分支：</p>
<p><img src="https://i.imgur.com/XeaMcOQ.png" alt="查看 commit 紀錄-10"></p>
<p>此時它就會指向 <code>development</code> 分支，我們剛剛有提到分支這一個概念是由 commit 紀錄所組成的，這也代表我們可以使用 commit 紀錄的 SHA-1 碼，切換到指定的 commit 紀錄點上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 3c28751</span><br></pre></td></tr></table></figure>

<p>此時前面所稱的分支名稱就會更改成 commit 紀錄點的 SHA-1 編號：</p>
<p><img src="https://i.imgur.com/6fi6xLS.png" alt="切換到指定 commit 紀錄點"></p>
<p>再次查看日誌：</p>
<p><img src="https://i.imgur.com/ptm111U.png" alt="查看 commit 紀錄-11"></p>
<p>有沒有發現 <code>HEAD</code> 改成指向 <code>3c28751</code> 這個 commit 紀錄上了？當 <code>HEAD</code> 沒有指向任何分支時，我們會稱此狀態為斷頭 (detached HEAD)，你不用把它想得太複雜，就只是 HEAD 剛好指向某個沒有分支指著的 commit 罷了，此時你可以查看目前的專案狀態有什麼變化：</p>
<p><img src="https://i.imgur.com/MpHyI8r.png" alt="查看專案是否有變化"></p>
<p>與切換分支的結果相同，專案進度回復到了當時的 <code>3c28751</code> 節點紀錄上，可能會有人問，那我可以在 detached HEAD 狀態下提交 commit 紀錄嗎？嘗試不就知道了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch test.txt</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'新增 test.txt'</span></span><br></pre></td></tr></table></figure>

<p>查看日誌：</p>
<p><img src="https://i.imgur.com/E51alx5.png" alt="查看 commit 紀錄-12"></p>
<p>你會發現 <code>HEAD</code> 又長出了一條分支，嚴格來講不能算是分支，頂多就是一個 commit 記錄才對，名為 <code>070af85</code>，你可能會好奇這樣有什麼影響，影響就是當我們的 HEAD 回到其他分支之後，這一個 commit 紀錄就會被隱藏掉，輸入以下指令回到 <code>master</code> 最新 commit 紀錄上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<p>此時會跳出警告：</p>
<p><img src="https://i.imgur.com/pSJRHOh.png" alt="有一個 commit 被隱藏"></p>
<p>這就是剛剛提到的 commit 被隱藏掉了，當然你也可以使用 <code>git checkout 070af85</code> 回到這個 commit 紀錄上，但如果你堅持保留這一個 commit 紀錄，更好的最法是建立一個分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch ex 070af85</span><br></pre></td></tr></table></figure>

<p>前面有提到，分支的生成會複製當下 commit 紀錄，所以假設你在 <code>070af85</code> 節點使用以上命令，此時的日誌為：</p>
<p><img src="https://i.imgur.com/JTjE16S.png" alt="new commit branch"></p>
<p>以成功在 <code>070af85</code> 生成分支囉，接下來就看你要合併阿還是怎麼樣。</p>
<p>讓我們做點複習，<code>HEAD</code> 主要用來指向我們目前所在的 commit 紀錄上，方便我們四處查看，當我們使用 <code>checkout</code> 切換到沒有分支的 commit 紀錄上時，此狀態稱之為斷頭 <code>detached HEAD</code>，在此狀態也可以進行 commit 提交，但要注意在將 HEAD 切換為分支時，此 commit 紀錄會被隱藏掉，如果堅持保留這一個 commit 紀錄，可以在這一個 commit 紀錄上開立分支，這樣就不會被隱藏了。</p>
<h2 id="Git-指令回顧"><a href="#Git-指令回顧" class="headerlink" title="Git 指令回顧"></a>Git 指令回顧</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看本地所有分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立分支</span></span><br><span class="line">git branch &lt;branch_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切換至指定分支</span></span><br><span class="line">git checkout &lt;branch_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立並切換到指定分支</span></span><br><span class="line">git checkout -b &lt;branch_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合併分支</span></span><br><span class="line">git merge &lt;branch_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合併分支 (採用 non-fast-forward)</span></span><br><span class="line">git merge &lt;branch_name&gt; --no-ff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改分支名稱</span></span><br><span class="line">git branch -m &lt;old_branch_name&gt; &lt;new_branch_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除分支 (分支以合併)</span></span><br><span class="line">git branch -d &lt;branch_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 強制刪除分支 (分支未合併)</span></span><br><span class="line">git branch -D &lt;branch_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在指定節點添加分支</span></span><br><span class="line">git branch &lt;branch_name&gt; &lt;SHA-1&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切換到指定 commit 節點</span></span><br><span class="line">git checkout &lt;SHA-1&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 版本控制系統 - 檔案還原與重置提交</title>
    <url>/2020-04-20-git-reset/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接下來進入重頭戲的部分，那就是版控系統絕對必備的檔案還原功能，前面我們有提到如何切換數據庫版本以做檢查，但你以為只有檢查嗎？它還可以還原阿！假設你今天開發應用時玩壞了某個檔案，透過簡單指令即可將檔案回復成未更動狀態，你說神不神奇？又或者是你發現了一個 Bug，為了修復這個 Bug，想了想還是把剛才提交的 commit 給拆掉重做比較快，這也同樣沒問題，只要你的本地數據庫沒有被刪掉，你想怎麼切、怎麼換、怎麼還原，通通不是問題。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>檔案狀態的生命週期</li>
<li>工作目錄檔案還原</li>
<li>索引區檔案還原</li>
<li>還原至指定版本</li>
<li>使用 Reflog 查看還原紀錄</li>
<li>Git 指令回顧</li>
</ul>
<h2 id="檔案狀態的生命週期"><a href="#檔案狀態的生命週期" class="headerlink" title="檔案狀態的生命週期"></a>檔案狀態的生命週期</h2><p><img src="https://learngitwithme.files.wordpress.com/2016/02/8-1.jpg?w=600" alt="檔案狀態的生命週期"></p>
<p>在我們正式進入到檔案還原章節之前，需先了解 Git 在各個工作流程所顯示的檔案狀態，請先開一個資料夾並新增 <code>index.html</code> 檔案：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir project</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> project</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">touch index.html</span><br></pre></td></tr></table></figure>

<p>此時使用 <code>git status</code> 查看目前檔案狀態：</p>
<p><img src="https://i.imgur.com/AVdGdH3.png" alt="查看檔案狀態-1"></p>
<p>此時 <code>index.html</code> 檔案狀態為 <code>Untracked files</code>，代表此檔案從未加入過資料庫，且流程還處於工作目錄下，請先記錄下這一個狀態，接著繼續將這個檔案提交至索引區：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>查看狀態：</p>
<p><img src="https://i.imgur.com/LgKzuCs.png" alt="查看檔案狀態-2"></p>
<p>此時的檔案狀態更改為了 <code>Changes to be committed</code>，代表此檔案以處於索引區，即將提交至本地數據庫，你可能會想，下方的 <code>new file</code> 字樣需要記嗎？此字樣是代表此檔案從未加入過數據庫，且以處於索引區內，在後面執行還原操作時，是以檔案狀態為依據並輸入指定命令進行還原，也就代表像是 <code>new file</code> 或 <code>modified</code> 字樣，可記可不記，它只是告訴你將要執行的操作而已，讓我們正式將這個檔案提交至本地數據庫：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">'新增 index.html'</span></span><br></pre></td></tr></table></figure>

<p>此時 <code>index.html</code> 檔案已被加入至本地數據庫，這也是我們之前在講解 Git 基本工作流程時的操作，接下來請隨意更改已存在本地數據庫的 <code>index.html</code> 內容，並使用 <code>git status</code> 查看狀態：</p>
<p><img src="https://i.imgur.com/4KMKfMc.png" alt="查看檔案狀態-3"></p>
<p><strong>當已存在本地數據庫的檔案經過修改，此檔案就會回到工作目錄</strong>，須從跑一次 Git 工作流程，與從未存在本地數據庫的檔案差別在於檔案狀態為 <code>Changes not staged for commit</code>，即代表檔案經過更動但還未提交至索引區或本地數據庫，讓我們來看此檔案提交至索引區後狀態為何：</p>
<p><img src="https://i.imgur.com/JVUTgg4.png" alt="查看檔案狀態-4"></p>
<p>此時檔案狀態更改為了 <code>Changes to be committed</code>，與未曾提交至本地數據庫的檔案提交至索引區結果相同，差別在於操作動作更改為了 <code>modified</code> 字樣，代表修改的意思，讓我們先將此檔案提交至本地數據庫再來做總結：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">'修改 index.html'</span></span><br></pre></td></tr></table></figure>

<p>跑過了上面的流程，可以做出以下總結：</p>
<p>Git 將<strong>尚未被提交</strong>的檔案分成了三個區塊：</p>
<ul>
<li><code>Untracked files</code>：代表新創建的檔案從未加入至數據庫，所在區域為工作目錄</li>
<li><code>Changes not staged for commit</code>：已存在數據庫的檔案經過修改回到工作目錄</li>
<li><code>Changes to be committed</code>：從工作目錄提交至索引區的檔案</li>
</ul>
<p>這三大狀態是我們下面使用檔案還原的關鍵，你可能會問，那狀態下的將執行操作會影響下面的範例嗎？答案是不會的，這些都屬於其他操作的範圍，先記這三大檔案狀態就好，接下來讓我們正式進入到檔案還原章節吧！</p>
<h2 id="工作目錄檔案還原"><a href="#工作目錄檔案還原" class="headerlink" title="工作目錄檔案還原"></a>工作目錄檔案還原</h2><p>經過了以上討論，代表存在工作目錄下的檔案只會有以下兩種狀態：</p>
<ul>
<li><code>Untracked files</code>：新建立的檔案，還未被 Git 追蹤</li>
<li><code>Changes not staged for commit</code>：已被 Git 追蹤，但檔案經過修改回到了工作目錄</li>
</ul>
<p>針對以上兩種狀態，Git 分別提供不同指定以進行還原動作，讓我們先來看目前的日誌：</p>
<p><img src="https://i.imgur.com/ZqW1A5p.png" alt="查看目前 commit 紀錄-1"></p>
<p>這兩個 commit 紀錄就是我們上面範例所產生的，接下來讓我們隨意新增一個檔案並查看狀態：</p>
<p><img src="https://i.imgur.com/kpyNWsd.png" alt="查看檔案狀態-5"></p>
<p>從上面結果可以得知，我們新增了一個 <code>all.css</code> 檔案，此時的檔案狀態為 <code>Untracked files</code>，代表此檔案從未加入過數據庫，自然無法紀錄版本內容，那你可能會想，都還沒加入過數據庫，要如何進行檔案還原呢？是要還原什麼？事實上，處於這一狀態的檔案只能進行刪除動作，在這邊的還原就是指檔案還沒有被建立出來時候，讓我們先執行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git clean -n</span><br></pre></td></tr></table></figure>

<p>此時會跳出以下訊息：</p>
<p><img src="https://i.imgur.com/xIzYxZB.png" alt="git clean -n"></p>
<p>這道命令的用意主要是讓我們得知那些檔案將被刪除，接著使用以下命令刪除檔案：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git clean -f</span><br></pre></td></tr></table></figure>

<p>此時會跳出已刪除檔案的訊息：</p>
<p><img src="https://i.imgur.com/z5dTASE.png" alt="git clean -f"></p>
<p>使用 <code>git clean</code> 主要可針對 <code>Untracked files</code> 的檔案進行還原 (刪除) 動作，你可以去檢查剛剛新增的檔案是否還存在，接下來介紹 <code>Changes not staged for commit</code> 狀態的檔案如何進行還原，請先修改已存在數據庫的 <code>index.html</code> 檔案並查看狀態：</p>
<p><img src="https://i.imgur.com/A5yCz0c.png" alt="查看檔案狀態-6"></p>
<p>前面有提到已存在數據庫但被修改過的檔案狀態為 <code>Changes not staged for commit</code>，此時如果你使用 <code>git clean</code> 是沒有任何效果的，<code>git clean</code> 只能作用在 <code>Untrakced files</code> 狀態下的檔案，針對此狀態，我們必須使用以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout index.html</span><br></pre></td></tr></table></figure>

<p>或：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure>

<p>此時會跳出以下訊息：</p>
<p><img src="https://i.imgur.com/N7gJ2cQ.png" alt="git checkout index.html"></p>
<p>你可以針對單一檔案或全部檔案進行還原，還原的結果就是檔案還未修改的狀態。</p>
<p>以上就是針對存在於工作目錄階段的檔案如何進行還原的操作，可能會有人問，那假設我已經提交至索引區了呢？此時你就不能使用以上命令進行還原，必須使用 <code>reset</code> 命令才能還原，讓我們繼續看下去。</p>
<h2 id="索引區檔案還原"><a href="#索引區檔案還原" class="headerlink" title="索引區檔案還原"></a>索引區檔案還原</h2><p>索引區的檔案還原就比較簡單了，因為它只有以下狀態：</p>
<ul>
<li><code>Changes to be committed</code>：從工作目錄提交至索引區的檔案</li>
</ul>
<p>讓我們先隨意新增一個檔案並提交至索引區：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch all.js</span><br><span class="line"></span><br><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>查看狀態：</p>
<p><img src="https://i.imgur.com/JEBzsFO.png" alt="查看檔案狀態-7"></p>
<p>如同前面所說，無論檔案是否被追蹤，只要提交至索引區，狀態就是 <code>Changes to be committed</code>，此時可透過以下指令將此檔案還原至工作目錄：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset HEAD --mixed</span><br></pre></td></tr></table></figure>

<p><code>--mixed</code> 為預設模式，在這邊可以省略，此模式會把暫存區的檔案丟掉，但不會動到工作目錄的檔案，也就是說還原的檔案會留在工作目錄，但不會留在暫存區；而 HEAD 代表我們所要還原到的 commit 紀錄上，你不用想的這麼複雜，讓我們以 Sourcetree 來說明：</p>
<p><img src="https://i.imgur.com/mfgQpBd.png" alt="sourcetree"></p>
<p>你會發現多出了一個 <code>Uncommitted</code> 節點，這一個節點即代表所有未經提交的紀錄，只要經過 <code>git commit</code> 此節點就會消失，進而生成一個有紀錄的 commit 節點，而上面的 <code>HEAD</code> 在這邊就是指 <code>master</code> 指向的這一個節點，之前我們有提到 <code>HEAD</code> 所代表的就是我們當下的狀態，所以上面命令你也可以寫成 <code>git reset master</code>，代表將檔案還原至這一個節點，讓我們來看此時的結果為何：</p>
<p><img src="https://i.imgur.com/fpXvUJP.png" alt="查看檔案狀態-8"></p>
<p>檔案被還原到工作目錄了，由於此檔案當初是以新增的方式進入到 Git 工作流程，所以還原後的狀態才為 <code>Untracked</code>，此時一樣可透過前面介紹的 <code>git clean -f</code> 將檔案進行還原 (刪除)，如果是 <code>Changes not staged for commit</code> 狀態，就必須使用 <code>git checkout .</code> 來進行還原，是不是很簡單？</p>
<p>事實上，如果你想要一氣呵成將存在索引區的檔案直接還原到最初狀態，即 <code>git reset HEAD + git clean -f</code>，你可以使用 <code>reset</code> 的另外一個參數：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset HEAD --hard</span><br></pre></td></tr></table></figure>

<p>在 <code>--hard</code> 模式下，不管是工作目錄還是索引區的檔案都會被丟掉，這個模式在某些情況下特別好用，下面會再做介紹，到這邊我們也完成索引區的檔案還原囉。</p>
<h2 id="還原至指定版本"><a href="#還原至指定版本" class="headerlink" title="還原至指定版本"></a>還原至指定版本</h2><p>在前面我們都是將狀態還原至 HEAD，也就是所謂的最新版本，那如果我們要還原到指定版本呢？比如說最新版本的前三個版本通通都不要了，我要將版本還原至最新版本數起的第四個版本，這時候該怎麼做？此時一樣可透過 <code>reset</code> 指令來完成，讓我們來複習一下各模式的處理方式：</p>
<ul>
<li><code>--mixed</code>：預設的模式，還原後的檔案將丟回工作目錄</li>
<li><code>--hard</code>：還原後的檔案將直接丟掉</li>
<li><code>--soft</code>：還原後的檔案將丟回索引區</li>
</ul>
<p><code>--soft</code> 模式在之前沒有講到，我們在後面會再進行補充，讓我們先來看目前的日誌：</p>
<p><img src="https://i.imgur.com/GO7JN7W.png" alt="查看 commit 紀錄-2"></p>
<p>因為我們之前都是在做新增後還原的動作，所以 commit 記錄才會完全沒有改變，為了方便等等做版本還原的操作，請先隨意新增幾個 commit 紀錄：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch all.js</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'新增 all.js'</span></span><br><span class="line"></span><br><span class="line">touch db.json</span><br><span class="line"></span><br><span class="line">gti add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'新增 db.json'</span></span><br></pre></td></tr></table></figure>

<p>查看目前的日誌：</p>
<p><img src="https://i.imgur.com/TuVrbvY.png" alt="查看 commit 紀錄-3"></p>
<p>版本還原有分所謂的相對路徑與絕對路徑，讓我們先來看相對對路徑的部分，假設我們要還原 <code>HEAD</code> 的前一個版本，也就是 <code>8d8ee63</code> 這一個 commit，請執行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset HEAD^</span><br></pre></td></tr></table></figure>

<p>有沒有發現 <code>^</code> 這一個符號？此符號代表你要還原幾個版本，如果是還原兩個版本，可以寫成 <code>^^</code>，那如果是還原五個版本呢？可以寫成 <code>^^^^^</code>，但這樣的寫法太累了，可以改使用 <code>~</code> 符號代替，<code>~5</code> 代表還原五個版本，所以 <code>^</code> 與 <code>~1</code> 效果是相同的，讓我們來檢查日誌看是否還原成功：</p>
<p><img src="https://i.imgur.com/KsSRh2f.png" alt="查看 commit 紀錄-4"></p>
<p>此時你會發現當初的 <code>e1e9db8</code> 紀錄不見了，也就代表版本還原成功，你可能會好奇，那與 <code>e1e9db8</code> 有關的檔案呢？同樣也不見了嗎？讓我們來看看目前檔案狀態：</p>
<p><img src="https://i.imgur.com/Dcdcf4o.png" alt="查看檔案狀態-9"></p>
<p>還記得之前 <code>--mixed</code> 模式的處理方式嗎？沒有錯，因為我們在使用 <code>reset</code> 指令時，並沒有加入任何的參數，預設就是使用 <code>--mixed</code> 模式，他把還原後的相關檔案全部丟到了工作目錄下，這才導致 <code>e1e9db8</code> 紀錄有關的檔案都存在於工作目錄下，此時一樣可透過 <code>git clean -f</code> 或 <code>git checkout .</code> 將檔案給還原到初始狀態。</p>
<p>你可能會問，我都已經還原到指定版本了，還需要一個一個看是什麼狀態並使用相對應的指令進行還原，這樣會不會太麻煩？還記得之前介紹地的 <code>--hard</code> 模式嗎？此模式可以把有關的檔案全部進行還原，就是全部丟掉的意思啦，假設我們以剛才的情況來說，回復到 <code>HEAD</code> 的前一個版本並使用 <code>--hard</code> 模式將有關的檔案全部丟掉，此時的狀態就會變為：</p>
<p><img src="https://i.imgur.com/jXg9Ru5.png" alt="查看 commit 紀錄-4"></p>
<p>與 <code>e1e9db8</code> 有關的檔案就都被我們丟掉了，講解完了 <code>--mixed</code> 與 <code>--hard</code> 模式，大家應該就都知道 <code>--soft</code> 的用法了，沒錯，就是把有關的檔案全部都丟到索引區內，在這邊就不進行示範了，各位可以自己試試看。</p>
<p>上面是以相對路徑方式還原版本，你也可以使用絕對路徑的方式進行還原，先讓我們使用 <code>git reflog</code> 查看並還原到最一開始的狀態：</p>
<p><img src="https://i.imgur.com/TuVrbvY.png" alt="查看 commit 紀錄-5"></p>
<p>關於 <code>Reflog</code> 的使用方式，下面會再做介紹，先讓我們回到主題，目前的 commit 紀錄就是我們最一開始的狀態，假設我們要還原到 <code>3c85d93</code> 這一個節點，相對路徑寫法是 <code>git reset HEAD~2</code>，而絕對路徑是寫成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gti reset 3c85d93 --hard</span><br></pre></td></tr></table></figure>

<p>不要懷疑，就是這麼簡單，只需要撰寫節點的 SHA-1 編碼即可，此時的檔案狀態為：</p>
<p><img src="https://i.imgur.com/Lr1yS2c.png" alt="查看檔案狀態-10"></p>
<p>因為我們使用了 <code>--hard</code> 模式，所以與之相關的檔案都被我們丟掉了，是不是很方便阿？</p>
<h2 id="使用-Reflog-查看還原紀錄"><a href="#使用-Reflog-查看還原紀錄" class="headerlink" title="使用 Reflog 查看還原紀錄"></a>使用 Reflog 查看還原紀錄</h2><p>在前面我們有偷偷透過 <code>git reflog</code> 查看我們還原紀錄並還原，你可能會好奇，難道 reset 後的檔案可以 reset 回來？沒有錯，確實是可以的，我們拿前面的範例來看：</p>
<p><img src="https://i.imgur.com/V7jvQyn.png" alt="查看 commit 紀錄-6"></p>
<p>這是我們剛剛還原的結果，那假設我後悔了，我想要還原到剛剛還原前的狀態呢？此時一定有人會去查看剛剛還原前的最新 commit 紀錄，並且使用以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset e1e9db8</span><br></pre></td></tr></table></figure>

<p>沒錯！這樣子就可以還原到尚未使用還原指令前的狀態，但假如說你沒有記下那一個狀態的 SHA-1 值呢？是不是就不能還原了？當然還是可以啊！但必須透過 <code>git reflog</code> 找回這一個 SHA-1 標號：</p>
<p><img src="https://i.imgur.com/oLHZjLj.png" alt="查看 commit 紀錄-7"></p>
<p>當 <code>HEAD</code> 有移動時 (例如切換分支或還原版本)，Git 就會在 Reflog 裡記上一筆，代表如果你做了任何傻事，都可以到這邊查找並進行復原，是不是很棒？這也是為什麼只要你曾將檔案加入過數據庫，絕大部份資料都可以找得回來的原因。</p>
<p>這樣子看起來，就算我們把 Git 給玩壞了，一樣可以使用 Reflog 還原到最初的狀態，但這邊要注意，Reflog 也是有保存時間的，預設來說 Git 會幫你保存這些歷史紀錄 90 天，如果這些紀錄中已經有些 commit 物件不在分支線上，則預設保留 30 天。但這些時間都是可以更改的，假如說你的硬碟無限大，永遠不想刪除紀錄，可以考慮設定如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global gc.reflogExpire <span class="string">'never'</span></span><br><span class="line">git config --global gc.reflogExpireUnreachable <span class="string">'never'</span></span><br></pre></td></tr></table></figure>

<p>在這邊補充一點，如果你想要查看 <code>Reflog</code> 內紀錄的時間，可以使用以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reflog --date=iso</span><br></pre></td></tr></table></figure>

<h2 id="Git-指令回顧"><a href="#Git-指令回顧" class="headerlink" title="Git 指令回顧"></a>Git 指令回顧</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看將被 git clean -f 還原的對象</span></span><br><span class="line">git clean -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 還原全部工作目錄檔案 (未追蹤)</span></span><br><span class="line">git clean -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 還原指定工作目錄檔案 (以追蹤)</span></span><br><span class="line">git checkout &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 還原全部工作目錄檔案 (以追蹤)</span></span><br><span class="line">git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 還原索引區檔案 (丟回工作目錄)</span></span><br><span class="line">git reset HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 還原索引區檔案 (同上，預設選項)</span></span><br><span class="line">git reset HEAD --mixed</span><br><span class="line"></span><br><span class="line"><span class="comment"># 還原索引區檔案 (全部丟掉)</span></span><br><span class="line">git reset HEAD --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 還原至前兩個版本 (丟回工作目錄)</span></span><br><span class="line">git reset HEAD^^ --mixed</span><br><span class="line"></span><br><span class="line"><span class="comment"># 還原至前三個版本 (丟回索引區)</span></span><br><span class="line">git reset HEAD~3 --soft</span><br><span class="line"></span><br><span class="line"><span class="comment"># 還原至指定版本 (使用絕對路徑，全部丟掉)</span></span><br><span class="line">git reset &lt;SHA-1&gt; --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看還原紀錄</span></span><br><span class="line">git reflog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看還原紀錄 (顯示時間)</span></span><br><span class="line">git reflog --date=iso</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 reflog 保存時間 (存在分支線上，預設 90 天改為無限)</span></span><br><span class="line">git config --global gc.reflogExpire <span class="string">'never'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 reflog 保存時間 (不存在分支線上，預設 30 天改為無限)</span></span><br><span class="line">git config --global gc.reflogExpireUnreachable <span class="string">'never'</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>w3HexSchool</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 版本控制系統 - 遠端數據庫託管與操作</title>
    <url>/2020-04-18-git-remote/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本地數據庫的操作已經介紹的差不多了，這次來講如何將本地數據庫推至遠端數據庫，這其實也是整個 Git 流程最重要的步驟，當我們成功將本地專案推至像是 GitHub 或 Bitbucket 等平台時，也就代表我們已經可以異地操作這一個專案了，你是否曾遇到過開發到一半的專案需要到另外一台電腦繼續操作的情況？這時你可能會使用像是 USB 等儲存裝置，但你不覺得這樣效率很差嗎？何況如果你忘記帶 USB 呢？只要你的專案已經存在遠端數據庫，且當前操作的電腦有安裝 Git，透過簡單指令即可將專案同步回本地。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>在 GitHub 開一個遠端數據庫</li>
<li>設定 GitHub SSH 金鑰</li>
<li>將本地數據庫 Push 至 GitHub</li>
<li>將遠端數據庫 Clone 到本地</li>
<li>使用 Fetch 獲取遠端數據庫修改內容</li>
<li>刪除遠端分支</li>
<li>Git 指令回顧</li>
</ul>
<h2 id="在-GitHub-開一個遠端數據庫"><a href="#在-GitHub-開一個遠端數據庫" class="headerlink" title="在 GitHub 開一個遠端數據庫"></a>在 GitHub 開一個遠端數據庫</h2><p>首先我們當然要有一個遠端數據庫託管我們的專案，在這邊示範 GitHub 的流程。</p>
<p>註冊 <a href="https://github.com/join?source=header-home" target="_blank" rel="external nofollow noopener noreferrer">GitHub</a> 帳號：</p>
<p><img src="https://i.imgur.com/n0pIThT.png" alt="Register GitHub"></p>
<p>點擊畫面左邊的 New 按鈕，新增一個 Repository：</p>
<p><img src="https://i.imgur.com/cGtent2.png" alt="New Repository"></p>
<p>此為 Repository 的各種設定，Name 為必要設定，其他都用預設值就好，反正後面還可以更改：</p>
<p><img src="https://i.imgur.com/q2mQFRg.png" alt="Repository First Setting"></p>
<p>成功顯示：</p>
<p><img src="https://i.imgur.com/iPyCrV1.png" alt="Repository success"></p>
<p>當你跑出以上畫面即代表遠端數據庫已成功被建立，你會看到一堆 Git 的指令，這些在下面都會做介紹，接下來進入本地數據庫連接遠端數據庫的部分。</p>
<h2 id="設定-GitHub-SSH-金鑰"><a href="#設定-GitHub-SSH-金鑰" class="headerlink" title="設定 GitHub SSH 金鑰"></a>設定 GitHub SSH 金鑰</h2><p>在我們將本地數據庫連結遠端數據庫之前，有一個很重要的觀念是關於 SSH 與 HTTPS 的差異，GitHub 為了保證當前使用者就是此 Repository 的授權用戶，提供了兩種的驗證方式：</p>
<ul>
<li>SSH：已經將金鑰設定完成，與遠端數據庫交流時不需輸入帳密 (可針對私鑰使用設定密碼)</li>
<li>HTTPS：與遠端數據庫交流時需輸入 GitHub 帳密，如果不需要輸入通常是帳密已存在電腦裡</li>
</ul>
<p>GitHub 本身是推薦使用 HTTPS，使用起來會比較安全，且對於初學者來說較友善，看到登入視窗直接輸入帳密就完成了；但我個人比較推薦使用 SSH 的方式，並針對私鑰設定使用密碼，這樣在每次與遠端數據庫交流時，都會跑出輸入密碼的提示，你可能會想，這樣不是很麻煩嗎？但換個角度去想，假設你在提交的途中後悔了呢？我是不是就可以避免此次的提交？類似 Git 要設立索引區的用意，下面將介紹 SSH 該如何設定並提交至 GitHub 上面。</p>
<p>開啟終端機並輸入以下指令，用以生成 SSH Key：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>

<ul>
<li>Created directory：生成路徑 (採預設即可)</li>
<li>Enter passphrase：私鑰密碼 (可為空值，但建議輸入，原因上面有提到)</li>
<li>Enter same passphrase again：再次輸入密碼</li>
<li>… 金鑰相關資訊</li>
</ul>
<p>成功生成 SSH Key：</p>
<p><img src="https://i.imgur.com/5G0gngn.png" alt="ssh-keygen created"></p>
<p>將 <code>C:\Users\${USER}\.ssh\id_rsa.pub</code> 公鑰內容提交至 GitHub 上：</p>
<p>位置：GitHub &gt; Setting &gt; SSH and GPG keys</p>
<p><img src="https://i.imgur.com/0mX7Tb5.png" alt="SSH Key push"></p>
<p>點擊 New SSH Key 並將剛剛複製內容貼到 Key 欄位，最後按 Add SSH key 提交公鑰，完成圖如下：</p>
<p><img src="https://i.imgur.com/NoCocJc.png" alt="SSH Key success"></p>
<p>到這邊就已經完成 GitHub SSH 金鑰設定的部分，下面我們就可以透過 SSH 方式與遠端數據庫交流囉。</p>
<h2 id="將本地數據庫-Push-至-GitHub"><a href="#將本地數據庫-Push-至-GitHub" class="headerlink" title="將本地數據庫 Push 至 GitHub"></a>將本地數據庫 Push 至 GitHub</h2><p>讓我們先開一個專案資料夾並提交兩次 commit 紀錄：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir project</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> project</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">touch index.html</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'新增 index.html'</span></span><br><span class="line"></span><br><span class="line">touch all.css</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'新增 all.css'</span></span><br></pre></td></tr></table></figure>

<p>輸入 <code>git log</code> 查看目前 commit 紀錄：</p>
<p><img src="https://i.imgur.com/2m89i24.png" alt="git log"></p>
<p>如果有看過前面文章的人，應該對這些流程非常熟悉了才對，將下來進入重頭戲的部分，輸入以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:awdr74100/git-remote-demo.git</span><br></pre></td></tr></table></figure>

<p>說明：</p>
<ul>
<li><code>git remote add</code>：添加一個遠端數據庫</li>
<li><code>origin</code>：後面那段遠端數據庫位址的名稱 (可隨意設置)</li>
<li><code>git@github.com:xxx</code>：遠端數據庫位址 (SSH 方式)</li>
<li><code>https://github.com/xxx</code>：遠端數據庫位址 (HTTPS 方式)</li>
</ul>
<p>遠端數據庫位址可在 Repository 頁面找到，前面的圖片就有照到。當我們輸入以上指令時，可以到 <code>/.git/config</code> 專案配置檔中檢查是否成功添加遠端數據庫位址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    url &#x3D; git@github.com:awdr74100&#x2F;git-remote-demo.git</span><br><span class="line">    fetch &#x3D; +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;*</span><br></pre></td></tr></table></figure>

<p>或是直接使用 <code>git remote -v</code> 查看所有以添加的遠端數據庫資訊：</p>
<p><img src="https://i.imgur.com/qjBsgX7.png" alt="git remote -v"></p>
<p>當出現以上畫面即代表遠端數據庫已被成功添加，一個本地數據庫可以添加無數個遠端數據庫，你也可以使用以下指令針對遠端數據庫做些修改：</p>
<ul>
<li>修改已註冊遠端數據庫位址：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote <span class="built_in">set</span>-url origin https://github.com/awdr74100/git-remote-demo.git</span><br></pre></td></tr></table></figure>

<ul>
<li>修改已註冊遠端數據庫名稱：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote rename origin github</span><br></pre></td></tr></table></figure>

<ul>
<li>刪除已註冊遠端數據庫：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure>

<p>簡單來講呢，你可以把它想像成宣告了 <code>origin</code> 這一個變數，並且賦予了遠端數據庫的位址，變數名稱可以自由的命名，但一般主要的遠端數據庫我們都會把它命名為 <code>origin</code>，其他特殊作用的遠端數據庫才會刻意命名，後面的操作就都會是以這一個變數名稱為主，接下來執行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>說明：</p>
<ul>
<li><code>git push</code>：將本地指定分支推送至遠端數據庫</li>
<li><code>-u</code>：同 <code>--set-upstream</code>，設定推送分支的上游</li>
<li><code>origin</code>：要推向哪個遠端數據庫，寫名稱即可 (就是指前面說的 <code>origin</code>)</li>
<li><code>master</code>：指定本地 <code>master</code> 分支進行推送，如果存在 <code>master</code> 分支即合併，不存在即新增</li>
</ul>
<p>這一段可能會比較不好理解，讓我們將上面這段命令完整的寫出來：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --<span class="built_in">set</span>-upstream origin master:master</span><br></pre></td></tr></table></figure>

<p>首先是 <code>-u</code> 的部分，等同於 <code>--set-upstream</code>，可以使 <code>master</code> 這一個指定的分支開始追蹤遠端的分支，只要做過一次 <code>git push -u origin master</code>，並且成功 Push 出去，本地的 <code>master</code> 分支就會被設定去追蹤遠端的 <code>origin/master</code> 分支，往後再 <code>master</code> 分支直接使用 <code>git push</code> 命令就會推向當時設定的 <code>origin/master</code> 分支，反之，如果沒有設定 <code>-u</code> 就使用 <code>git push</code>，就會導致以下錯誤：</p>
<p><img src="https://i.imgur.com/OUCX1Hl.png" alt="git 尚未設置上游"></p>
<p>可能有人會想，那我是否可以在不設定 <code>-u</code> 的情況下使用以下指令呢？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>答案是可以的，我們為什麼要設定 <code>-u</code> 就是要方便往後在直接使用 <code>git push</code> 命令時，Git 能夠知道此命令該推向何處，上面這種寫法明確的定義推向何處，結果與 <code>git push -u origin master</code> 一樣，只是我們習慣在第一次推送時，在明確定義該推向何處時，同時也設置往後這個位置就是預設推向的位置，有關 <code>-u</code> 的設定一樣可以到 <code>/.git/config</code> 尋找：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[branch &quot;master&quot;]</span><br><span class="line">    remote &#x3D; origin</span><br><span class="line">    merge &#x3D; refs&#x2F;heads&#x2F;master</span><br></pre></td></tr></table></figure>

<p>在這邊補充一點，如果你往後 <code>master</code> 這個以設定 <code>-u</code> 的分支，想要單純使用 <code>git push</code> 就推向其他的分支，你可以解除 <code>-u</code> 的設定或直接覆蓋掉 <code>-u</code> 的設定：</p>
<ul>
<li>移除 <code>upstream</code> 設定 (當前所在分支為 <code>master</code> =&gt; 設定 <code>master</code> 分支)：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --<span class="built_in">unset</span>-upstream</span><br></pre></td></tr></table></figure>

<ul>
<li>移除 <code>upstream</code> 設定 (當前所在分支不是 <code>master</code> =&gt; 設定 <code>master</code> 分支)：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --<span class="built_in">unset</span>-upstream master</span><br></pre></td></tr></table></figure>

<ul>
<li>設定 <code>upstream</code> 存在即覆蓋 (當前所在分支為 <code>master</code> =&gt; 設定 <code>master</code> 分支)：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -u origin/master</span><br></pre></td></tr></table></figure>

<ul>
<li>設定 <code>upstream</code> 存在即覆蓋 (當前所在分支為 <code>master</code> =&gt; 設定 <code>master</code> 分支)：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -u origin/master master</span><br></pre></td></tr></table></figure>

<p>相信到這邊各位已經了解 <code>upstream</code> 的作用了，再來是前面提到的 <code>master:master</code> 部分，這個就比較簡單了，前面的 <code>master</code> 代表本地端的分支，後面的 <code>master</code> 代表遠端的分支，如果你把遠端的 <code>master</code> 改為 <code>develop</code>，那遠端的分支名稱就會是 <code>develop</code>，但內容還是本地端的 <code>master</code> 分支，就只是單純的改名子而已，接下來我們來看最初執行 <code>git push -u origin master</code> 後的 GitHub 頁面：</p>
<p><img src="https://i.imgur.com/p7h4b4r.png" alt="git push 後的頁面"></p>
<p>你會發現我們的本地數據庫已成功推至遠端數據庫了，且分支名稱為 <code>master</code>，假設你在推送時只有寫 <code>master</code> 單個本地分支名稱，遠端分支的名稱就會直接採用這一個本地端分支的名稱，讓我們在練習一次：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b develop</span><br><span class="line"></span><br><span class="line">touch db.json</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'增加 db.json'</span></span><br></pre></td></tr></table></figure>

<p>這一次我們在本地端開了一個名為 <code>develop</code> 的分支，執行以下命令進行推送：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin develop</span><br></pre></td></tr></table></figure>

<p>或是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin develop</span><br></pre></td></tr></table></figure>

<p>請注意，你沒有必要切換到 <code>master</code> 分支才進行推送，你的 Git 命令本身已經添加本地端的哪個分支，除非你要使用 <code>git push</code> 方式進行推送，這時就需要切換到要推送的那個分支，<strong>每一個分支都可以設定一個 upstream</strong>，我自己是習慣將每一個分支都設定好 <code>upstream</code>，日後就可以直接使用 <code>git push</code> 推至指定位置了，工程師就是要少打點字啊！我們來看現在的遠端數據庫有什麼變化：</p>
<p><img src="https://i.imgur.com/dCYbWTC.png" alt="push 新分支"></p>
<p>記得將頁面預設呈現的 <code>master</code> 分支切換到 <code>develop</code> 分支，從上面結果可以得知，我們的本地端數據庫已成功同步到遠端數據庫，接下來換本地該如何拉取遠端數據庫的部分：</p>
<h2 id="將遠端數據庫-Clone-到本地"><a href="#將遠端數據庫-Clone-到本地" class="headerlink" title="將遠端數據庫 Clone 到本地"></a>將遠端數據庫 Clone 到本地</h2><p>我們已經完成將本地數據庫推送至遠端了，將下來示範如何將遠端數據庫克隆回本地：</p>
<p>先確認目前有哪些分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>

<p>你也可以使用 <code>-r</code> 僅查看遠端分支，但我習慣使用 <code>-a</code> 直接查看所有分支，結果如下：</p>
<p><img src="https://i.imgur.com/iOltleD.png" alt="git branch -a"></p>
<p>結果如同預期，因為我們已經分別將 <code>master</code>、<code>develop</code> 分支推至遠端了，所以遠端也存在同名的分支，接下來執行已下命令：</p>
<ul>
<li>克隆遠端數據庫的預設分支至本地：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:awdr74100/git-remote-demo.git gh-demo</span><br></pre></td></tr></table></figure>

<ul>
<li>克隆遠端數據庫的指定分支至本地：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master git@github.com:awdr74100/git-remote-demo.git gh-demo</span><br></pre></td></tr></table></figure>

<p>剛剛在 Push 時是使用 SSH 方式驗證，在 Clone 這邊我們也一樣使用 SSH 方式連結，事實上，你想要改成 HTTPS 方式也沒差，如果你想要克隆非 <code>master</code> (origin/HEAD) 的分支，可以加上 <code>-b</code> 參數，後面帶入想要克隆的分支，最後面的 <code>gh-demo</code> 代表的是遠端數據庫要放在本地端的哪個資料夾，如果不存在即建立，如果不寫放置資料夾，預設會在當下命令路徑生成遠端數據庫名稱</p>
<p><img src="https://i.imgur.com/HaPt1Jc.png" alt="git clone"></p>
<p>切換並查看剛剛 Clone 下來的數據庫：</p>
<p><img src="https://i.imgur.com/9BYZTBO.png" alt="git clone 分支缺少"></p>
<p>到這邊我們已經成功將遠端數據庫 Clone 下來了，但在這邊還有一個問題，從上圖可以發現，這一個數據庫缺少了 <code>develop</code> 分支，預設情況下，使用 <code>git clone</code> 命令只會將 <code>master</code> (origin/HEAD) 分支給複製下來，可能會有人想，我可以直接 <code>git checkout origin/develop</code> 就好了啊，但這樣的作法是無法在本地端工作的，正確的做法應該是將遠端數據庫的分支一併給同步下來，可以使用以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -t origin/develop</span><br></pre></td></tr></table></figure>

<p>再次查看所有分支：</p>
<p><img src="https://i.imgur.com/EMfHFPi.png" alt="git checkout -t"></p>
<p><code>-t</code> 全名為 <code>--track</code>，此道命令可將遠端分支建立至本地並追蹤 (即設置 upstream)，此時我們的 <code>gh-demo</code> 數據庫就會與最之前的 <code>project</code> 數據庫一模一樣囉，在這邊補充幾個指令：</p>
<ul>
<li>將遠端分支建立至本地並追蹤 (自定義名稱)：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b develop origin/develop</span><br></pre></td></tr></table></figure>

<p>這道指令與 <code>git checkout -t origin/develop</code> 結果相同，差別在於可自定義名稱。</p>
<ul>
<li>將遠端分支建立至本地並追蹤 (自動辨識遠端是否存在同名分支)：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout develop</span><br></pre></td></tr></table></figure>

<p>這道命令與使用 <code>git checkout -t origin/develop</code> 結果相同，Git 會檢查這一個分支是否洽好存在同名遠端分支，如果存在，即在本地創建這一個分支並追蹤遠端分支。</p>
<p>以上幾道命令結果都一樣，看你認為哪一個比較好記。到這邊我們已經成功將遠端數據庫克隆至本地，以後只要在有 Git 環境的電腦中，都可以達到異地開發的效果，再也不需要使用 USB 囉。</p>
<h2 id="使用-Fetch-獲取遠端數據庫修改內容"><a href="#使用-Fetch-獲取遠端數據庫修改內容" class="headerlink" title="使用 Fetch 獲取遠端數據庫修改內容"></a>使用 Fetch 獲取遠端數據庫修改內容</h2><p>到這邊還有一個情境是假設本地端已將數據庫推至遠端，在異地開發時，我們也從遠端複製一份到本地端並提交了數次 commit，最後 Push 到遠端，那一開始已存在本地端檔案但資料落後於遠端的這個人該怎麼辦？讓我們來模擬這個狀況：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> project</span><br><span class="line"></span><br><span class="line">git checkout develop</span><br><span class="line"></span><br><span class="line">touch all.js</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'新增 all.js'</span></span><br><span class="line"></span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">git merge develop --no-ff</span><br></pre></td></tr></table></figure>

<p>查看日誌：</p>
<p><img src="https://i.imgur.com/tYT26fr.png" alt="查看 commit 紀錄-1"></p>
<p>你會發現我們本地端的兩個分支已經超前遠端分支的紀錄，接下來進行 Push：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --all origin</span><br></pre></td></tr></table></figure>

<p>在我們前面都是介紹單個分支的推送，事實上，你也可以添加 <code>--all</code> 用以推送本地端所有分支的更新，而 <code>origin</code> 就是之前介紹的主機名稱，再看一次日誌：</p>
<p><img src="https://i.imgur.com/tfJx30q.png" alt="查看 commit 紀錄-2"></p>
<p>看起來我們的本地端內容已經被同步到遠端數據庫了，接著換剛剛克隆下來的數據庫：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> gh-demo</span><br></pre></td></tr></table></figure>

<p>執行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure>

<p>查看日誌：</p>
<p><img src="https://i.imgur.com/HjhElq0.png" alt="查看 commit 紀錄-3"></p>
<p>你會發現本地參照的遠端分支已被更新，這也就是 <code>git fetch</code> 的功用，它會將本地存在的分支從遠端給一併拉下來，接著執行合併動作：</p>
<ul>
<li>在 <code>master</code> 分支：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>develop</code> 分支：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge origin/develop</span><br></pre></td></tr></table></figure>

<p>查看日誌：</p>
<p><img src="https://i.imgur.com/4k9SaRb.png" alt="查看 commit 紀錄-4"></p>
<p>大功告成！我們最初的本地端數據庫也被同步完成囉！我們可以針對上面 <code>git fetch</code> 指令做點修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch origin master:temp</span><br></pre></td></tr></table></figure>

<p>查看日誌：</p>
<p><img src="https://i.imgur.com/ysGyR5H.png" alt="查看 commit 紀錄-5"></p>
<p>預設情況下，<code>git fetch</code> 會把所有的遠端分支拉下來，而上面這到命令的意思就如同前面所講到的 <code>master:master</code>，只拉取遠端的 <code>master</code> 分支並同步到本地端的 <code>temp</code> 分支，不存在即創建，之後我們一樣透過 <code>git merge temp</code> 就可以拿到最新內容了。</p>
<p>這邊我們再補充一個指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p><code>git pull</code> 與 <code>git fetch</code> 同樣都是用來將遠端數據庫給拉下來，不同的地方在於 <code>git pull</code> 會直接將遠端分支合併至本地分支，你可以把它想成 <code>git fetch</code> 與 <code>git merge</code> 的組合技，你就不需要親自合併分支了，方便了不少。</p>
<p>我個人比較偏好 <code>git fetch</code> 的方式獲取遠端內容，通常在多人開發時，有很大的機率這一個遠端分支與本地分支合併時會發生衝突，使用 <code>git fetch</code> 就可先透過 <code>git diff</code> 比對差異，將衝突內容作修改，避免合併時可能出現的問題，而 <code>git pull</code> 確實比較方便，但如果遠端與本地分支發生衝突，就會直接跳出警告，等著我們慢慢去修，我不太喜歡這樣的做法，各位可以自行試試。</p>
<h2 id="刪除遠端分支"><a href="#刪除遠端分支" class="headerlink" title="刪除遠端分支"></a>刪除遠端分支</h2><p>在這邊我們補充一下如何刪除遠端的分支，其實原理如同我們前面所提到的 <code>master:master</code> 概念，如果你今天想要移除任何的遠端分支，只需要 Push 一個空的分支即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin :develop</span><br></pre></td></tr></table></figure>

<p>在 Git v1.7 之後的版本可以使用 <code>--delete</code> 參數：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --delete origin develop</span><br></pre></td></tr></table></figure>

<p>顯示遠端分支已被刪除：</p>
<p><img src="https://i.imgur.com/jUhYkHE.png" alt="刪除遠端分支"></p>
<p>此時一樣可以使用 <code>git log</code> 查看日誌，你會發現遠端的分支被我們刪除囉。</p>
<h2 id="Git-指令回顧"><a href="#Git-指令回顧" class="headerlink" title="Git 指令回顧"></a>Git 指令回顧</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新增遠端數據庫</span></span><br><span class="line">git remote add &lt;repo_name&gt; &lt;url&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有以添加的遠端數據庫資訊</span></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改已註冊遠端數據庫位址</span></span><br><span class="line">git remote <span class="built_in">set</span>-url &lt;repo_name&gt; &lt;new url&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改已註冊遠端數據庫名稱</span></span><br><span class="line">git remote rename &lt;old_repo_name&gt; &lt;new_repo_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除已註冊遠端數據庫</span></span><br><span class="line">git remote remove &lt;repo_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定分支上傳至遠端數據庫 (同時設定 upstream)</span></span><br><span class="line">git push -u &lt;repo_name&gt; &lt;local_branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定分支上傳至遠端數據庫 (指定不同名稱)</span></span><br><span class="line">git push &lt;repo_name&gt; &lt;local_branch&gt;:&lt;remote_branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定分支上傳至遠端數據庫</span></span><br><span class="line">git push &lt;repo_name&gt; &lt;local_branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分支移除 `upstream`</span></span><br><span class="line">git branch --<span class="built_in">unset</span>-upstream &lt;local_branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分支設定 `upstream` 存在即覆蓋</span></span><br><span class="line">git branch -u &lt;repo_name&gt;/&lt;remote_branch&gt; &lt;local_branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看遠端分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有分支 (包含遠端與本地)</span></span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆遠端數據庫的預設分支至本地</span></span><br><span class="line">git <span class="built_in">clone</span> &lt;url&gt; &lt;folder&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆遠端數據庫的指定分支至本地</span></span><br><span class="line">git <span class="built_in">clone</span> -b &lt;remote_branch&gt; &lt;url&gt; &lt;folder&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將遠端分支建立至本地並追蹤</span></span><br><span class="line">git checkout -t &lt;repo_name&gt;/&lt;remote_branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將遠端分支建立至本地並追蹤 (可自訂名稱)</span></span><br><span class="line">git checkout -b &lt;local_branch&gt; &lt;repo_name&gt;/&lt;remote_branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將遠端分支建立至本地並追蹤 (自動辨識遠端是否存在同名分支)</span></span><br><span class="line">git checkout &lt;remote_branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上傳至遠端數據庫 (全部分支)</span></span><br><span class="line">git push --all &lt;repo_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上傳至遠端數據庫 (全部分支，同時設定 upstream)</span></span><br><span class="line">git push -u &lt;repo_name&gt; --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下載遠端數據庫 (所有本地存在分支)</span></span><br><span class="line">git fetch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合併遠端分支 (將本地分支更新為最新狀態)</span></span><br><span class="line">git merge &lt;repo_name&gt;/&lt;remote_branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下載遠端數據庫 (指定分支)</span></span><br><span class="line">git fetch &lt;repo_name&gt; &lt;remote_branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下載遠端數據庫 (放至指定分支，不存在及建立)</span></span><br><span class="line">git fetch &lt;repo_name&gt; &lt;remote_branch&gt;:&lt;local_branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下載遠端數據庫 (等同於 git fetch + git merge)</span></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除遠端分支</span></span><br><span class="line">git push :&lt;remote_branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除遠端分支 (v1.7 以後版本可使用)</span></span><br><span class="line">git push --delete &lt;repo_name&gt; &lt;remote_branch&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 版本控制系統 - 分支合併衝突與解決辦法</title>
    <url>/2020-04-22-git-conflict/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前我們有提到 Git 主要被使用在多人協作開發，每個人各自完成屬於自己的工作，最後透過合併即可完成應用，但想的簡單，實作起來卻有些困難，過程中難免會有意外發生，比如說 A 同事與 B 同事先前在初始檔案各開了一個分支，但 A 同事發現這一份檔案存在 Bug，於是做了修復的動作，而 B 同事正好也發現了這一個 Bug 也做了修復，此時如果進行合併，就會造成所謂的合併衝突，此狀況不只會發生在本地分支，遠端分支也同樣會發生，該如何解決此類的衝突，也就是本篇的主題。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>本地分支合併衝突</li>
<li>遠端分支合併衝突</li>
<li>GitHub 保護機制</li>
<li>Git 指令回顧</li>
</ul>
<h2 id="本地分支合併衝突"><a href="#本地分支合併衝突" class="headerlink" title="本地分支合併衝突"></a>本地分支合併衝突</h2><p>讓我們先來模擬衝突發生的情境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir project</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> project</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">touch index.html</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add index.html'</span></span><br></pre></td></tr></table></figure>

<p>修改 <code>index.html</code> 檔案：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>再次提交 commit：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'update index.html'</span></span><br></pre></td></tr></table></figure>

<p>到這邊已經完成初始化的動作了，假設目前有一位工程人員開了一個分支並提交了一次 commit 紀錄：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b dog</span><br><span class="line"></span><br><span class="line">touch all.css</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add all.css'</span></span><br></pre></td></tr></table></figure>

<p>此時他發現原本的 <code>index.html</code> 檔案標題打錯了，進行了修改：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>dog<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>並提交了 commit 紀錄：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'edit index.html &gt; title'</span></span><br></pre></td></tr></table></figure>

<p>假設又有一位工程人員開了一個分支並修復 title 這個問題：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">git checkout -b cat</span><br><span class="line"></span><br><span class="line">... edit index.html title</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'edit index.html &gt; title'</span></span><br></pre></td></tr></table></figure>

<p>讓我們來看目前的日誌：</p>
<p><img src="https://i.imgur.com/Qzr8J69.png" alt="查看目前 commit 紀錄-1"></p>
<p>你會發現在 <code>dog</code> 分支與 <code>cat</code> 分支同時修改了 <code>index.html</code> 檔案的標題，這邊要注意，並不是修改同一份檔案就會發生衝突，而是修改同一份檔案的同一行代碼才會發生衝突，基本上 Git 有自己判定的標準，讓我們繼續來看衝突是如何發生的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout cat</span><br><span class="line"></span><br><span class="line">git merge dog</span><br></pre></td></tr></table></figure>

<p>此時會跳出合併發生衝突的警告：</p>
<p><img src="https://i.imgur.com/s66X0qE.png" alt="git 合併衝突"></p>
<p>此時千萬不要慌張，讓我們先用 <code>git status</code> 壓壓驚：</p>
<p><img src="https://i.imgur.com/qHOftjW.png" alt="查看檔案狀態-1"></p>
<p>從上面可以得知，目前 <code>all.css</code> 已經被提交至索引區，代表這一個檔案沒有發生衝突，而 <code>index.html</code> 這個檔案就不一樣了，出現了 <code>Unmerged paths</code> 的狀態，且提示 <code>both modified</code> 字樣，代表兩個分支同時修改到了同份檔案的同行代碼，這時候 Git 提示可執行以下命令還原到未合併前的狀態：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure>

<p>這很明顯是半途而廢的行為！遇到問題，解決它不就行了？讓我們先打開發生衝突的這一個檔案：</p>
<!-- prettier-ignore-start -->
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>cat<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">=======</span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>dog<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dog</span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>神奇的事情發生了！發生衝突的這個檔案居然出現了奇怪的符號，其實這是 Git 用來告訴我們何處發生了衝突，上半部是 <code>HEAD</code>，也就是請求合併的 <code>cat</code> 分支，中間是分隔線，接下是 <code>dog</code> 分支的內容，這時請去與 <code>dog</code> 分支的人討論究竟該用誰的修改，假設我們要用 <code>dog</code> 分支的人修改好了，請把 <code>cat</code> 內容與其餘標記都給它刪除：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>dog<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在這邊補充一點，如果你的編輯器是 VSCode，它會有選擇的提示喔！挺方便的，效果如下：</p>
<p><img src="https://i.imgur.com/iuVVaA4.png" alt="VSCode 衝突提示"></p>
<p>修改完後，老樣子，目前這個檔案還是存在於工作目錄，將它提交至索引區吧：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>這時我們來看狀態長什麼樣子：</p>
<p><img src="https://i.imgur.com/j2bzdhV.png" alt="查看檔案狀態-2"></p>
<p>你會發現提示改變了，告訴我們所有衝突都已被修復，但此時還沒有結束喔，我們目前還是處於索引區，使用以下指令提交至本地數據庫：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure>

<p>這時你可能會想，為什麼沒有加 <code>-m</code> 參數呢？事實上，在這種情況下，我習慣使用預設的訊息，如果你跟我一樣單純使用 <code>git commit</code>，此時會跳出預設編輯器請你輸入提交訊息，而分支衝突本身就有預設的訊息內容了，也就代表直接關閉視窗即可，但如果你想要自訂訊息內容，那就照往常的加入 <code>-m &#39;message&#39;</code> 即可，這時候讓我們來看究竟合併成功了沒：</p>
<p><img src="https://i.imgur.com/CtrV3OY.png" alt="查看檔案狀態-3"></p>
<p>大功告成！分支已被成功合併，事實上，本地分支發生衝突的機率確實是挺高的，但只要跑過一次流程，就沒什麼好害怕的了，接下來進入到遠端分支合併衝突的部分。</p>
<h2 id="遠端分支合併衝突"><a href="#遠端分支合併衝突" class="headerlink" title="遠端分支合併衝突"></a>遠端分支合併衝突</h2><p>在這邊我們需要先釐清遠端數據庫是怎麼處理我們的上傳檔案的，你可能會認為遠端是以 “更新” 的方式進行處理，但這個觀念是錯的，事實上遠端與本地端同樣都是使用合併的方式處理檔案，這也就導致可能發生與本地端相同的合併衝突問題。</p>
<p>請先在 GitHub 隨便開一個遠端數據庫，並將本地端內容推上去：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:awdr74100/conflict-demo.git</span><br><span class="line"></span><br><span class="line">git push -u origin --all</span><br></pre></td></tr></table></figure>

<p>此時的日誌應該為：</p>
<p><img src="https://i.imgur.com/OO9EQwX.png" alt="查看目前 commit 紀錄-2"></p>
<p>在這邊補充一個指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend -m <span class="string">'merge dog branch'</span></span><br></pre></td></tr></table></figure>

<p>這個指令主要可用來修改最後一次提交的 commit 訊息，假設你不小心在提交 commit 時打錯字，這個指令就很用好，但不建議使用在以推至遠端數據庫的 commit 節點，必定會發生衝突：</p>
<p><img src="https://i.imgur.com/lQLCEcW.png" alt="查看目前 commit 紀錄-3"></p>
<p>你會發現原本的 <code>6aa88f4</code> 節點目前只剩遠端的 <code>cat</code> 分支指著，本地的 <code>cat</code> 分支反而指向了一個全新的 commit 節點，這邊你可能會有所誤會，修改訊息對於 Git 來說也算是一次全新的 commit 紀錄，但假設你是使用在本地尚未推至遠端的 commit 節點，原有的 <code>6aa88f4</code> 應該是會被 “隱藏” 才對，使用 <code>git log</code> 是看不到這一個節點的，上面為什麼看的到是因為遠端的 <code>cat</code> 分支指著，才導致這個節點被顯示出來。</p>
<p>此時如果將本地推至遠端，就會產生所謂的遠端合併分支衝突：</p>
<p><img src="https://i.imgur.com/iB6eRgq.png" alt="遠端分支合併衝突"></p>
<p>對於遠端分支來說，應該是存在 <code>6aa88f4</code> 這一個節點的，但我們透過修改形成了一個全新的節點，原有的 <code>6aa88f4</code> 就被隱藏了，只要合併前的舊有紀錄有被更改的情形，就有可能發生衝突，因為版本對不上阿！</p>
<p>有沒有發現 <code>non-fast-forward</code> 字樣？這不就是之前介紹的取消快轉合併嗎？這也證實了遠端是以合併的方式處理推上來的檔案，讓我們先來看目前的檔案狀態：</p>
<p><img src="https://i.imgur.com/OIxmorf.png" alt="查看檔案狀態-4"></p>
<p>Git 也直接跟你表明目前有衝突發生，請將遠端內容下載到本地端並進行合併，我們可以依造它指示的來做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>此時會跳出請你輸入此次合併提交的訊息：</p>
<p><img src="https://i.imgur.com/1dHjcvI.png" alt="合併分支"></p>
<p>再次執行 <code>git push</code>：</p>
<p><img src="https://i.imgur.com/rzfkuKE.png" alt="push 成功"></p>
<p>這一次 Push 就成功了，之前我們有說過 <code>git pull</code> 主要會將 <code>git fetch</code> 的內容直接執行 <code>git merge</code>，這也才導致直接跳出合併的訊息視窗，這樣子看起來是不是使用 <code>commit --amend</code> 挺麻煩的？我建議此命令不要用在以推至遠端的 commit 紀錄上，以免造成自己與夥伴的困擾。</p>
<p>跑過一次上面的流程你大概就知道怎麼修復遠端分支的衝突了，你也可以嘗試使用 Fetch 來跑上面的流程，之後再透過與本地端發生衝突的修復方法來解決這一個衝突，兩者的原理是一模一樣的。</p>
<h2 id="GitHub-保護機制"><a href="#GitHub-保護機制" class="headerlink" title="GitHub 保護機制"></a>GitHub 保護機制</h2><p>如果你是乖乖依照上面方法去修復衝突，倒是不必動用到 GitHub 的保護機制，但如果你是使用以下指令可就麻煩了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure>

<p>這個 <code>-f</code> 等同於 <code>--force</code>，表示強制的意思，這個指令主要用在遠端分支發生衝突時，可以強迫上傳，並且覆蓋掉遠端的分支，你可以把它想像成最高權限的覆蓋動作，如果以我們剛才的例子來講，遠端發生衝突時，就可以直接使用這個指令，免去修復的困擾，但建議這個指令只用在自己身上，你可以想像，團隊裡有人沒有先知會大家就突然使用這個指令，此時會發生什麼事？回家吃自己吧！</p>
<p>也因為這個指令帶來的後果太過於可怕，像是 GitHub 網站就有提供所謂的保護機制，可以避免某個分支被 Force Push，以下為示範：</p>
<p>路徑：Settings &gt; Branches &gt; Branch protection</p>
<p><img src="https://i.imgur.com/bkOJpIs.png" alt="保護機制-1"></p>
<p>點擊 <code>Add rule</code> 並挑選適合的選項：</p>
<p><img src="https://i.imgur.com/C7lYl3p.png" alt="保護機制-2"></p>
<p><code>master</code> 分支已被保護：</p>
<p><img src="https://i.imgur.com/E9tVpfv.png" alt="保護機制-3"></p>
<p>這樣就完成囉，根據你挑選的保護選項，在每次推送前都會觸發，避免可能發生的可怕後果。</p>
<h2 id="Git-指令回顧"><a href="#Git-指令回顧" class="headerlink" title="Git 指令回顧"></a>Git 指令回顧</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 還原至合併前狀態</span></span><br><span class="line">git merge --abort</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改最後一次 commit 訊息</span></span><br><span class="line">git commit --amend -m <span class="string">'message'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 強制推送遠端分支</span></span><br><span class="line">git push -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 強制推送遠端分支 (同上)</span></span><br><span class="line">git push --force</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 版本控制系統 - 比對檔案版本差異與標示說明</title>
    <url>/2020-04-27-git-diff/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前我們已經學會如何提交、切換、還原與重製版本了，現在只差比對了；身為版控的主流，Git 本身就已擁有強大的版本比對功能，在我們之前的分支合併衝突文章中，Git 之所以能夠告訴我們在何處發生了衝突，就是因為在內部運用了版本比對功能，事實上，我們也可以自己進行版本比對，這樣在合併分支時就不會造成所謂的衝突，除此之外，當你今天想要了解特定版本之間的差異性，也可以透過版本比對功能一目了然，省去了大部分時間。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>比對 HEAD 與 uncommitted 差異</li>
<li>比對 HEAD 與指定版本差異</li>
<li>比對不同版本間差異</li>
<li>使用 difftool 比對檔案</li>
<li>Git 指令回顧</li>
</ul>
<h2 id="比對-HEAD-與-uncommitted-差異"><a href="#比對-HEAD-與-uncommitted-差異" class="headerlink" title="比對 HEAD 與 uncommitted 差異"></a>比對 HEAD 與 uncommitted 差異</h2><p>讓我們先新增一個資料夾並提交數個 commit 紀錄：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir project</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> project</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">touch index.html</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add index.html'</span></span><br><span class="line"></span><br><span class="line">touch all.css</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add all.css'</span></span><br><span class="line"></span><br><span class="line">... edit index.html</span><br><span class="line"></span><br><span class="line">git commit -am <span class="string">'edit index.html'</span></span><br><span class="line"></span><br><span class="line">... edit all.css</span><br><span class="line"></span><br><span class="line">git commit -am <span class="string">'edit all.css'</span></span><br></pre></td></tr></table></figure>

<p>這邊做一個指令的補充：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -am <span class="string">'message'</span></span><br></pre></td></tr></table></figure>

<p>完整指令為：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -a -m <span class="string">'message'</span></span><br></pre></td></tr></table></figure>

<p><code>-m</code> 大家應該都很熟悉了才對，即提交訊息，<code>-a</code> 全名為 <code>--all</code>，可使狀態為 Changes not staged for commit 或 Changes to be committed 的檔案直接被提交至數據庫，省略了 <code>git add</code> 動作，但要注意 Untracked files 狀態的檔案是不受此命令作用的。</p>
<p>讓我們來看目前的日誌長什麼樣子：</p>
<p><img src="https://i.imgur.com/LrVHToM.png" alt="查看目前 commit 紀錄-1"></p>
<p>現在請隨意修改 <code>index.html</code> 與 <code>all.css</code> 成以下狀態：</p>
<p><img src="https://i.imgur.com/poFZvMJ.png" alt="查看檔案狀態-1"></p>
<p>在這邊我們只有將 <code>all.css</code> 的修改提交至索引區，而 <code>index.html</code> 的修改則是還停留在工作目錄，接著請執行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>

<p>這是比對檔案中最基本的指令，<strong>主要比對 HEAD (這指最新的 commit 紀錄) 與尚未進索引區 (unstaged) 全部檔案的差異</strong>，結果如下：</p>
<p><img src="https://i.imgur.com/YjEQ37s.png" alt="比對結果-1"></p>
<p>這邊你會發現只有 <code>index.html</code> 被進行比對，因為 <code>all.css</code> 已經被提交至索引區了，不在比對的範圍，如果你想比對以進索引區 (staged) 全部檔案的差異，也就是 <code>all.css</code> 的差異，可以使用以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure>

<p>這樣便可比對目前 HEAD (這指最新 commit 紀錄) 與以進索引區 (staged) 全部檔案的差異，此時結果如下：</p>
<p><img src="https://i.imgur.com/rmyNDfc.png" alt="比對結果-2"></p>
<p><code>--cached</code> 代表只比對 uncommitted 狀態下的已進索引區 (staged) 檔案，與 <code>--staged</code> 結果相同，後者只是前者的別名，兩者作用完全一樣。</p>
<p>那假設我們要同時比對尚未進索引區 (unstaged) 與已進索引區 (staged) 的檔案呢？可以使用以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure>

<p>這道指令代表自從上次 commit 以來做了什麼變化，這邊的 <code>HEAD</code> 也可以換成最新 commit 紀錄的 SHA-1 值，此時結果如下：</p>
<p><img src="https://i.imgur.com/ieP7THF.png" alt="比對結果-3"></p>
<p>以上就是 uncommitted 狀態如何進行比對的各種方式，讓我們簡單說明一下比對的標示：</p>
<ul>
<li><code>diff --git</code>：將哪兩個檔案進行比對</li>
<li><code>10064</code>：檔案屬性，表示 Regular non-executable file<ul>
<li><code>100664</code>：Regular non-executable group-writeable file</li>
<li><code>100755</code>：Regular executable file</li>
<li><code>120000</code>：Symbolic link</li>
<li><code>160000</code>：Gitlink</li>
</ul>
</li>
<li><code>@@ -1,3 +1,7 @@</code>：前面為舊版本總行數，後面為新版本總行數</li>
</ul>
<h2 id="比對-HEAD-與指定版本差異"><a href="#比對-HEAD-與指定版本差異" class="headerlink" title="比對 HEAD 與指定版本差異"></a>比對 HEAD 與指定版本差異</h2><p>上面都是介紹 uncommitted 狀態與 HEAD (這指最新 commit 紀錄) 比對的差異，以確認在每次提交 commit 時做了些什麼事情，事實上，我們也可以指定比對的版本，輸入以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff HEAD~1</span><br></pre></td></tr></table></figure>

<p>之前我們有提到 <code>^</code> 與 <code>~</code> 相對路徑的表示方法，這邊我們使用 <code>~1</code> 比較 <code>HEAD</code> 的前一個版本差異，此時結果如下：</p>
<p><img src="https://i.imgur.com/nZAS22h.png" alt="比對結果-4"></p>
<p><strong>在添加指定版本的 git diff 指令中，預設比對的是 HEAD (這指最新 commit 紀錄)</strong>，但你會發現它連同 uncommitted 的內容也進行了比對，我個人建議，如果你要指定版本進行比對，最好在無 uncommitted 狀態下進行比對，避免混亂，執行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'edit index.html all.css'</span></span><br></pre></td></tr></table></figure>

<p>因為我們又一次提交了 commit 紀錄，所以相對路徑須改為 <code>~2</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff HEAD~2</span><br></pre></td></tr></table></figure>

<p>此時結果為：</p>
<p><img src="https://i.imgur.com/BQ3l1Kp.png" alt="比對結果-5"></p>
<p>這樣就可以確保當前比對的版本為 HEAD (指最新 commit 紀錄) 與 HEAD 的前一個版本。</p>
<h2 id="比對不同版本間差異"><a href="#比對不同版本間差異" class="headerlink" title="比對不同版本間差異"></a>比對不同版本間差異</h2><p>事實上，剛剛的 <code>git diff HEAD~2</code> 等同於以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff HEAD^^ HEAD</span><br></pre></td></tr></table></figure>

<p>我們可以比對指定兩個版本間的差異，前面的 <code>HEAD^^</code> 代表較舊的版本，後面的 <code>HEAD</code> 代表較新的版本，千萬不要把兩者寫反了，這樣的結果也會是相反的，讓我們試試比較不同的版本：</p>
<p><img src="https://i.imgur.com/W67sTVw.png" alt="比對結果-6"></p>
<p>請注意，我們之前有提到 <code>HEAD</code> 代表的是我們當前所在的版本，你也可以使用 SHA-1 值作為比對的依據，任何能代表 commit 節點的稱謂都可以。</p>
<h2 id="使用-difftool-比對檔案"><a href="#使用-difftool-比對檔案" class="headerlink" title="使用 difftool 比對檔案"></a>使用 difftool 比對檔案</h2><p>到這邊你會發現 <code>diff</code> 都是在 Terminal 內顯示以進行比對，在較單純的情況下，是沒什麼問題，但只要檔案結構一變複雜，查看起來真的挺費勁的。</p>
<p>Git 自己也深知這點，所以提供對第三方 diff 工具的支持；在之前的 Vim 章節，我們就有嘗試將預設的 Vim 編輯器更改為 VSCode，在這邊我們也如法炮製，將 VScode 設置為我們的比對工具，以下為示範：</p>
<p>通過 git bash 配置 difftool (VSCode 示範)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global diff.tool vscode</span><br><span class="line"></span><br><span class="line">git config --global difftool.vscode.cmd <span class="string">'code --wait --diff $LOCAL $REMOTE'</span></span><br></pre></td></tr></table></figure>

<p>通過 <code>.gitconfig</code> 配置 difftool (VSCode 示範)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[diff]</span><br><span class="line">    tool &#x3D; vscode</span><br><span class="line">[difftool &quot;vscode&quot;]</span><br><span class="line">    cmd &#x3D; code --wait --diff $LOCAL $REMOTE</span><br></pre></td></tr></table></figure>

<p>此時即可使用 <code>difftool</code> 比對檔案：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git difftool -y HEAD^</span><br></pre></td></tr></table></figure>

<p>這邊的 <code>-y</code> 代表同意啟動第三方比對工具，如果沒有設置，在每次開啟比對檔案時，都會詢問是否同意開啟，你也可以使用以下命令全局關閉對話提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global difftool.prompt <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>讓我們來看結果如何：</p>
<p><img src="https://i.imgur.com/zttPqbC.png" alt="比對結果-7"></p>
<p><img src="https://i.imgur.com/1WPrnNd.png" alt="比對結果-8"></p>
<h2 id="Git-指令回顧"><a href="#Git-指令回顧" class="headerlink" title="Git 指令回顧"></a>Git 指令回顧</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 省略 git add 提交至本地數據庫 (限以追蹤或存在於索引區檔案)</span></span><br><span class="line">git commit -am <span class="string">'message'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 省略 git add 提交至本地數據庫 (同上)</span></span><br><span class="line">git commit -a -m <span class="string">'message'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比對 HEAD 與尚未進索引區檔案差異</span></span><br><span class="line">git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比對 HEAD 與已進索引區檔案差異</span></span><br><span class="line">git diff --cached</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比對 HEAD 與已進索引區檔案差異 (同上)</span></span><br><span class="line">git diff --staged</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比對 HEAD 與 uncommitted 檔案差異</span></span><br><span class="line">git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比對 uncommitted 與指定版本差異 (當前為 uncommitted 狀態)</span></span><br><span class="line">git diff HEAD~1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比對 HEAD 與指定版本差異 (當前為 nothing to commit 狀態)</span></span><br><span class="line">git diff HEAD^</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比對兩個不同版本間差異 (舊版本 - 新版本)</span></span><br><span class="line">git diff HEAD^^ HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 VSCode 設為 difftool 默認開啟工具</span></span><br><span class="line">git config --global diff.tool vscode</span><br><span class="line">git config --global difftool.vscode.cmd <span class="string">'code --wait --diff $LOCAL $REMOTE'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局關閉 difftool 對話提示</span></span><br><span class="line">git config --global difftool.prompt <span class="literal">false</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>w3HexSchool</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 版本控制系統 - rebase 合併分支與 pull --rebase 同步提交</title>
    <url>/2020-05-04-git-rebase/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前我們已經介紹過如何使用 merge 合併分支，這次來介紹更為進階的 rebase 方法合併分支。一般的 merge 方法就只是單純的將兩個分支進行合併，而 rebase 方法可以在不額外生成新 commit 的狀況下進行合併，達到精簡化的目的，且還提供了互動模式，針對時不時 commit 的人特別有用，能夠將零碎的 commit 紀錄依造自己需求做修改，以保證最後分享給夥伴的內容是有條理的。此篇將介紹如何使用 rebase 合併分支，過程也會提到衝突的解決辦法，最後說明何謂 rebase 互動模式。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>rebase 分支合併與處理方式</li>
<li>rebase 衝突發生並解決</li>
<li>rebase 互動模式 - 修改歷史訊息</li>
<li>rebase 互動模式 - 合併或拆分 commit 紀錄</li>
<li>rebase 互動模式 - 刪除或調整 commit 紀錄</li>
<li>使用 git pull <span>-</span><span>-</span>rebase 處理遠端提交</li>
<li>Git 指令回顧</li>
</ul>
<h2 id="rebase-分支合併與處理方式"><a href="#rebase-分支合併與處理方式" class="headerlink" title="rebase 分支合併與處理方式"></a>rebase 分支合併與處理方式</h2><p>讓我們先新增一個專案並提交兩次 commit 紀錄：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir project</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> project</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">touch index.html</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add index.html'</span></span><br><span class="line"></span><br><span class="line">touch all.css</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add all.css'</span></span><br></pre></td></tr></table></figure>

<p>建立 <code>feature</code> 分支並提交兩次 commit 紀錄：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b feature</span><br><span class="line"></span><br><span class="line">touch all.js</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add all.js'</span></span><br><span class="line"></span><br><span class="line">touch db.json</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add db.json'</span></span><br></pre></td></tr></table></figure>

<p>回到 <code>master</code> 分支並提交一個 commit 紀錄：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">... edit index.html</span><br><span class="line"></span><br><span class="line">git commit -am <span class="string">'edit index.html'</span></span><br></pre></td></tr></table></figure>

<p>目前的線路圖應該長這樣：</p>
<p><img src="https://i.imgur.com/UFes9lD.png" alt="查看目前 commit 紀錄-1"></p>
<p>在這種情況下使用 <code>git merge</code> 預設即會採用 non-fast-forward 合併分支，並生成一個全新的 commit 節點，這些在分支的章節都有講過，這一次我們換使用 rebase 的方式合併分支看看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase feature</span><br></pre></td></tr></table></figure>

<p>此時的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/ZwyrKue.png" alt="查看目前 commit 紀錄-2"></p>
<p>你會發現 <code>master</code> 原來指向的 <code>eca39f1</code> 節點更改為了 <code>b5cd508</code> 節點，且 <code>feature</code> 分支的線路圖不見了，這也就是 rebase 特別的地方，合併的同時重整了我們的 commit 紀錄，從字面上來看，「rebase」是「re」加上「base」，直譯大概是「重新定義分支的參考基準」的意思，以上面範例來說，<code>master</code> 分支 rebase <code>feature</code> 分支，代表 <code>feature</code> 分支為新的參考基準，<code>master</code> 分支與 <code>feature</code> 分支舊基準點為 <code>449ff41</code> 節點，此節點以後的 <code>master</code> 分支紀錄都將被剪下貼至新的基準點 <code>3cc7339</code> 後面，也就造成了上面的結果。</p>
<p><img src="https://i.imgur.com/wcl5WY9.png" alt="rebase 示例"></p>
<p>簡單來講就是「剪下」「貼上」的概念，但這邊要注意，所謂的剪下是指一個一個依序剪下，並不是將整條分支直接剪下，等等會在說明，這時你可能又會問，那原有的 <code>master</code> 分支指向的 <code>eca39f1</code> 怎會變成 <code>b5cd508</code> 節點呢？那是因為原有的 <code>eca39f1</code> 節點是接在 <code>449ff41</code> 之後的，但現在 <code>eca39f1</code> 被剪下貼到了 <code>3cc7339</code> 之後，兄弟關係已改變，Git 重新計算 SHA-1 使之成為父子關係，也就生成了 <code>b5cd508</code> 這個節點，本質上與 <code>eca39f1</code> 沒有差異，且屬於被隱藏不是被丟棄。</p>
<p>到這邊你可能還是有點不太能理解 rebase 的處理方式，不如讓我們在試一次，使用以下指令進行回復：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset ORIG_HEAD --hard</span><br></pre></td></tr></table></figure>

<p>你可以使用 <code>git reflog</code> 查找當時的 SHA-1 並進行還原，但這邊我們不這樣做，rebase 對於 Git 來說屬危險操作，為什麼危險呢？結果你也看到了，它會改變原有的 commit 紀錄，針對危險操作的還原，我們可以使用 <code>ORIG_HEAD</code> 這個變數，事實上，它是一個檔案，路徑為 <code>/.git/ORIG_HEAD</code>，裡面記載了危險操作前的 SHA-1，這也就是我們可以還原並指向的原因。</p>
<p>此時的路線圖狀態為：</p>
<p><img src="https://i.imgur.com/UFes9lD.png" alt="查看目前 commit 紀錄-3"></p>
<p>這次我們換使用 <code>feature</code> 分支合併 <code>master</code> 分支看看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line"></span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure>

<p>此時的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/8PnOuXx.png" alt="查看目前 commit 紀錄-4"></p>
<p>你會發現 <code>feature</code> 分支所屬的 <code>2ca0999</code> 與 <code>3cc7339</code> 節點被剪下至 <code>eca39f1</code> 之後了，我們剛剛有說過 rebase 是依序剪下貼上動作，所以在這邊可以理解為剪下 <code>2ca0999</code> 貼到 <code>eca39f1</code> 之後，由於父子關係改變，使之重新計算 SHA-1，也就生成了 <code>e97010a</code> 物件，接著繼續將 <code>3cc7339</code> 剪下並貼到剛剛重新計算的 <code>e97010a</code> 之後，一樣父子關係改變，也就生成了 <code>46c816d</code> 物件。</p>
<p>你可能會想，這樣有什麼好處嗎？從上面的結果可以發現線路圖變得單純許多，相比於使用 <code>git merge</code>，<code>git rebase</code> 可以保持線路圖的一致性，說白了，就是當你看不慣傳統 <code>git merge</code> 產生的 commit，希望它不要出現在線路圖裡，就用 <code>git rebase</code>。</p>
<h2 id="rebase-衝突發生並解決"><a href="#rebase-衝突發生並解決" class="headerlink" title="rebase 衝突發生並解決"></a>rebase 衝突發生並解決</h2><p>跑過了上面使用 rebase 的流程，相信各位大致上已經了解 rebase 的用法，也意識到可能會發生的問題了，沒錯！就是發生衝突時會很麻煩，相比於使用 <code>git merge</code> 只要解決一次衝突，<code>git rebase</code> 是依序剪下貼上來做處理，如果當前處理的節點有衝突，就必須進行修復，之後再跑到第二個節點，如果又有問題，就在進行修復，讓我們來模擬此情境：</p>
<p>目前的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/8PnOuXx.png" alt="查看目前 commit 紀錄-5"></p>
<p>回復到 rebase 前狀態：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset 3cc7339 --hard</span><br></pre></td></tr></table></figure>

<p>此時的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/UFes9lD.png" alt="查看目前 commit 紀錄-6"></p>
<p>假設我們在 <code>feature</code> 與 <code>master</code> 各做了些事情：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">... edit index.html</span><br><span class="line"></span><br><span class="line">git commit -am <span class="string">'edit index.html'</span></span><br><span class="line"></span><br><span class="line">... edit all.css</span><br><span class="line"></span><br><span class="line">git commit -am <span class="string">'edit all.css'</span></span><br><span class="line"></span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">... edit all.css</span><br><span class="line"></span><br><span class="line">git commit -am <span class="string">'edit all.css'</span></span><br></pre></td></tr></table></figure>

<p>目前線路圖狀態：</p>
<p><img src="https://i.imgur.com/muOg1pA.png" alt="查看目前 commit 紀錄-7"></p>
<p>這次一樣使用 <code>feature</code> 合併 <code>master</code> 分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase master</span><br></pre></td></tr></table></figure>

<p>此時會跳出衝突的提示：</p>
<p><img src="https://i.imgur.com/rw5yW3d.png" alt="查看目前 commit 紀錄-8"></p>
<p>不用緊張，先讓我們用 <code>git status</code> 壓壓驚：</p>
<p><img src="https://i.imgur.com/LpHqBoj.png" alt="查看檔案狀態-1"></p>
<p>你會發現它提示了 <code>rebase in progress</code> 代表卡住了，開啟 Sourcetree 可以看得更清楚：</p>
<p><img src="https://i.imgur.com/RPB0Mnd.png" alt="Sourcetree"></p>
<p>從上面顯示可以得知，<code>2ca0999</code> 與 <code>3cc7339</code> 已被成功處理，但 <code>b1d9a97</code> 節點似乎發生衝突導致卡住，在前面的檔案狀態中，提示了可使用以下指令操作目前的 rebase 狀態：</p>
<ul>
<li>跳過當下 commit，並執行下一個 commit：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase --skip</span><br></pre></td></tr></table></figure>

<ul>
<li>取消 rebase 操作，回到 rebase 前狀態：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure>

<p>這幾個指令看來都是逃避用的，都到這一步了，我們怎麼可能半途而廢，遇到問題解決不就得了，解法與 <code>git merge</code> 差不多，打開狀態為 <code>both modified</code> 的檔案：</p>
<p><img src="https://i.imgur.com/KvONbC3.png" alt="VSCode 衝突"></p>
<p>假設我們要 <code>feature</code> 的內容，請把 <code>master</code> 的內容連同標記一起刪掉，之後再把他加至索引區：</p>
<p><img src="https://i.imgur.com/o8PT39K.png" alt="查看檔案狀態-2"></p>
<p>在 <code>git merge</code> 的狀況下，我們可以使用 <code>git commit</code> 提交修改，但在 <code>git rebase</code> 的狀況下，必須使用以下指令提交修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>

<p>有些人會在這一步使用 <code>git commit</code>，但在 rebase 的狀況下，反而是要使用 <code>--continue</code> 處理下一個 commit，這也是之前提到的 rebase 是依序處理每一個 commit，此時狀態為：</p>
<p><img src="https://i.imgur.com/pRcifmN.png" alt="git rebase --continue"></p>
<p>你會發現 <code>b1d9a97</code> 已被成功處理，目前 <code>HEAD</code> 也就指向 <code>d40af91</code> 這個新產生的物件。</p>
<p>你以為結束了嗎？有沒有發現它又跳了一個錯誤？代表 <code>c952696</code> 也發生了衝突，解決就不再贅述，過程跟上面一模一樣，當我們全部衝突都被解決了，會跳出以下提示：</p>
<p><img src="https://i.imgur.com/MjOqSFD.png" alt="rebase 成功解決衝突"></p>
<p>看到這個提示，代表我們的 rebase 終於成功了，此時的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/kNrcSRP.png" alt="查看目前 commit 紀錄-9"></p>
<p>的確 <code>feature</code> 分支原有的 commit 都被接到了 <code>2d0d29c</code> 之後，以上就是 rebase 發生衝突的解決辦法。</p>
<h2 id="rebase-互動模式-修改歷史訊息"><a href="#rebase-互動模式-修改歷史訊息" class="headerlink" title="rebase 互動模式 - 修改歷史訊息"></a>rebase 互動模式 - 修改歷史訊息</h2><p>前面都是介紹 rebase 該如何針對兩個分支進行合併，利用依序剪下貼上的概念達到重整的效果，但你以為重整效果只能在兩個分支合併時才觸發嗎？這你就錯了，它還可以針對舊有紀錄做重整啊！你可以把它理解為自己合併自己導致觸發的概念，主要依靠其互動模式而進行，讓我們直接實際操作一番。</p>
<p>目前的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/kNrcSRP.png" alt="查看目前 commit 紀錄-10"></p>
<p>假設我們要重整 <code>b2179fc</code> 到 <code>b3c71bc</code> 間的紀錄，輸入以下指令以啟動互動模式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i b3c71bc</span><br></pre></td></tr></table></figure>

<p><code>-i</code> 這個參數，全名是 <code>--interactive</code>，也就是互動模式，此時會跳出預設編輯器視窗：</p>
<p><img src="https://i.imgur.com/maslzmh.png" alt="git rebase -i 互動模式"></p>
<p>預設的 rebase 模式為 <code>pick</code>，意思是「保留這次的 commit，不做任何修改」，你可以嘗試在此情況下直接 <code>:wq</code>，你的 commit 紀錄將不會有任何的改變。</p>
<p>還記得之前介紹的 <code>git commit --amend</code> 命令嗎？主要可用來修改最後一次提交的 commit 紀錄訊息，但假設我們要修改更以前的 commit 紀錄訊息呢？這時候該怎麼辦？使用 <code>reword</code> 模式：</p>
<p><img src="https://i.imgur.com/UoQVBkk.png" alt="修改為 reword 選項"></p>
<p>這邊補充一點，傳統使用 <code>git log</code> 最新紀錄是顯示在最上面，但在互動模式的顯示中是顯示在最下面，你可以把它看做相反的概念；<code>reword</code> 模式主要用來修改以提交的紀錄，且不限多久以前的紀錄，操作方法也很簡單，只需要將 <code>pick</code> 更改為 <code>reword</code> 即可，上面示範了修改 <code>82c681b</code> 與 <code>47701bd</code> 的紀錄訊息，此時會跳出修改訊息的視窗：</p>
<p><img src="https://i.imgur.com/Fs5MNQF.png" alt="修改訊息視窗-1"></p>
<p>此為 <code>82c681b</code> 的原始紀錄訊息，你可以隨意的更改訊息，接著一樣 <code>:wq</code> 儲存後離開，此時又會再跳出 <code>47701bd</code> 的修改訊息視窗：</p>
<p><img src="https://i.imgur.com/mINOLTL.png" alt="修改訊息視窗-2"></p>
<p>一樣修改成你想要訊息 <code>:wq</code> 儲存後離開，假設你之後的 commit 紀錄沒有要做任何的修改，最後就會跳出成功修改訊息的提示，讓我們來看目前的線路圖狀態：</p>
<p><img src="https://i.imgur.com/Ei24Pid.png" alt="查看目前 commit 紀錄-11"></p>
<p>你會發現訊息確實是修改了，但我們不是只有修改 <code>06380be</code> (原來的 <code>82c681b</code>) 與 <code>e98f2b8</code> (原來的 <code>47701bd</code>) 而已嗎？怎會連同之後的全部 commit 紀錄也被修改 (生成新 SHA-1 物件)了呢？原理如同之前所說，父子關係改變，導致生成新的 SHA-1 物件，但本質上還是一樣的東西，就這麼簡單。</p>
<h2 id="rebase-互動模式-合併或拆分-commit-紀錄"><a href="#rebase-互動模式-合併或拆分-commit-紀錄" class="headerlink" title="rebase 互動模式 - 合併或拆分 commit 紀錄"></a>rebase 互動模式 - 合併或拆分 commit 紀錄</h2><p>有時候我們會為了記錄特定的事情而提交多餘的 commit 紀錄，拿前面例子來看：</p>
<p><img src="https://i.imgur.com/Ei24Pid.png" alt="查看目前 commit 紀錄-12"></p>
<p>像是 <code>06380be</code> 與 <code>e98f2b8</code> 這兩個節點都是在做新增檔案的行為，又不是什麼多重要的行為，建議以單個節點的方式存在，避免線路圖過於混亂，此時就是 <code>squash</code> 模式出馬的時候了，執行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i b3c71bc</span><br></pre></td></tr></table></figure>

<p>這邊要注意，並不是一定要選擇 <code>b3c71bc</code> 這個節點才能夠啟動互動模式，只是我習慣選取大範圍的節點好方便選取罷了，你可以隨意的修改選取的範圍，只要符合你的需求就好，此時一樣會跳出互動模式視窗：</p>
<p><img src="https://i.imgur.com/hFyoNAW.png" alt="git rebase -i 互動模式"></p>
<p><code>squash</code> 模式主要用來合併 commit 紀錄，你沒有看錯，commit 還真的能合併，請將須合併節點從原本的 <code>pick</code> 修改為 <code>squash</code> 模式：</p>
<p><img src="https://i.imgur.com/3EolJAh.png" alt="修改為 squash 選項"></p>
<p>這邊要注意，並不是將 <code>06380be</code> 與 <code>e98f2b8</code> 都選為 <code>squash</code> 模式，這樣會導致一併被合併到 <code>2d0d29c</code> 這一個節點，所謂的合併是指合併到前一個節點，代表這邊只需要合併 <code>e98f2b8</code> 就可以達成目的了，<code>:wq</code> 後會跳出編輯 commit 訊息的視窗：</p>
<p><img src="https://i.imgur.com/Xsum3Z4.png" alt="合併訊息"></p>
<p>從提示的內容可以得知，所謂的合併紀錄，其實是將指定的 commit 拆掉並將檔案提交至索引區，為什麼會跳出訊息的視窗呢？答案也很明顯了，這一步就是在做提交至本地數據庫的動作，請將被合併的訊息內容註解掉，並修改合併至的訊息內容，此時 <code>:wq</code> 即可完成合併動作，讓我們來看目前的線路圖狀態：</p>
<p><img src="https://i.imgur.com/o46DLNT.png" alt="查看目前 commit 紀錄-13"></p>
<p>原有的 <code>06380be</code> 與 <code>e98f2b8</code> 以被合併成 <code>b9fec18</code>，且由於父子關係改變，後面所有的 commit 都經過重新計算生成了新的 commit 紀錄。</p>
<p>你可能會問，既然 commit 可以合併，是不是也能夠拆分呢？沒錯！還真的可以，執行以下命令已啟動互動模式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i b3c71bc</span><br></pre></td></tr></table></figure>

<p>假設我們要把剛剛合併完成的 <code>b9fec18</code> 拆分成原來的兩個 commit，在需拆分的 commit 設置 <code>edit</code> 模式：</p>
<p><img src="https://i.imgur.com/5I1qfZi.png" alt="修改為 edit 選項"></p>
<p><code>edit</code> 模式可讓我們編輯指定的 commit 節點，你不用把它想得太複雜，先讓我們開啟線路圖狀態：</p>
<p><img src="https://i.imgur.com/hRPVAuq.png" alt="查看目前 commit 紀錄-14"></p>
<p>你會發現 rebase 卡在了 <code>b9fec18</code> 節點，這才導致 <code>HEAD</code> 指向了這一個節點，拆分 commit 非常的簡單，還記得 <code>reset</code> 指令嗎？把檔案丟回工作目錄重新跑一次流程不就達到目的了？執行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset HEAD^ --mixed</span><br></pre></td></tr></table></figure>

<p><code>--mixed</code> 是 <code>reset</code> 的預設模式，可加可不加，這邊千萬不要用 <code>--hard</code> 模式啊！你的檔案會被徹底丟掉，讓我們來看目前狀態：</p>
<p><img src="https://i.imgur.com/26fTkBx.png" alt="查看檔案狀態-3"></p>
<p>原本 <code>b9fec18</code> 的檔案都被丟回工作目錄了，接下來就只需要各別提交 commit 即可完成目的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add all.js</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add all.js'</span></span><br><span class="line"></span><br><span class="line">git add db.json</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add db.json'</span></span><br></pre></td></tr></table></figure>

<p>這時候還沒有結束喔！目前我們還是處於 rebase 的狀態，執行以下指令跳到下個進程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>

<p>大功告成！此時的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/h3yg00e.png" alt="查看目前 commit 紀錄-15"></p>
<p><code>b9fec18</code> 已被拆分成 <code>74b2f71</code> 與 <code>d54d71d</code>，跑過一次上面流程，你會發現 <code>edit</code> 模式可以做非常多的事情，你可以嘗試在指定的節點新增 commit 紀錄看看，這邊就不做示範了，差別只在於 <code>HEAD</code> 狀態下想要做什麼動作而已。</p>
<h2 id="rebase-互動模式-刪除或調整-commit-紀錄"><a href="#rebase-互動模式-刪除或調整-commit-紀錄" class="headerlink" title="rebase 互動模式 - 刪除或調整 commit 紀錄"></a>rebase 互動模式 - 刪除或調整 commit 紀錄</h2><p>前面介紹了 rebase 各種的操作，應該夠你玩一陣子了，這邊來補充一些基本的操作，使用以下命令啟動互動模式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i b3c71bc</span><br></pre></td></tr></table></figure>

<p>這次來介紹 <code>drop</code> 模式，此模式主要可用來刪除指定的 commit 紀錄，假設我們要刪除 <code>d54d71d</code> 這個 commit，將 <code>pick</code> 改為 <code>drop</code>：</p>
<p><img src="https://i.imgur.com/EYHYH1z.png" alt="選改為 deop 選項"></p>
<p>你如果嫌 <code>drop</code> 模式還需要打字，你可以直接把想要刪除的 commit 整行刪除，你沒有看錯，就是整行刪除，這樣 rebase 就不會去處理那一個 commit，也就達到與 <code>drop</code> 相同的目的，讓我們來看 <code>:wq</code> 後的線路圖狀態：</p>
<p><img src="https://i.imgur.com/PZnfFOw.png" alt="查看目前 commit 紀錄-16"></p>
<p><code>d54d71d</code> 已經被我們刪除了，相比於上面的模式，<code>drop</code> 可能是最單純的一個模式。</p>
<p>假設你覺得現在的 commit 流程有點怪怪的，你也可以任意調整 commit 的順序，老樣子，使用以下指令開啟互動模式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i b3c71bc</span><br></pre></td></tr></table></figure>

<p>在這邊我們將 <code>74b2f71</code> 調整到最新的 commit 上，如下所示：</p>
<p><img src="https://i.imgur.com/TZNYGFB.png" alt="調整 commit 順序"></p>
<p>其實就只要把 commit 移動到想要的位置就可以了，此時一樣 <code>:wq</code> 並查看線路圖狀態：</p>
<p><img src="https://i.imgur.com/pbVFJQd.png" alt="查看目前 commit 紀錄-17"></p>
<p><code>74b2f71</code> 就被我們移動到指定的位置上了，在每次調整 commit 時，千萬要注意相依性的問題！</p>
<p>上面針對 rebase 的操作都是屬於合理的範圍內，何謂合理呢？就是指在不發生衝突的狀態下完成目的，那何謂不合理呢？我們拿上面最後這張流程圖來做說明，假設我們把 <code>449ff41</code> 移到 <code>e91dee5</code> 之後，此時就會跳出衝突等待我們處理，一般來說不建議這樣做，rebase 雖然可達到重整的作用，但還是必須考慮到相依性的問題，像是剛剛提到的範例，我們都還沒有新增 <code>all.css</code> 何來修改 <code>all.css</code> 呢？這邊要特別的注意。</p>
<h2 id="使用-git-pull-rebase-處理遠端提交"><a href="#使用-git-pull-rebase-處理遠端提交" class="headerlink" title="使用 git pull --rebase 處理遠端提交"></a>使用 git pull <span>-</span><span>-</span>rebase 處理遠端提交</h2><p>事實上，rebase 主要都是被用在尚未提交至遠端的 commit，達到重整的作用，以及多人協作時在同一條分支上的開發，避免產生多餘的 commit 紀錄，在這邊我們來模擬多人協作時的狀況：</p>
<blockquote>
<p>這邊以資料夾名稱辨認當前的用戶</p>
</blockquote>
<p>A 夥伴進行初始化專案動作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir a-repository</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">touch index.html</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add index.html'</span></span><br><span class="line"></span><br><span class="line">... edit index.html</span><br><span class="line"></span><br><span class="line">git commit -am <span class="string">'change index.html'</span></span><br><span class="line"></span><br><span class="line">git remote add origin git@github.com:awdr74100/pull-rebase-demo.git</span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>B 夥伴克隆回本地並提交一個 commit：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:awdr74100/pull-rebase-demo.git b-repository</span><br><span class="line"></span><br><span class="line">touch all.css</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add all.css'</span></span><br></pre></td></tr></table></figure>

<p>A 夥伴與 B 夥伴屬共同開發，A 夥伴此時提交了一個 commit：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch all.js</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add all.js'</span></span><br><span class="line"></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>B 夥伴上傳時肯定會跳出衝突：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>衝突內容如下：</p>
<p><img src="https://i.imgur.com/dBeRFmk.png" alt="git push 發生衝突"></p>
<p>理由很簡單，Git 發現遠端分支有新的 commit 尚未同步到本地，導致無法推送，這些在介紹分支的章節都有提到，解決方法如下：</p>
<blockquote>
<p>這邊也可以使用 git pull，預設是使用 merge 方式合併分支</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch</span><br><span class="line"></span><br><span class="line">git merge origin/master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此時會跳出輸入 commit 訊息的視窗</span></span><br></pre></td></tr></table></figure>

<p>此時的線路圖狀態如下：</p>
<p><img src="https://i.imgur.com/bRNHacH.png" alt="查看目前 commit 紀錄-18"></p>
<p>發現問題了嗎？明明 A 夥伴與 B 夥伴都是在 <code>master</code> 這條分支進行開發，這樣子的處理方式會導致產生額外的 <code>9dba8b9</code> 這個節點，如果頻繁的操作，豈不是會增加一堆類似的節點？整個線路圖變得非常不易閱讀，此時就是 rebase 出馬的時候了，先讓我們回復到尚未 merge 的狀態：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset HEAD^ --hard</span><br></pre></td></tr></table></figure>

<p>目前的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/VeKksd3.png" alt="查看目前 commit 紀錄-19"></p>
<p>改使用 rebase 合併遠端提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase origin/master</span><br></pre></td></tr></table></figure>

<p>此時的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/dTr5OTw.png" alt="查看目前 commit 紀錄-20"></p>
<p>是不是變得乾淨且合理許多？同樣的結果，我們也可以使用 <code>git pull</code> 來完成，請先將 B 夥伴內容推至遠端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>A 夥伴與遠端同步：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch</span><br><span class="line"></span><br><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure>

<p>A 夥伴提交一個可能發生衝突的 commit 並推至遠端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">... edit index.html</span><br><span class="line"></span><br><span class="line">git commit -am <span class="string">'change index.html &gt; title'</span></span><br><span class="line"></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>B 夥伴也提交一個可能發生衝突的 commit：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">... edit index.html</span><br><span class="line"></span><br><span class="line">git commit -am <span class="string">'change index.html &gt; title'</span></span><br></pre></td></tr></table></figure>

<p>又回到了剛剛的情境，B 夥伴的數據庫有尚未同步的分支，此時 Push 會發生衝突，剛剛的最完美解法是 <code>git fetch + git rebase</code>，這次我們換 <code>git pull</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure>

<p>git pull 預設是使用 <code>merge</code> 來合併分支，我們可透過傳遞 <code>--rebase</code> 選項告知改使用 rebase 合併分支，此時就達到與 <code>git fetch + git rebase</code> 一樣的效用，不過在上面範例中，我們有刻意加入衝突的行為，此時會跳出需修復衝突的提示：</p>
<p><img src="https://i.imgur.com/AJAYMnE.png" alt="git pull --rebase 衝突"></p>
<p>解決方法如同之前所介紹，這邊就不再做贅述，最後記得輸入 <code>git rebase --continue</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">... fix conflict</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>

<p>此時的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/sZ3QBLe.png" alt="查看目前 commit 紀錄-21"></p>
<p>大功告成！如果硬要說 <code>git pull --rebase</code> 相比 <code>git pull</code> 有什麼令人困擾的地方，可能就是遇到衝突時會比較麻煩點，這其實也是 rebase 的通病，merge 如果發生衝突，你只需要解決衝突一次，之後 coomit 出去就完事了，而 rebase 的衝突你可能要修復數次，畢竟他是以依序的方式進行處理，有利也有弊，判斷當下情境去做選擇才是上策。</p>
<h2 id="Git-指令回顧"><a href="#Git-指令回顧" class="headerlink" title="Git 指令回顧"></a>Git 指令回顧</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 合併分支 (使用 rebase 方式)</span></span><br><span class="line">git rebase &lt;branch_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 還原 rebase 操作 (使用 ORIG_HEAD)</span></span><br><span class="line">git reset ORIG_HEAD --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 還原 rebase 操作 (從 reflog 查詢)</span></span><br><span class="line">git reset &lt;SHA-1&gt; --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳過當下 commit，並執行下一個 commit：</span></span><br><span class="line">git rebase --skip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消 rebase 操作，回到 rebase 前狀態：</span></span><br><span class="line">git rebase --abort</span><br><span class="line"></span><br><span class="line"><span class="comment"># 進入下一個 rebase 進程</span></span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在指定範圍啟動 rebase 互動模式</span></span><br><span class="line">git rebase -i &lt;SHA-1&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在指定範圍啟動 rebase 互動模式 (同上)</span></span><br><span class="line">git rebase --interactive &lt;SHA-1&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 互動可選模式：</span></span><br><span class="line"><span class="comment"># pick &lt;commit&gt; = 保留這次 commit，不做任何修改</span></span><br><span class="line"><span class="comment"># reword &lt;commit&gt; = 修改 commit 訊息內容</span></span><br><span class="line"><span class="comment"># squash &lt;commit&gt; = 合併 commit (合併至前一個節點)</span></span><br><span class="line"><span class="comment"># edit &lt;commit&gt; = 編輯 commit (停留在指定 commit，可做新增、修改的操作)</span></span><br><span class="line"><span class="comment"># drop &lt;commit&gt; = 刪除 commit (與移除整行提示同結果)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 將遠端分支合併至本地 (使用 rebase 合併)</span></span><br><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>w3HexSchool</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 版本控制系統 - 使用標籤為特定版本號做標記</title>
    <url>/2020-04-28-git-tag/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在我們使用某些函式庫或框架進行開發時，途中可能會遇到某些無法理解的內部錯誤，這時最直接的方法就是到官方 GitHub 中的 releases 頁面查找是否有已釋出的修復版本並進行更新；這邊你所看到的版本號其實是由 Git 為特定版本進行標記所形成的標籤，標籤就如同分支一般的存在，但本質上還是有些差異，該如何正確使用標籤標記特定版本以及標籤與分支何謂本質上的差別，本篇都會講到。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>新增標籤</li>
<li>刪除標籤</li>
<li>遠端標籤相關操作</li>
<li>標籤與分支差異</li>
<li>Git 指令回顧</li>
</ul>
<h2 id="新增標籤"><a href="#新增標籤" class="headerlink" title="新增標籤"></a>新增標籤</h2><p>讓我們先新增一個專案並提交數次 commit 紀錄：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir project</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> project</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">touch index.html</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add index.html'</span></span><br><span class="line"></span><br><span class="line">touch all.css</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add index.html'</span></span><br><span class="line"></span><br><span class="line">touch all.js</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add all.js'</span></span><br></pre></td></tr></table></figure>

<p>查看目前日誌：</p>
<p><img src="https://i.imgur.com/KyKR9pC.png" alt="查看目前 commit 紀錄-1"></p>
<p>要在 Git 中使用標籤非常的簡單，先讓我們來執行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag v1.0.0</span><br></pre></td></tr></table></figure>

<p>此時你會發現所在的 commit 節點新增了一個名為 <code>tag: v1.0.0</code> 的狀態：</p>
<p><img src="https://i.imgur.com/G9KzWkc.png" alt="查看目前 commit 紀錄-2"></p>
<p>這就是新增標籤的方法，是不是非常的簡單？標籤名稱你可以隨意命名，但通常我們都是用來標記當前的開發版本，讓我們在試一次：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag v0.9.0 2755da8</span><br></pre></td></tr></table></figure>

<p>事實上，標籤的語法與分支幾乎差不多，只不過關鍵字一個是 <code>branch</code> 一個是 <code>tag</code> 的差別而已，你也可以在指定 commit 節點貼上標籤，就如同上面所示，讓我們來看目前的狀態：</p>
<p><img src="https://i.imgur.com/QAJj4sh.png" alt="查看目前 commit 紀錄-3"></p>
<p>確實 <code>2755da8</code> 節點也被貼上了標籤，有沒有注意到我都是用 “貼上” 一詞？標籤與分支同樣都屬於貼紙一般的存在，並不是說你刪除了哪一個分支或標籤這一個節點就不見了，頂多只是這個貼紙被撕掉了，你還是可以重貼這張貼紙。</p>
<p>請注意，我們上面使用的標籤形式都是屬於輕量標籤 (lightweight tag)，這邊還有另外一種標籤形式為帶註解標籤 (annotated tag)，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag v0.8.1 v0.9.0^ -am <span class="string">'Bug fix'</span></span><br></pre></td></tr></table></figure>

<p>如同我們前面所提到，標籤與分支都是如同貼紙一般的存在，你也可以使用標籤搭配相對路徑的方式，指定作用的 commit 節點，上面示範了使用 <code>^</code> 指定前一個節點，這邊的 <code>-am</code> 參數等同於 <code>-a + -m</code>，<code>-a</code> 代表請 Git 幫你建立帶註解的標籤，而後面的 <code>-m</code> 如同 commit 的 <code>-m</code>，即訊息內容，讓我們來看目前的狀態：</p>
<p><img src="https://i.imgur.com/sOYtuKd.png" alt="查看目前 commit 紀錄-4"></p>
<p>這時你會發現 <code>2b7826b</code> 節點也被貼上標籤了，但看起來輕量標籤與帶註解標籤好像沒什麼差別？讓我們使用以下指令將標籤記錄顯示出來：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git show v0.9.0</span><br></pre></td></tr></table></figure>

<p><code>git show</code> 主要用來顯示指定提交版本的異動，你可以在後面指定標籤、分支、SHA-1 等屬性，如果都沒有指定，預設即會顯示 <code>HEAD</code> 的版本內容，讓我們來看此時結果為何：</p>
<p><img src="https://i.imgur.com/m5JPLBI.png" alt="git show 0.9.0"></p>
<p>你會發現輕量標籤真的就只是一張很單純的貼紙，沒有任何的註解內容，顯示的都只是預設就該顯示的內容，這也是官方比較推薦使用帶註解標籤的原因，讓我們來看帶註解標籤有何不同：</p>
<p><img src="https://i.imgur.com/XsFkRbm.png" alt="git show 0.8.1"></p>
<p>帶註解標籤比輕量標籤多了一些資訊，可以很直接看到是誰將這張貼紙貼了上去以及貼紙的內容，我自己是比較常用帶註解標籤，既然你都要貼標籤了，必定是有其原因，這時如果你使用輕量標籤，日後就沒辦法檢視貼這張標籤的原因了，在這邊補充幾個指令：</p>
<ul>
<li>顯示所有標籤</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>

<ul>
<li>顯示所有標籤及資訊 (優先顯示帶註解標籤內容，輕量標籤則顯示 commit 訊息內容)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -n</span><br></pre></td></tr></table></figure>

<p>這邊比較特別的是 <code>git tag -n</code> 命令，讓我們來執行它並查看結果：</p>
<p><img src="https://i.imgur.com/U3aKeu3.png" alt="git tag -n"></p>
<p>你會發現與單純顯示標籤不同，多了訊息的資訊，這一個訊息有可能為帶註解標籤內容或者 commit 訊息內容，這邊請記住一個原則，此訊息內容優先選擇帶註解標籤內容，如為輕量標籤則顯示 commit 訊息內容。</p>
<p>到這邊已經完成對輕量標籤與帶註解標籤的相關操作了，其實你真的不用想得太複雜，分支的指令與標籤的指令真得幾乎一模一樣，比如說等等會介紹的刪除標籤，其實你應該也猜得出來指令是什麼了，讓我們繼續看下去。</p>
<h2 id="刪除標籤"><a href="#刪除標籤" class="headerlink" title="刪除標籤"></a>刪除標籤</h2><p>刪除標籤並沒有分所謂的輕量標籤或帶註解標籤，通通一視同仁，使用以下指令刪除標籤：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -d 0.9.0</span><br></pre></td></tr></table></figure>

<p>此時會跳出標籤已被刪除的提示：</p>
<p><img src="https://i.imgur.com/tlhg2Vm.png" alt="git tag -d"></p>
<p>讓我們來看目前日誌：</p>
<p><img src="https://i.imgur.com/x03kiLz.png" alt="查看目前 commit 紀錄-5"></p>
<p>確實 <code>v0.9.0</code> 標籤被我們刪除了，在標籤刪除的操作中，並沒有像分支有分所謂的 <code>-d</code> 或 <code>-D</code>，畢竟標籤就只是單純的黏貼作用，隨時都可以取代。</p>
<p>以上就是標籤在本地端的相關操作，接下來進入到重頭戲將標籤推至遠端數據庫的部分。</p>
<h2 id="遠端標籤相關操作"><a href="#遠端標籤相關操作" class="headerlink" title="遠端標籤相關操作"></a>遠端標籤相關操作</h2><p>請先至 GitHub 開一個遠端數據庫並將本地內容 Push 上去：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:awdr74100/tag-demo.git</span><br><span class="line"></span><br><span class="line">git push -u origin --all</span><br></pre></td></tr></table></figure>

<p>此時的狀態為：</p>
<p><img src="https://i.imgur.com/V9iaICz.png" alt="查看目前 commit 紀錄-6"></p>
<p>讓我們來看 GitHub 中的 releases 頁面是否有本地的 Tag 標籤：</p>
<p><img src="https://i.imgur.com/Af53gYG.png" alt="GitHub reslease"></p>
<p>放心，沒有是很正常的，<code>git push</code> 預設是不會把標籤連同 Push 上去的，得另外使用以下指令：</p>
<ul>
<li>指定標籤上傳至遠端數據庫：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin v1.0.0</span><br></pre></td></tr></table></figure>

<ul>
<li>全部標籤上傳至遠端數據庫：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>

<p>此時會提示遠端新增了本地 Push 上去的分支：</p>
<p><img src="https://i.imgur.com/CXOIDzk.png" alt="git push origin --tags"></p>
<p>查看 GitHub Releases 頁面是否成功提交：</p>
<p><img src="https://i.imgur.com/6H7WerU.png" alt="GitHub Releases"></p>
<p>大功告成！事實上，本地標籤是被推至 GitHub 中的 Tag 頁面，Releases 頁面是 GitHub 的高級功能，你可以針對這一個版本寫些內容，如下所示：</p>
<blockquote>
<p>Tags &gt; Create release</p>
</blockquote>
<p><img src="https://i.imgur.com/atBgK2s.png" alt="Create release"></p>
<p>是不是很酷？以後你也可以發行自己的版本囉，這邊再補充幾個指令：</p>
<ul>
<li>刪除遠端標籤</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin :v0.8.1</span><br></pre></td></tr></table></figure>

<ul>
<li>刪除遠端標籤 (v1.7 以後版本可使用)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --delete origin v0.8.1</span><br></pre></td></tr></table></figure>

<p>遠端標籤刪除的命令與分支也是幾乎一樣，Push 一個空的標籤即可，在較新的 Git 版本，你也可以使用 <code>--delete</code> 參數刪除標籤。但這邊要注意，如果存在同名的分支或標籤，Git 會因為不知道選擇哪個而跳錯，解決辦法也很簡單，使用以下命令：</p>
<ul>
<li>刪除遠端標籤 (明確命令)：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin :refs/tags/&lt;remote_tag&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>刪除遠端分支 (明確命令)：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin :refs/heads/&lt;remote_branch&gt;</span><br></pre></td></tr></table></figure>

<p>雖然說一般人不太可能把分支名取作 <code>v0.8.1</code>，但這邊還是稍微注意一下比較好。</p>
<p>這邊再做最後一個補充：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:awdr74100/tag-demo.git tag-demo-copy</span><br></pre></td></tr></table></figure>

<p>標籤不需要像分支得透過 <code>git checkout -t origin/&lt;remote_branch&gt;</code> 才能在本地使用遠端分支，克隆的同時，就已經把全部標籤取回本地了。</p>
<h2 id="標籤與分支差異"><a href="#標籤與分支差異" class="headerlink" title="標籤與分支差異"></a>標籤與分支差異</h2><p>跑過一次上面的流程，相信各位差不多了解標籤的使用了，讓我們回到重點，標籤與分支何謂本質上的差異，先讓我們來看目前的日誌：</p>
<p><img src="https://i.imgur.com/qFcwXBo.png" alt="查看目前 commit 紀錄-7"></p>
<p>新增一個分支並提交一次 commit 紀錄：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b develop</span><br><span class="line"></span><br><span class="line">touch db.json</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add db.json'</span></span><br></pre></td></tr></table></figure>

<p>查看目前日誌：</p>
<p><img src="https://i.imgur.com/1dOSXXU.png" alt="查看目前 commit 紀錄-8"></p>
<p>發現差別了嗎？分支會隨著 commit 而移動，標籤只會停留在當時黏貼的位置，就是這麼簡單，沒有其他差異了，兩者都是貼紙一般的存在，你想要怎麼撕怎麼貼，隨你開心。</p>
<p>實務上，分支會使用在特定部分的開發，而標籤則是使用在特定版本的標記。</p>
<h2 id="Git-指令回顧"><a href="#Git-指令回顧" class="headerlink" title="Git 指令回顧"></a>Git 指令回顧</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新增標籤 (輕量標籤)</span></span><br><span class="line">git tag &lt;tag_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定節點新增標籤 (輕量標籤)</span></span><br><span class="line">git tag &lt;tag_name&gt; &lt;SHA-1&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增標籤 (帶註解標籤)</span></span><br><span class="line">git tag &lt;tag_name&gt; -am <span class="string">'message'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定節點新增標籤 (帶註解標籤)</span></span><br><span class="line">git tag &lt;tag_name&gt; &lt;SHA-1&gt; -am <span class="string">'message'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定節點新增標籤 (同上)</span></span><br><span class="line">git tag &lt;tag_name&gt; &lt;SHA-1&gt; -a -m <span class="string">'message'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示提交版本異動</span></span><br><span class="line">git show</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示提交版本異動 (標籤示範)</span></span><br><span class="line">git show &lt;tag_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示所有標籤</span></span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示所有標籤及資訊 (優先顯示帶註解標籤內容，輕量標籤則顯示 commit 訊息內容)</span></span><br><span class="line">git tag -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除指定標籤</span></span><br><span class="line">git tag -d &lt;tag_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定標籤上傳至遠端數據庫</span></span><br><span class="line">git push &lt;repo_name&gt; &lt;tag_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全部標籤上傳至遠端數據庫</span></span><br><span class="line">git push &lt;repo_name&gt; --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除遠端標籤</span></span><br><span class="line">git push &lt;repo_name&gt; :&lt;remote_tag&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除遠端標籤 (v1.7 以後版本可使用)</span></span><br><span class="line">git push --delete &lt;repo_name&gt; &lt;remote_tag&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除遠端標籤 (明確命令)</span></span><br><span class="line">git push &lt;repo_name&gt; :refs/tags/&lt;remote_tag&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除遠端分支 (明確命令)</span></span><br><span class="line">git push &lt;repo_name&gt; :refs/heads/&lt;remote_branch&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 版本控制系統 - cherry-pick 合併提交與 revert 抵銷提交</title>
    <url>/2020-05-05-git-cherrypick-revert/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>跑過前面的文章大概就知道 Git 整個的處理流程了，這次來補充介紹 cherry-pick 與 revert 指令，你可以把 cherry-pick 看做 rebase 底層使用的指令，事實上，rebase 之所以能夠依序的整理提交，過程就是使用 cherry-pick 來執行，而 revert 就更簡單了，以往我們會使用 reset 或 rebase 來重置提交，但僅限於尚未推至遠端的提交，如果重置到了遠端的提交，此時肯定會發生衝突，revert 主要就是被用來解決此問題，以不修改原始提交為原則，新增一個相反的提交以抵銷之前的修改。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>cherry-pick 合併提交</li>
<li>revert 抵銷提交</li>
<li>Git 指令回顧</li>
</ul>
<h2 id="cherry-pick-合併提交"><a href="#cherry-pick-合併提交" class="headerlink" title="cherry-pick 合併提交"></a>cherry-pick 合併提交</h2><p>讓我們先新增一個專案並提交兩次 commit 紀錄：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir project</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> project</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">touch index.html</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add index.html'</span></span><br><span class="line"></span><br><span class="line">touch all.css</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add all.css'</span></span><br></pre></td></tr></table></figure>

<p>建立 <code>feature</code> 分支並提交兩次 commit 紀錄：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b feature</span><br><span class="line"></span><br><span class="line">touch all.js</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add all.js'</span></span><br><span class="line"></span><br><span class="line">touch db.json</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add db.json'</span></span><br></pre></td></tr></table></figure>

<p>此時的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/2sxQc3U.png" alt="查看目前 commit 紀錄-1"></p>
<p>在此情況下如果要進行合併我們通常會使用 merge 或 rebase 來完成，但如果我們不需要 <code>feature</code> 的全部提交呢？比如說我不想要 <code>ca6fca8</code> 這一個提交，你可能會打算用 rebase 來做，之後再用互動模式刪掉這一個提交，但這樣實在是太麻煩了，有沒有更簡單點的做法？讓我們先將 <code>HEAD</code> 切換回 <code>master</code> 分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<p>使用 cherry-pick 挑選想要合併的 commit：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick 057edc1</span><br></pre></td></tr></table></figure>

<p>此時會跳出 commit 以提交的提示：</p>
<p><img src="https://i.imgur.com/OxR8Tcd.png" alt="commit 已提交"></p>
<p>代表 <code>057edc1</code> 紀錄已經被我們複製過來囉，就是這麼簡單，讓我們來看目前的線路圖狀態：</p>
<p><img src="https://i.imgur.com/92hu6rs.png" alt="查看目前 commit 紀錄-2"></p>
<p>cherry-pick 能夠將它分支的 commit 撿過來並進行合併，達到不合併整條分支依然有它分支部分 commit 的效果，讓我們在試一次，回到 <code>feature</code> 分支新增幾個 commit：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">... edit index.html</span><br><span class="line"></span><br><span class="line">git commit -am <span class="string">'change index.html'</span></span><br><span class="line"></span><br><span class="line">touch touch all.scss</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add all.scss'</span></span><br></pre></td></tr></table></figure>

<p>這邊模擬衝突發生的情況，回到 <code>master</code> 分支並新增一個 commit：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">... edit index.html</span><br><span class="line"></span><br><span class="line">git commit -am <span class="string">'change index.html'</span></span><br></pre></td></tr></table></figure>

<p>此時的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/ZXLBvtU.png" alt="查看目前 commit 紀錄-3"></p>
<p>假設我想要 <code>feature</code> 分支的 <code>2841c5b</code> 與 <code>26af41f</code> 紀錄，可以這樣做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick 2841c5b 26af41f</span><br></pre></td></tr></table></figure>

<p>後面的 commit 是可以無限添加的，但如果 commit 太多，使用 rebase 可能是更好的選擇。</p>
<p><code>cherry-pick</code> 與 <code>merge</code> 或 <code>rebase</code> 相同，都可能會遇到衝突的情況，如下所示：</p>
<p><img src="https://i.imgur.com/ZurA1Hz.png" alt="cherry-pick 衝突發生"></p>
<p>一樣先用 <code>git status</code> 壓壓驚：</p>
<p><img src="https://i.imgur.com/8r0IuVu.png" alt="git status"></p>
<p>cherry-pick 與 rebase 處理衝突方式幾乎一模一樣，畢竟 rebase 底層就是使用 cherry-pick 來做，cherry-pick 提示了可以使用以下指令處理衝突：</p>
<ul>
<li>跳過當下 commit，並執行下一個 commit：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick --skip</span><br></pre></td></tr></table></figure>

<ul>
<li>取消 cherry-pick 操作，回到 cherry-pick 前狀態：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick --abort</span><br></pre></td></tr></table></figure>

<p>是不是與 rebase 差不多？逃避問題向來不是我們的風格，請將衝突解決並提交至索引區：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">... resolve conflict</span><br><span class="line"></span><br><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>與 rebase 解法相同，但要注意關鍵字是 cherry-pick，執行以下命令以進行下一個任務：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>

<p>此時一樣會跳出 commit 以提交至本地數據庫的提示，最後的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/ENKj3f5.png" alt="查看目前 commit 紀錄-4"></p>
<p>大功告成！這邊補充一點，我們拿 <code>feature</code> 分支的 <code>ca6fca8</code> 來做示範，執行以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick ca6fca8 -n</span><br></pre></td></tr></table></figure>

<p><code>-n</code> 全名為 <code>--no-commit</code>，可告知 Git 不要自動提交，並將檔案放置在索引區，我們可以使用 <code>git status</code> 查看：</p>
<p><img src="https://i.imgur.com/ea8tLcO.png" alt="查看檔案狀態-1"></p>
<p>有關 <code>ca6fca8</code> 的更動就都被放到索引區了，如果當時 cherry-pick 是選取多個 commit 的話，所有更動都會一併被放置在索引區，此時你只要透過 commit 即可將所有提交當做一個 coomit 提交出去，或者你也可以各別提交達到與預設同樣的效果。</p>
<p>這邊在補充一個參數，假設我們 cherry-pick 時不想要使用原先的提交訊息，可以這樣做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick ca6fca8 -e</span><br></pre></td></tr></table></figure>

<p><code>-e</code> 全名為 <code>--edit</code>，可告知 Git 需要編輯提交訊息，此時會跳出預設編輯器讓你輸入提交訊息，最後呈現的結果如下：</p>
<p><img src="https://i.imgur.com/6EP7uLZ.png" alt="查看目前 commit 紀錄-5"></p>
<h2 id="revert-抵銷提交"><a href="#revert-抵銷提交" class="headerlink" title="revert 抵銷提交"></a>revert 抵銷提交</h2><p>有時我們會遇到以被推至遠端的檔案存在 Bug 的問題，如果這一個檔案還未被推至遠端，你大可放心使用 reset 或 rebase 來重置這一個檔案，反正別人又同步不到你的提交，但如果你已經把檔案推至遠端了呢？且夥伴已經將你的提交同步到他的本地了，此時該怎麼半？如果你用 reset 或 rebase 修復這一個檔案並推至雲端，夥伴要與遠端溝通時，肯定會報錯，此時推薦使用 revert 來修復這個檔案，我們以之前的專案來做範例。</p>
<p>目前線路圖狀態：</p>
<p><img src="https://i.imgur.com/6EP7uLZ.png" alt="查看目前 commit 紀錄-6"></p>
<p>這是我們之前最後的結果，先將此專案推至遠端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:awdr74100/revert-demo.git</span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>此時的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/hEqJG7m.png" alt="查看目前 commit 紀錄-7"></p>
<p><code>master</code> 已經被同步到遠端數據庫上面了，此時我們發現 <code>18f9dcc</code> 這個 commit 存在 Bug 需要被修復，使用 reset 重置提交：</p>
<blockquote>
<p>這邊模擬錯誤的操作</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset HEAD^</span><br><span class="line"></span><br><span class="line">... fix bug</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add db.json'</span></span><br></pre></td></tr></table></figure>

<p>此時的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/HeGUTU0.png" alt="查看目前 commit 紀錄-8"></p>
<p>如果你將此提交推至遠端肯定會報衝突，就算你透過修復方式成功上傳，夥伴要同步時也會發生衝突，搞得大家都會發生衝突，這就是為什麼之前一直強調 rebase 與 reset 千萬不要用在以推至遠端的 commit 上，他們都會改變歷史紀錄，造成所謂的衝突發生，正確的做法應該是使用 revert 才對，先將提交進行還原：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset 18f9dcc --hard</span><br></pre></td></tr></table></figure>

<p>使用 revert 反轉指定 commit 內容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git revert 18f9dcc</span><br></pre></td></tr></table></figure>

<p>此時的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/Tq0TYwj.png" alt="查看目前 commit 紀錄-9"></p>
<p>你會發現多了一個 commit 紀錄，這一個 commit 剛好抵銷了 <code>18f9dcc</code> 的版本內容，類似 +10 + (-10) 的概念，達到了所謂重置的效果，此時 <code>c8a1261</code> 節點的狀態就會正好是 <code>474b25d</code> 節點的狀態，這也就是 revert 的功能，他會新增一個 commit 來抵銷指定的 commit 內容，對於 Git 來說，只是新增了一個 commit 紀錄，歷史紀錄並沒有更動到，不管是 Push 或 Fetch 也都不會有問題，讓我們在試一次：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git revert 474b25d --no-edit</span><br></pre></td></tr></table></figure>

<p><code>--no-edit</code> 參數可用來告知 Git 直接使用預設訊息，過程就不會跳出輸入訊息視窗了，此時的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/Y2zAeky.png" alt="查看目前 commit 紀錄-10"></p>
<p><code>474b25d</code> 也被我們反轉了，此時的版本狀態就會與 <code>f5315c1</code> 一樣，這邊要注意，revert 並不像 reset 是把指定節點後的提交全部重置，revert 只會作用在單個提交上，這時你可能會問，我可以 revert 更以前的提交嗎？答案是可以的，但要注意相依性的問題，以上面範例來看，<code>da58123</code> 是可以成功被 revert 的，但 <code>12981b3</code> 可能就不會 revert 的這麼順利，可以參考以下指令解決衝突的問題：</p>
<ul>
<li>跳過當下 commit，並執行下一個 commit：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git revert --skip</span><br></pre></td></tr></table></figure>

<ul>
<li>取消 revert 操作，回到 revert 前狀態：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git revert --abort</span><br></pre></td></tr></table></figure>

<ul>
<li>直行下一個進程：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git revert --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>

<h2 id="Git-指令回顧"><a href="#Git-指令回顧" class="headerlink" title="Git 指令回顧"></a>Git 指令回顧</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 合併單個指定提交</span></span><br><span class="line">git cherry-pick &lt;SHA-1&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合併多個指定提交</span></span><br><span class="line">git cherry-pick &lt;SHA-1&gt; &lt;SHA-1&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳過當下 commit，並執行下一個 commit</span></span><br><span class="line">git cherry-pick --skip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消 cherry-pick 操作，回到 cherry-pick 前狀態：</span></span><br><span class="line">git cherry-pick --abort</span><br><span class="line"></span><br><span class="line"><span class="comment"># 進入下一個 cherry-pick 進程</span></span><br><span class="line">git cherry-pick --<span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合併單個指定提交 (取消自動提交，並將檔案放置在索引區)</span></span><br><span class="line">git cherry-pick &lt;SHA-1&gt; -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合併單個指定提交 (同上)</span></span><br><span class="line">git cherry-pick &lt;SHA-1&gt; --no-commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合併單個指定提交 (修改提交訊息)</span></span><br><span class="line">git cherry-pick &lt;SHA-1&gt; -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合併單個指定提交 (同上)</span></span><br><span class="line">git cherry-pick &lt;SHA-1&gt; --edit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反轉指定提交</span></span><br><span class="line">git revert &lt;SHA-1&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反轉指定提交 (使用預設提交訊息)</span></span><br><span class="line">git revert &lt;SHA-1&gt; --no-edit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳過當下 commit，並執行下一個 commit</span></span><br><span class="line">git revert --skip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消 revert 操作，回到 revert 前狀態：</span></span><br><span class="line">git revert --abort</span><br><span class="line"></span><br><span class="line"><span class="comment"># 進入下一個 revert 進程</span></span><br><span class="line">git revert --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 版本控制系統 - stash 暫存修改內容</title>
    <url>/2020-05-06-git-stash/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有時候我們會遇到需臨時修改它分支的狀況，這邊的臨時代表正在開發的項目並不是它分支的內容，比如說 master 分支需做緊急修改，但我們目前正在跑 feature 分支的進度，這時你可能會將 feature 尚未提交成 commit 的修改內容複製到一個空白文件上，以確保修改內容不會不見，最後當 master 分支修改完成時，再將修改內容貼回到 feature 上，這確實也是個辦法，但其實不用這麼麻煩，Git 本身就有專門處理此情況的指令，名為 stash，可將當下分支的修改內容暫存起來，日後有需要再將它取出即可。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>stash 暫存修改內容</li>
<li>reset 模擬暫存修改內容</li>
<li>Git 指令回顧</li>
</ul>
<h2 id="stash-暫存修改內容"><a href="#stash-暫存修改內容" class="headerlink" title="stash 暫存修改內容"></a>stash 暫存修改內容</h2><p>讓我們先新增一個專案並提交兩次 commit 紀錄：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir project</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> project</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">touch index.html</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add index.html'</span></span><br><span class="line"></span><br><span class="line">touch all.css</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add all.css'</span></span><br></pre></td></tr></table></figure>

<p>建立 <code>feature</code> 分支並提交數次 commit 紀錄</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b feature</span><br><span class="line"></span><br><span class="line">touch all.js</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add all.js'</span></span><br></pre></td></tr></table></figure>

<p>假設 <code>feature</code> 分支第一階段的需求已經達到了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">git merge feature --no-ff</span><br></pre></td></tr></table></figure>

<p>此時的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/2b4zrTq.png" alt="查看目前 commit 紀錄-1"></p>
<p><code>feature</code> 分支已被合併到 <code>master</code> 分支，接著進行第二階段的工作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line"></span><br><span class="line">... edit index.html</span><br><span class="line"></span><br><span class="line">touch db.json</span><br></pre></td></tr></table></figure>

<p>此時的檔案狀態為：</p>
<p><img src="https://i.imgur.com/ysHErRX.png" alt="查看檔案狀態-1"></p>
<p>假設老闆臨時叫你去修改 <code>master</code> 分支的內容，我們可使用以下指令將當前分支的修改給暫存下來：</p>
<ul>
<li>暫存當前分支修改內容：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>

<ul>
<li>暫存當前分支修改內容 (包含未追蹤)：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash -u</span><br></pre></td></tr></table></figure>

<p>因為 <code>db.json</code> 屬於未追蹤的檔案，所以在這邊需要添加 <code>-u</code> 參數告知需包含未追蹤檔案，在這邊補充一點，你可能看過下面這道類似的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash save</span><br></pre></td></tr></table></figure>

<p>這道命令在 v2.16 的 Git 版本已被棄用，取而代之的是使用 <code>push</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash push</span><br></pre></td></tr></table></figure>

<p>事實上，這兩道命令都可以達到相同的目的，只差在 <code>save</code> 無法擁有 <code>push</code> 的 pathspec 參數功能，由於較冷門，這邊我們不討論 pathspec 參數，你可能會好奇，那 <code>git stash push</code> 的功能是什麼？簡單來講，<code>git stash</code> 就等效於 <code>git stash push</code>，少打 <code>push</code> 只是方便你輸入而已，但我建議還是輸入完整指令比較好，等等會在說明，此時的檔案狀態為：</p>
<p><img src="https://i.imgur.com/dvIJDuJ.png" alt="查看檔案狀態-2"></p>
<p>你會發現修改內容都不見了，如同使用 <code>git checkout .</code> 與 <code>git clean -f</code> 一般，事實上，它是把修改內容都暫存到了 <code>/.git/refs/stash</code> 檔案內，我們可使用以下指令查看所有暫存內容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure>

<p>暫存以清單呈現：</p>
<p><img src="https://i.imgur.com/1trpxZK.png" alt="git stash list 列出暫存清單-1"></p>
<p>為什麼會是以清單呈現呢？暫存檔總不可能只有一個吧，這邊我們到 <code>master</code> 分支也新增一個暫存檔看看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">... edit all.css</span><br><span class="line"></span><br><span class="line">git stash push -m <span class="string">'edit all.css'</span></span><br></pre></td></tr></table></figure>

<p>這邊有一個大雷點，<code>-m</code> 參數是用來告知 Git 使用自訂的暫存訊息，必須使用完整的 <code>git stash push</code> 才能作用，你沒辦法寫做 <code>git stash -m</code>，這樣會跳找不到命令，這是我實測的結果，所以為什麼前面說盡量寫成完整的命令，就是這個原因，此時的暫存內容就會多一筆：</p>
<p><img src="https://i.imgur.com/6p1sO2a.png" alt="git stash list 列出暫存清單-2"></p>
<p>目前我們已經把修改內容暫存到 Git 內了，假設你已經完成臨時的任務，此時可使用以下指令取出暫存內容：</p>
<ul>
<li>將最新暫存套用至當前分支，成功後銷毀暫存 (即 stash@{0})：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure>

<ul>
<li>將指定暫存套用至當前分支，成功後銷毀暫存：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash pop stash@&#123;1&#125;</span><br></pre></td></tr></table></figure>

<p>以下為 <code>feature</code> 分支取出暫存內容的結果：</p>
<p><img src="https://i.imgur.com/IiQ34qN.png" alt="使用 pop 取出暫存內容"></p>
<p>此時你當時所做的修改就都回來了，是不是很方便？使用 <code>pop</code> 可以把某個 stash 拿出來並套用在目前的分支上，套用完成即銷毀這個暫存內容，如果你不想銷毀暫存內容，可改用以下指令：</p>
<ul>
<li>將最新暫存套用至當前分支，成功後保留暫存：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure>

<ul>
<li>將指定暫存套用至當前分支，成功後保留暫存：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash apply stash@&#123;1&#125;</span><br></pre></td></tr></table></figure>

<p><code>apply</code> 只會將暫存做套用的動作，並不會銷毀暫存，如果你不想要某個暫存了，可使用以下指令：</p>
<ul>
<li>刪除最新暫存 (即 stash@{0})：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash drop</span><br></pre></td></tr></table></figure>

<ul>
<li>刪除指定暫存：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash drop stash@&#123;1&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>刪除全部暫存：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure>

<p>以上就是 stash 命令的相關操作。</p>
<h2 id="reset-模擬暫存修改內容"><a href="#reset-模擬暫存修改內容" class="headerlink" title="reset 模擬暫存修改內容"></a>reset 模擬暫存修改內容</h2><p>這邊主要參考 <a href="https://reurl.cc/vDvNNj" target="_blank" rel="external nofollow noopener noreferrer">為你自己學 Git</a> 文章，使用 reset 來模擬暫存修改內容，讓我們先看目前的狀態：</p>
<p><img src="https://i.imgur.com/FjfYp9H.png" alt="查看檔案狀態-3"></p>
<p>由於剛剛我們只有套用 <code>feature</code> 分支的暫存檔，這邊我們也連同套用 <code>master</code> 分支的暫存檔。</p>
<p>其實關於暫存的操作並不一定要使用 stash 來完成，我們也可以透過土法煉鋼的方式來操作，直接將修改內容提交至本地庫：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'stash file'</span></span><br></pre></td></tr></table></figure>

<p>此時的 Git 就會是 nothing to commit 狀態，與使用 <code>git stash</code> 結果相同，假設我們完成它分支的任務了，使用以下指令把 commit 還原到工作目錄：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset HEAD^ --mixed</span><br></pre></td></tr></table></figure>

<p><code>--mixed</code> 為 reset 預設模式，即丟回工作目錄，這邊千萬不要使用 <code>--hard</code> 模式阿，你的修改內容就要說掰掰了 (還是可以用 reflog 查詢並還原拉)。</p>
<p>此時的結果就會與使用 <code>git stash pop</code> 相同，並沒有說哪一種方式比較好，只要你夠熟悉 Git 指令，確實有相當多的方法可以達到同樣效果。</p>
<h2 id="Git-指令回顧"><a href="#Git-指令回顧" class="headerlink" title="Git 指令回顧"></a>Git 指令回顧</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 暫存當前分支修改內容</span></span><br><span class="line">git stash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暫存當前分支修改內容 (包含未追蹤)</span></span><br><span class="line">git stash -u</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暫存當前分支修改內容 (已棄用)</span></span><br><span class="line">git stash save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暫存當前分支修改內容 (完整指令)</span></span><br><span class="line">git stash push</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有暫存項目</span></span><br><span class="line">git stash list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暫存當前分支修改內容 (修改預設暫存訊息)</span></span><br><span class="line">git stash push -m <span class="string">'message'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 將最新暫存套用至當前分支，成功後銷毀暫存 (即 stash@&#123;0&#125;)</span></span><br><span class="line">git stash pop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將指定暫存套用至當前分支，成功後銷毀暫存</span></span><br><span class="line">git stash pop stash@&#123;1&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將最新暫存套用至當前分支，成功後保留暫存 (即 stash@&#123;0&#125;)</span></span><br><span class="line">git stash apply</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將指定暫存套用至當前分支，成功後保留暫存</span></span><br><span class="line">git stash apply stash@&#123;1&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除最新暫存 (即 stash@&#123;0&#125;)</span></span><br><span class="line">git stash drop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除指定暫存</span></span><br><span class="line">git stash drop stash@&#123;1&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除全部暫存</span></span><br><span class="line">git stash clear</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 版本控制系統 - Fork 複製倉庫與 Pull Request 請求合併</title>
    <url>/2020-05-07-git-fork-pullrequest/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前我們都是在自己的遠端數據庫做操作，由於是自己的並不會遇到所謂的權限問題，但假如我們也想操作其他開發者的遠端數據庫呢？比如你正在使用的套件存在 Bug，而你剛好有能力修復，將專案克隆並修復後，你想把最新提交推至原作的遠端數據庫，這時就會遇到權限不足的問題，你可能透過 Email 請作者開權限給你，但你覺得他會理你嗎？通常這個過程我們都會使用 Fork 與 Pull Request 來完成，先將原作的數據庫 Fork 至帳號底下，待我們克隆並修復完成後，再透過 Pull Request 請求作者合併更新。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>推至遠端時所遇權限不足問題</li>
<li>Fork 其他開發者專案</li>
<li>發送 Pull Request 請求合併</li>
<li>處理 Pull Request 檢查是否合併</li>
<li>同步 Pull Request 後的專案進度</li>
<li>Pull Request 衝突解決辦法</li>
</ul>
<h2 id="推至遠端時所遇權限不足問題"><a href="#推至遠端時所遇權限不足問題" class="headerlink" title="推至遠端時所遇權限不足問題"></a>推至遠端時所遇權限不足問題</h2><p>這邊我們來模擬推至遠端時所遇權限不足問題，假設我們的專案使用了 Vue 進行開發，但發現存在一處 Bug 須修復，我們可能會這樣做：</p>
<p><img src="https://i.imgur.com/mTLV1iZ.png" alt="Vue.js"></p>
<p>如同處理自己的遠端數據庫一般，可使用 HTTPS 或 SSH 方式克隆回本地：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b dev git@github.com:vuejs/vue.git vue</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> vue</span><br></pre></td></tr></table></figure>

<p>這邊要注意，並不是說操作其他開發者的遠端數據庫時，都會遇到身分驗證的提示，你想想看，我只是單純克隆別人的數據庫，為什麼需要身分驗證呢？如果你不想把數據庫給公開，你可以設置為 <code>Private</code> 屬性，此時陌生人就看不到你的遠端數據庫囉，上面提到的都是屬於克隆操作，那假設我們要進行推至遠端的動作呢？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch test123.txt</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add test123.txt'</span></span><br><span class="line"></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>此時會跳出無訪問權限的提示：</p>
<p><img src="https://i.imgur.com/aV3GRpO.png" alt="git push 權限不足"></p>
<p>這蠻合理的嗎，克隆並不會影響原作者的數據庫，但 Push 就會了，你敢想像自己的遠端數據庫突然被陌生人 <code>git push -f</code> 嗎？一般來說我們只能操作自己的遠端數據庫，並不能操作別人的數據庫，但可透過 Fork 與 PR (為 Pull Request 縮寫) 與原作者做交流，了解了原由，接下來讓我們進入到主要的章節吧！</p>
<h2 id="Fork-其他開發者專案"><a href="#Fork-其他開發者專案" class="headerlink" title="Fork 其他開發者專案"></a>Fork 其他開發者專案</h2><p>為了示範原作者與陌生開發者各自的操作，這邊我開了兩支帳號來示範，角色如下：</p>
<ul>
<li>原作者：<a href="https://github.com/lanroya" target="_blank" rel="external nofollow noopener noreferrer">lanroya</a></li>
<li>陌生開發者：<a href="https://github.com/awdr74100" target="_blank" rel="external nofollow noopener noreferrer">awdr74100</a></li>
</ul>
<p>目前我們登入的帳號是 lanroya，建立一個專案並提交兩次 commit 紀錄：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir pr-demo</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> pr-demo</span><br><span class="line"></span><br><span class="line">touch all.css</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'add all.css'</span></span><br><span class="line"></span><br><span class="line">... edit all.css</span><br><span class="line"></span><br><span class="line">git commit -am <span class="string">'edit all.css &gt; .a'</span></span><br></pre></td></tr></table></figure>

<p>假設初步的操作已經完成，在 GitHub 新增一個遠端數據庫並 Push：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/lanroya/pr-demo.git</span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>此時 lanroya 帳號底下就會有自己的 pr-demo 專案：</p>
<p><img src="https://i.imgur.com/cm8V25n.png" alt="lanroya 帳號底下的專案"></p>
<p>接著 awdr74100 開發者發現這個專案蠻有趣的但存在些 Bug，他想要幫忙修復，先執行 Fork：</p>
<p><img src="https://i.imgur.com/6JPxfh8.png" alt="fork 專案"></p>
<p>這邊要注意，fork 並不屬於 Git 的指令，它是 GitHub 等遠端伺服器相當特別的功能，主要能將指定專案複製一份到你的帳號底下，當你按下了 fork 按鈕，會跳出以下畫面：</p>
<p><img src="https://i.imgur.com/CT2AO0V.png" alt="fork 轉場畫面"></p>
<p>代表正在 fork 此專案到你的帳號底下，完成後會跳轉到你帳號底下的這個專案：</p>
<p><img src="https://i.imgur.com/uUvMGAc.png" alt="fork 完成後跳轉"></p>
<p>到這邊就已經完成 fork 的動作了，可以到帳號底下查看是否有這一個目標專案。</p>
<p>你可能會好奇，這樣有什麼作用？還記得上面提到的權限不足問題嗎？當我們去存取帳號底下除外的專案時，會遇到 Push 操作無訪問權限的提示，而 fork 的用意就是將陌生專案拷貝一份到你的帳號底下，之後我們就可以如同帳號底下專案操作一般，針對此專案進行 Fetch、Pull、Push 的操作，接著我們來修復這個 Bug 吧：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/awdr74100/pr-demo.git pr-demo</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> pr-demo</span><br><span class="line"></span><br><span class="line">... edit all.css</span><br><span class="line"></span><br><span class="line">git commit -am <span class="string">'edit all.css &gt; b'</span></span><br></pre></td></tr></table></figure>

<p>當我們修復完成後，由於是自己帳號底下的數據庫，並不會造成所謂的 Push 無訪問權限問題：</p>
<p><img src="https://i.imgur.com/T1FnyUf.png" alt="-3-(https://i.imgur.com/sbp2WfH.png)1"></p>
<p>目前 Bug 就已經被 awdr74100 修復了，但這邊所謂的修復是指在 awdr74100 拷貝的專案下進行修復，原作者的專案是不受任何影響的，如果要告知原作者 Bug 已被修復，可以使用 Pull Request 功能，直接進入下個章節。</p>
<h2 id="發送-Pull-Request-請求合併"><a href="#發送-Pull-Request-請求合併" class="headerlink" title="發送 Pull Request 請求合併"></a>發送 Pull Request 請求合併</h2><p>目前 awdr74100 已經把 Bug 給修復完成了，但 lanroya 還不知道，這過程可透過 PR (Pull Request) 來完成：</p>
<p><img src="https://i.imgur.com/yyrLP8m.png" alt="New Pull Request"></p>
<p>在 awdr74100 拷貝的專案底下有 Pull request 的區塊可做選擇，點擊後的畫面如上圖，接者點擊 <code>New pull request</code> 按鈕，此時會跳出以下畫面：</p>
<p><img src="https://i.imgur.com/Q8QKJUz.png" alt="發送 Pull Request"></p>
<p>畫面跳轉到了 lanroya 的頁面，這邊我們就可選擇剛剛修復完成的分支進行請求合併，在之前的文章我們有說過 GitHub 等遠端伺服器是採用「合併」的方式來更新內容，Pull Request 你可以把它理解為將最新的 commit 提交丟給原作者，讓原作者判斷是否要合併這一個 commit 提交。</p>
<p>這邊還有一個重點是關於 <code>Able to merge</code> 字樣，它能夠告訴你這一個 PR 如果作者接受的話是否會發生衝突，畢竟 PR 不太可能只有一個人發，如果你的專案很知名，像 React、Vue 等等，作者接受了第一個 PR，但要接受第二個 PR 時，就有可能發生錯誤，因為提交紀錄被改變了阿，從原本的兩個 commit，變成了三個 commit，假如你的 PR 還是處於兩個 commit 的狀態，就會跳衝突，這我們之後再說，確認 PR 沒問題後，就可以點擊 <code>Create pull request</code> 按鈕囉，此時會切換為以下畫面：</p>
<p><img src="https://i.imgur.com/Bn1GUbB.png" alt="PR 訊息"></p>
<p>預設的標題為當時提交的 commit 訊息，你可以隨意做修改，如果要進行補充，也可以寫在下方的空白區域內，此區域是支援 Markdown 語法的喔，確認沒問題就可以點擊 <code>Create pull request</code> 發送 PR 囉，結果畫面為：</p>
<p><img src="https://i.imgur.com/WMvvX3P.png" alt="PR 發送成功"></p>
<p>到這邊我們的 PR 就已經發送成功，你可以在下方繼續進行補充，接下來就等作者 (lanroya) 檢查並判斷是否接受合併囉。</p>
<h2 id="處理-Pull-Request-檢查是否合併"><a href="#處理-Pull-Request-檢查是否合併" class="headerlink" title="處理 Pull Request 檢查是否合併"></a>處理 Pull Request 檢查是否合併</h2><p>接著我們換原作者 (lanroya) 的部分，登入 lanroya 帳號後並切換到指定數據庫會看到以下畫面：</p>
<blockquote>
<p>當有 PR 請求時，作者也會收到 Email 的通知</p>
</blockquote>
<p><img src="https://i.imgur.com/Yx7XR6c.png" alt="原作者 GitHub 畫面"></p>
<p>有發現不一樣的地方嗎？沒錯，有人發送了 Pull Request 給我們，讓我們點擊進去看看：</p>
<p><img src="https://i.imgur.com/uQvJqEE.png" alt="Pull Request 清單"></p>
<p>在這邊你可以看到所有的 PR 紀錄，正好第一筆不就是剛剛 awdr74100 發送給我們的 PR 嗎？點擊進入：</p>
<p><img src="https://i.imgur.com/6qrEbrY.png" alt="PR 詳細頁面"></p>
<p>你可以看到有關這個 PR 的各種資訊，比如說提交幾次 commit 阿，代碼哪裡做了更動阿，這些都看的到，你也可以在下方的互動區塊與提交者 (awdr74100) 做互動，這邊最重要的是檢查此 PR 是否會發生衝突，你可以直接從它的提示去得知，如果確認都沒問題，就直接按下 <code>Merge pull request</code> 按鈕吧！</p>
<p>此時會要求你輸入此次提交的 commit 紀錄訊息，就如同 <code>non-fast-forward</code> 處理一般，這邊我們採用預設訊息即可，按下 <code>Confirm merge</code> 確認合併吧！</p>
<p><img src="https://i.imgur.com/6qrEbrY.png" alt="Confirm merge"></p>
<p>此時 PR 狀態會從 <code>Open</code> 更改為 <code>Merged</code>，代表合併成功囉。</p>
<p>那要怎麼確認 PR 是否真的合併成功呢？你可以切換到主頁面並點選 <code>commits</code> 查看所有提交紀錄：</p>
<p><img src="https://i.imgur.com/VbpUVlz.png" alt="commits 查看所有提交紀錄"></p>
<p>或是直接在 lanroya 的 bash 輸入以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>因為遠端數據庫有了新的提交紀錄，我們可以把它 Fetch 回來並查看：</p>
<p><img src="https://i.imgur.com/Ug6kmvm.png" alt="fetch PR 提交"></p>
<p>看到我們剛剛 merge 的 PR 提交囉，此時一樣使用 merge 即可同步遠端的提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure>

<p>以上就是整個發送 PR 的流程，是不是很有趣？發送 PR 不只可以應用在開源專案上，企業內部也很常使用此方式來處理夥伴間的提交，達到流程化的效果。</p>
<h2 id="同步-Pull-Request-後的專案進度"><a href="#同步-Pull-Request-後的專案進度" class="headerlink" title="同步 Pull Request 後的專案進度"></a>同步 Pull Request 後的專案進度</h2><p>這邊我們做一個補充，原作者要同步遠端數據庫的內容相對簡單，上面就已經有示範，但陌生開發者 (awdr74100) 可能就需要點技巧了，發送的 PR 就算已被原作者合併，fork 過來的專案也不會有任何變化，帳號底下的這個專案看起來雖然是個克隆體，但本質上與原作者的數據庫是完全不一樣的東西，如果想要完成同步，有以下方法可做選擇：</p>
<ul>
<li>把克隆專案改掉，重新 fork 專案</li>
<li>新增原作遠端數據庫位址，並手動同步專案</li>
</ul>
<p>砍掉重練方法相對簡單，你不需要輸入任何指令，每次 fork 的狀態一定就是最新的，各位可自行試試，這邊就不做示範，我自己是比較習慣新增原作的遠端數據庫位址並手動同步專案，以下為示範：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add lanroya https://github.com/lanroya/pr-demo.git</span><br></pre></td></tr></table></figure>

<p>檢查是否成功新增遠端數據庫位址：</p>
<p><img src="https://i.imgur.com/SEFwBYP.png" alt="新增遠端數據庫位址"></p>
<p>在前面我們有提到使用 clone 或 fetch 等方式是不會跳出無訪問權限提示的，因為又不影響原作者的數據庫，這邊我們就可以用同樣方式來處理 PR 後的提交紀錄，上面新增了原作者的遠端數據庫位址，接下來進行 fetch 動作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch lanroya mastr</span><br></pre></td></tr></table></figure>

<p>此時的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/W6c7Con.png" alt="-3-(https://i.imgur.com/sbp2WfH.png)2"></p>
<p>你會發現原作者的遠端數據庫就被我們拉下來了，接著直接合併即可完成同步動作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge lanroya/master</span><br></pre></td></tr></table></figure>

<p>說真的這也沒多複雜，我比較推薦使用此方式來完成同步操作，某方面來講可能會比較簡單。</p>
<h2 id="Pull-Request-衝突解決辦法"><a href="#Pull-Request-衝突解決辦法" class="headerlink" title="Pull Request 衝突解決辦法"></a>Pull Request 衝突解決辦法</h2><p>在上面我們有提到 PR 也是會發生衝突的，且機率還挺高的，我們來模擬這一狀況：。</p>
<p>假設原作者 (lanroya) 更新的專案進度：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">... edit all.css</span><br><span class="line"></span><br><span class="line">git commit -am <span class="string">'edit all.css &gt; .c'</span></span><br></pre></td></tr></table></figure>

<p>很自然的將它推上遠端數據庫：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>此時陌生開發者 (awdr74100) 忘記先同步原作者專案就直接發 PR：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">... edit all.css</span><br><span class="line"></span><br><span class="line">git commit -am <span class="string">'edit all.css .c'</span></span><br><span class="line"></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>在這邊我們刻意模擬同步的衝突以及代碼的衝突，此時 PR 的畫面為：</p>
<p><img src="https://i.imgur.com/r7gkfAH.png" alt="PR 發生衝突"></p>
<p>你會發現它顯示了 <code>Can&#39;t automatically merge</code> 字樣，代表此 PR 會發生合併衝突，雖然你還是能把此 PR 發出去，但我建議在未發送前就解決這個衝突，你現在不解決，最後原作者還是得解決，但它合併的意願可能就不大了，解決辦法很簡單，如同我們自己的遠端數據庫合併衝突辦法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch lanroya master</span><br></pre></td></tr></table></figure>

<p>此時的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/sbp2WfH.png" alt="查看目前 commit 紀錄-3"></p>
<p>原來是未同步提交紀錄所發生的衝突阿，此時我們可以這樣做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase lanroya/master</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge lanroya/master</span><br></pre></td></tr></table></figure>

<p>由於我不想要提交額外的 commit 紀錄，這邊我使用 rebase 來合併分支，如果順利的話分支就會被合併，但剛剛我也刻意模仿代碼發生的衝突，此時也就會跳出衝突的錯誤：</p>
<p><img src="https://i.imgur.com/mlQvYgH.png" alt="rebase 發生衝突"></p>
<p>關於 rebase 如何解決衝突，之前在 <a href="https://awdr74100.github.io/2020-05-04-git-rebase/">rebase 文章</a> 就有完整的解說，有興趣的可以過去看看，這邊就快速帶過：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">... resolve conflict</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>

<p>此時的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/O3Lcd4S.png" alt="查看目前 commit 紀錄-4"></p>
<p>這邊要注意，如果你是使用 merge 來合併分支，等等 Push 時就不會發生衝突，而如果你是使用 rebase 來合併分支，由於遠端指向的 <code>38a67a3</code> 提交已被拋棄 (隱藏)，本地改而指向剛剛 rebase 新生成的 <code>eddd006</code> 節點，歷史紀錄不同就會導致衝突，這邊很適合使用以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure>

<p>你可能會想，不是盡量不要使用這個命令嗎？沒錯，但此提交也只有我一個人在運作，何況我們沒有修改到原作者的紀錄阿，這種情況就比較沒關係，讓我們來看目前發 PR 還會不會有衝突：</p>
<p><img src="https://i.imgur.com/57BVALN.png" alt="PR 衝突以解決"></p>
<p>這一次的 PR 就不會有合併衝突囉，後面的流程就如同前面所介紹，各位可以自己跑一次看看。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 版本控制系統 - GitHub Flow 工作流程與實際演練</title>
    <url>/2020-05-11-git-githubflow/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>隨著專案越來越大，協作人員越來越多，衝突發生的機率也越來越高，訂定良好的團隊規範就顯得更為重要，Workflow 因此而誕生，常見的對象有 Git Flow、GitHub Flow 或 GitLab flow 等，主要都是被用來解決團隊間無規範可遵循造成衝突的問題，透過共同遵循的處理流程，達到有條理的進行團隊協作開發。此篇將介紹目前主流的 GitHub Flow 工作流程是如何運作，並透過實際演練說明它所能帶給團隊的好處。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>GitHub Flow 介紹</li>
<li>建立 Organization 組織</li>
<li>GitHub Flow 實際演練</li>
<li>Heroku 自動部屬</li>
</ul>
<h2 id="GitHub-Flow-介紹"><a href="#GitHub-Flow-介紹" class="headerlink" title="GitHub Flow 介紹"></a>GitHub Flow 介紹</h2><p>讓我們先來看 <a href="https://guides.github.com/introduction/flow/" target="_blank" rel="external nofollow noopener noreferrer">官方</a> 的介紹：</p>
<blockquote>
<p>GitHub flow is a lightweight, branch-based workflow that supports teams and projects where deployments are made regularly.</p>
</blockquote>
<p>你現在一定很困惑，沒關係，我當時看到也是滿臉問號，簡單來講呢，GitHub Flow 是基於創建分支所運作，最大的特點在於其流程非常簡單，你不需要像 Git Flow 一樣創建多達 5 種的分支，有新功能需求時在創建對應的 <code>feature</code> 分支即可，其中的主要流程為：</p>
<ul>
<li>創建分支 (Create a branch)</li>
<li>提交修改 (Add commits)</li>
<li>開啟 PR (Open a Pull Request)</li>
<li>代碼審核 (Discuss and review your code)</li>
<li>部屬 (Deploy)</li>
<li>合併 (Merge)</li>
</ul>
<p>剛剛我們提到了創建 <code>feature</code> 分支的部分，當你的功能開發完成後，即透過 PR (Pull Request) 與負責人做溝通，如果有看過我上一篇文章的人應該很熟悉了才對，接著負責人收到你的 PR 後會與你討論相關的內容，確認沒問題即合併到 <code>master</code> 分支，而 <code>master</code> 分支上的每個版本都是可以進行部屬的，這點在我們實際演練時會再做討論，最後即完成了此次的 GitHub Flow 流程，日後有新功能需求時，就只是再重跑一次流程而已。</p>
<p>你可能還是聽得霧煞煞，簡單來講呢，就是我們只會接觸到對應的 <code>feature</code> 分支，當我們的 <code>feature</code> 分支開發完成後，即發送 PR 給負責人，如果確認沒問題負責人就會將這個 PR (<code>feature</code> 分支) 合併到 <code>master</code> 分支，在合併完成後即自動部屬至伺服器，因為放在 <code>master</code> 分支上的每個版本都是可以直接部屬的。</p>
<p>現在你可能就有點頭緒了，為了加強對 GitHub Flow 的了解，讓我們來實際演練一番吧！</p>
<h2 id="建立-Organization-組織"><a href="#建立-Organization-組織" class="headerlink" title="建立 Organization 組織"></a>建立 Organization 組織</h2><p>這邊要強調，GitHub Flow 只是一種工作流程，你可以把它用在開源專案或私有專案上，並沒有說一定要用在哪裡，它更像是一種共識，下面我們會以 GitHub 中的組織 (Organization) 為對象做介紹，說明團隊間是如何使用 GitHub Flow 做運作的，讓我們先在 GitHub 建立一個組織：</p>
<p><img src="https://i.imgur.com/xjHMkOR.png" alt="建立組織"></p>
<p>在 GitHub 建立組織相當簡單，就如同新增遠端數據庫一般，透過點選即可完成，之後會跳出邀請成員的畫面：</p>
<p><img src="https://i.imgur.com/DPpflYE.png" alt="邀請成員"></p>
<p>這邊我們一樣使用兩支帳號來做示範，被邀請的成員需透過 Email 接收邀請才會正式加入組織，最後的結果為：</p>
<p><img src="https://i.imgur.com/b8R9FAb.png" alt="組織畫面"></p>
<p>由於是示範用的，其他細項我們就不做討論，到這邊就已經完成創建組織的動作了，接下來讓我們正式進入到 GitHub Flow 的實際演練章節吧！</p>
<h2 id="GitHub-Flow-實際演練"><a href="#GitHub-Flow-實際演練" class="headerlink" title="GitHub Flow 實際演練"></a>GitHub Flow 實際演練</h2><p>目前我們登入的帳號為 lanroya，也就是組織的管理者，你可以把它當作專案的負責人，他使用了 express-generator 生成專案的初始環境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">express -e express-project</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> express-project</span><br><span class="line"></span><br><span class="line">npm i</span><br></pre></td></tr></table></figure>

<p>新增 <code>.gitignore</code> 檔案：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch .gitignore</span><br></pre></td></tr></table></figure>

<p>忽略 <code>node_modules</code> 資料夾：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; .gitignore</span><br><span class="line"></span><br><span class="line">node_modules&#x2F;</span><br></pre></td></tr></table></figure>

<p>初始化 Git 環境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'建立環境'</span></span><br></pre></td></tr></table></figure>

<p>此時的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/WScL3cV.png" alt="查看目前 commit 紀錄-1"></p>
<p>目前初始環境已經建立完成，你總不可能要求成員使用 USB 來 copy 你的檔案吧？如同新增帳號底下的遠端數據庫一般，在組織新增一個遠端數據庫：</p>
<p><img src="https://i.imgur.com/o8xQyJ0.png" alt="在組織新增遠端數據庫"></p>
<p>我們選擇將組織的遠端數據庫設為公開狀態，當然你也可以設為私有的，但要注意，以預設來說，成員是無法 Fork 私有遠端數據庫的，你必須到組織的設定將其選項打開，成員才可以進行 Fork，組織的遠端數據庫與帳號底下的遠端數據庫基本上沒啥差別，一個是掛在組織底下，一個是掛在帳號底下而已：</p>
<p><img src="https://i.imgur.com/blOjpEv.png" alt="遠端數據庫成功建立"></p>
<p>添加組織的遠端數據庫位址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/roxog/express-project.git</span><br></pre></td></tr></table></figure>

<p>將專案推至遠端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>專案已成功推至遠端：</p>
<p><img src="https://i.imgur.com/wcd7EAH.png" alt="成功推至遠端數據庫"></p>
<p>到這邊負責人的操作就先告一段落了，接下來換成員建立 <code>feature</code> 分支並開發新功能的部分，我們採用 GitHub Flow 來運作，登入 awdr74100 帳號並 Fork 組織的專案：</p>
<p><img src="https://i.imgur.com/kEOSyF1.png" alt="fork 組織的專案"></p>
<p>此時會跳出選擇 Fork 至哪一個帳號的提示，選擇成員 (awdr74100)，之後就會 Fork 至帳號底下：</p>
<p><img src="https://i.imgur.com/7SJKkug.png" alt="成功 fork 專案"></p>
<p>在來的操作就如同帳號底下的遠端數據庫一般，由於我們本地還未有這個資料，這邊先克隆回本地：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/awdr74100/express-project.git project</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> project</span><br></pre></td></tr></table></figure>

<p>查看線路圖狀態：</p>
<p><img src="https://i.imgur.com/6U2F8t3.png" alt="查看目前 commit 紀錄-2"></p>
<p>本文重點來了，GitHub Flow 的第一步是在 <code>master</code> 分支建立 <code>feature</code> 的分支，假設我今天要開發的功能是修改路由，可以這樣做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b feature/edit_router</span><br><span class="line"></span><br><span class="line">... edit /routes/index.js</span><br><span class="line"></span><br><span class="line">git commit -am <span class="string">'修改 router 標題'</span></span><br></pre></td></tr></table></figure>

<p>分支的名稱是可隨意命名的，但必須具備其描述性，目前我們已經完成 GitHub Flow 的第一與第二個步驟了，線路圖狀態為：</p>
<p><img src="https://i.imgur.com/q76yMKN.png" alt="查看目前 commit 紀錄-3"></p>
<p>假設新功能已經開發完成了，先將新提交推至帳號底下的遠端數據庫：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin --all</span><br></pre></td></tr></table></figure>

<p>接著進行 GitHub Flow 的第三步驟，開啟 PR (Pull Request)：</p>
<p><img src="https://i.imgur.com/ZFiRooC.png" alt="開啟 PR"></p>
<p>這邊要注意來源與目的的選擇，你是將 <code>feature/edit_router</code> 推到專案的 <code>master</code> 分支，並不是 <code>master</code> 推 <code>master</code>，如果確認沒問題，就發送 RP 吧，此時 GitHub Flow 的第三步驟也就完成了。</p>
<p>這邊做一個補充，其實也不算補充，如果你有看過上一篇文章的人應該都知道該怎麼做了，如果未來要同步組織的遠端資料庫時，必須添加數據庫的位址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add <span class="built_in">source</span> https://github.com/roxog/express-project.git</span><br></pre></td></tr></table></figure>

<p>這樣之後就可以使用 <code>fetch</code> 或 <code>pull</code> 將負責人合併後的資料給拉下來，達到同步更新的作用，接下來切換到負責人的帳號 (lanroya) 來處理 PR 吧：</p>
<p><img src="https://i.imgur.com/gro36Go.png" alt="處理 PR"></p>
<p>目前來到了 GitHub Flow 的第四個步驟，也就是代碼審核的部分，這邊介紹一個蠻有趣的功能，切換到 <code>Files changed</code> 選項：</p>
<p><img src="https://i.imgur.com/e2vijFv.png" alt="files changed 功能"></p>
<p>你可以點擊更動代碼旁邊的 <code>+</code> 按鈕，或是直接將更動代碼整個選起來以進行討論，看起來會像這樣個樣子：</p>
<p><img src="https://i.imgur.com/sFVSx2r.png" alt="代碼審核"></p>
<p>點擊 <code>Add single comment</code> 即可添加討論，此時有關的人員都會收到此次的評論通知，現在的 <code>Conversation</code> 看起來會像這樣：</p>
<p><img src="https://i.imgur.com/P1KQp2O.png" alt="add single comment"></p>
<p>假設此次的討論已經完成，可以點擊 <code>Resolve conversation</code> 關閉對話，最後確認沒問題的話，點擊 <code>Merge pull request</code> 合併 PR：</p>
<p><img src="https://i.imgur.com/rJg3ywT.png" alt="合併 PR"></p>
<p>到這邊我們就跑完 GitHub Flow 的全部步驟了，此時你可能會想，第五個步驟怎麼沒有說明呢？在前面我們有一直強調 <code>master</code> 分支的每個版本都是可以直接部屬至伺服器的，這也就代表說當我們合併這一個 PR 時，進而生成的提交就等於 production 的版本，在這邊你先理解大概的概念就好，下面我們會介紹如何使用 heroku 自動完成部署動作。</p>
<p>現在你已經會使用 GitHub Flow 運作整個提交流程了，其實就是一直圍繞在 <code>master</code> 開 <code>feature</code> 分支，將 <code>feature</code> 分支推上 fork 的遠端數據庫，之後開啟 PR 發送 <code>feature</code> 分支合併 <code>master</code> 分支的請求，之後又有新功能要開發時，先將本地數據庫與組織數據庫做同步：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull <span class="built_in">source</span> master</span><br><span class="line"></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>此時的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/OtLgsKR.png" alt="查看目前 commit 紀錄-4"></p>
<p>要開發新功能就在開一個 <code>feature</code> 分支，之後再重跑一次 GitHub Flow 的流程，這邊要養成一個好習慣先 <code>pull</code> 在 <code>push</code>，也就是先拉在推，你沒辦法保證在過程中是否會有其他成員提交 PR 並審核通過，如同我們之前所說，歷史紀錄不同，肯定會發生衝突，這邊要特別注意。</p>
<h2 id="Heroku-自動部屬"><a href="#Heroku-自動部屬" class="headerlink" title="Heroku 自動部屬"></a>Heroku 自動部屬</h2><p>這邊我們來補充何謂 <code>master</code> 分支上的每個版本都是可部屬狀態的，通常這個動作會在初始化專案時進行，但為了避免大家混淆，剛剛沒有操作到這一部分，回到 lanroya 帳號操作 Git：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">heroku login</span><br><span class="line"></span><br><span class="line">heroku create</span><br></pre></td></tr></table></figure>

<p>上面操作主要用來在 heroku 開一個伺服器，這邊我們並不會強調 heroku 的使用方式，在之後的 express 章節會再做說明，目前主要用來示範何謂自動部屬，此時的專案會新增 heroku 的遠端位址：</p>
<p><img src="https://i.imgur.com/E57QN7r.png" alt="查看所有遠端數據庫"></p>
<p>將專案推至 heroku 並查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push heroku origin master</span><br><span class="line"></span><br><span class="line">heroku open</span><br></pre></td></tr></table></figure>

<p>此時會跳出以下畫面：</p>
<p><img src="https://i.imgur.com/lWGK47s.png" alt="查看 heroku 部屬畫面-5"></p>
<p>我們的 express 專案已成功部屬在 heroku，你可以把它想像成 GitHub Page 的感覺，目前的線路圖狀態為：</p>
<p><img src="https://i.imgur.com/2qH9EL3.png" alt="查看目前 commit 紀錄"></p>
<p><code>master</code> 分支新增了 <code>heroku/master</code> 的參考，接著到剛剛新增的 heroku 伺服器設定介面：</p>
<p><img src="https://i.imgur.com/7bcH581.png" alt="heroku 啟用自動部屬功能"></p>
<p>點擊 <code>Enable Automatic Deploys</code> 啟用自動部屬功能，這樣就完成了，此後組織專案中的 <code>master</code> 分支只要有變動，heroku 都會自動幫你完成部屬的動作，讓我們來測試一次：</p>
<blockquote>
<p>當前為成員 (awdr74100) 的操作</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b feature/change_router_title</span><br><span class="line"></span><br><span class="line">... edit router title</span><br><span class="line"></span><br><span class="line">git commit -am <span class="string">'再次修改標題'</span></span><br><span class="line"></span><br><span class="line">git push origin --all</span><br></pre></td></tr></table></figure>

<p>開啟 PR：</p>
<p><img src="https://i.imgur.com/MLB56GZ.png" alt="再次開啟 PR"></p>
<p>負責人通過 PR：</p>
<p><img src="https://i.imgur.com/O4nJ1yJ.png" alt="通過 PR"></p>
<p>當你按下 <code>Merge pull request</code> 合併 PR 時，因為 <code>master</code> 分支移動了，heroku 就會開始自動部屬的動作：</p>
<p><img src="https://i.imgur.com/iRXVQ03.png" alt="heroku 自動部屬"></p>
<p>結果頁面：</p>
<p><img src="https://i.imgur.com/QPrM9cr.png" alt="結果頁面"></p>
<p>是不是很酷？我們就再也不需要手動 Push 至 heroku 了，事實上，類似的 PaaS 都有這個功能，比如說我自己非常喜歡的 <a href="https://vercel.com/" target="_blank" rel="external nofollow noopener noreferrer">ZEIT Now</a> 也有這個功能，之後有機會再做示範。</p>
<p>到這邊我們的 Git 學習路程就告一段落囉。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>w3HexSchool</tag>
        <tag>Git</tag>
        <tag>GitHub</tag>
        <tag>GitHub Flow</tag>
        <tag>Heroku</tag>
      </tags>
  </entry>
  <entry>
    <title>Sass / SCSS 預處理器 - 基本介紹與編譯環境建立</title>
    <url>/2020-05-18-scss-install/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前介紹的各種前端工具中，都是使用 SCSS 最為樣式表的開發對象，原因很簡單，那就是它大幅加強了 CSS 對各種操作的支持，以往我們會認為 CSS 語法很單調，但也因為太單調，導致存在許多操作上的不便，現在我們有了 Sass / SCSS 等 CSS 預處理器可以選擇，真正意義上的將樣式表變為一門程式語言，可使用變數、函式、迴圈等程式語言基本就具備的功能達到撰寫樣式表的目的。此篇將從何謂 CSS 預處理器開始介紹，接著說明 Sass / SCSS 該如何透過相關工具使之編譯成 CSS 跑在瀏覽器上。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>什麼是 CSS 預處理器？</li>
<li>Sass 和 SCSS 有什麼區別？</li>
<li>編譯環境建立 - 使用官方 sass 套件</li>
<li>編譯環境建立 - 使用 VSCode 的 Live Sass Compiler 套件</li>
<li>編譯環境建立 - 使用 gulp-sass 套件</li>
<li>編譯環境建立 - 使用 sass-loader 套件</li>
</ul>
<h2 id="什麼是-CSS-預處理器？"><a href="#什麼是-CSS-預處理器？" class="headerlink" title="什麼是 CSS 預處理器？"></a>什麼是 CSS 預處理器？</h2><p>讓我們先來看傳統的 CSS 樣式表：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.menu</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.menu</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.menu</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.menu</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是都有過類似的經驗？有時候為了避免樣式汙染到全域環境，我們會藉由 CSS 的子對象選擇器來完成指定，但此時你會發現大部分的時間都耗費在了父對象的撰寫上，不覺得這樣很浪費時間嗎？如果能在不修改 CSS 選擇器達到樣式名稱不重複效果該有多好呢？讓我們來看下個例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#2e2ecf</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#2e2ecf</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#2e2ecf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這也是很常見的案例，在多個元素中套用了相同的樣式，假入我們今天要修改網站統一的樣式呢？我以前的做法是先選取 <code>#2e2ecf</code> 對象，之後 <code>Ctrl + D</code> 一路給他按下去，最後統一做修改，但這時會遇到的問題是，有些 <code>#2e2ecf</code> 對象我可不想做修改阿！如果不小心修改到，還得使用 <code>Ctrl + Z</code> 進行回復，想想就覺得麻煩，如果能像一般程式語言設置一個變數，之後只需要針對這個變數做修改，該有多好呢？讓我們來看下個例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-danger</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-warning</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有時為了符合 <a href="http://oocss.org/" target="_blank" rel="external nofollow noopener noreferrer">OOCSS</a> 的概念，我們會撰寫專門用於外觀的樣式，達到結構與樣式分離的效果，但單純用 CSS 來完成的話，真的是挺累人的，結構的名稱你都必須自己手打出來，如果能使用類似迴圈的語法將歸納在陣列的樣式給讀取出來，這該有多好呢？</p>
<p>經過了以上種種的問題，我們可以歸咎出一個結論，那就是 CSS 的撰寫方式實在是太單調了，單調對於初學者來說確實是好事，只需要記住幾個原則，即可快樂的進行開發，但相對的隨著你的程度提升，當你開發較有規模的專案時，就會顯得 CSS 綁手綁腳，永遠都只有那一套規則，缺少了程式語言那靈活的操作，此時 CSS 預處理器因此而誕生。</p>
<p>簡單來講，CSS 預處理器是一個須透過編譯器使之編譯成 CSS 的程式語言，有沒有發現到關鍵字？程式語言！CSS 預處理器就是一門程式語言，我們可以使用程式語言的特性來完成撰寫樣式表的目的，簡直完美，且最後編譯出來的檔案就是 CSS，也不存在所謂 Browser 不支援此語言的問題，</p>
<p>到這邊，你只需要對 CSS 預處理器有一個基本認知就是它是程式語言，這樣就好，讓我們繼續看下去。</p>
<h2 id="Sass-和-SCSS-有什麼區別？"><a href="#Sass-和-SCSS-有什麼區別？" class="headerlink" title="Sass 和 SCSS 有什麼區別？"></a>Sass 和 SCSS 有什麼區別？</h2><p>目前我們已經知道 CSS 預處理器是什麼東西了，但它總該有個對象名稱吧？沒錯，CSS 預處理器只是個統稱，目前常見的 Sass / SCSS、Less、Stylus 等，這些都是所謂的 CSS 預處理器，那這時你可能就會問了，我該選擇哪一個 CSS 預處理器？你可以反問你自己，你看過哪一個 CSS 預處理器？是不是只有 Sass / SCSS 這個選項？目前 Sass / SCSS 也是最紅的，比例非常的懸殊，我也推薦你直接學 Sass / SCSS，那這邊就又有一個問題了，Sass 與 SCSS 是一樣的東西嗎？感覺他們好像常常被混為一談？</p>
<p>Sass / SCSS 本質上是一樣的東西，差別在於其兩者語法結構的不同，讓我們直接來看範例：</p>
<ul>
<li>SCSS 語法結構：</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Sass 語法結構：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.list</span><br><span class="line">  display: flex</span><br></pre></td></tr></table></figure>

<p>SCSS 是較新的版本 (<code>Sassy CSS</code>、<code>Sass 3</code>、副檔名為 <code>*.scss</code>)，Sass 是較舊的版本 (如同 <code>HTML</code> 的 <code>Pug</code> 預處理器，具備不使用大括弧格式、使用縮排，副檔名為 <code>*.sass</code>)，如果你問我要選擇哪個，我會毫不猶豫推薦你 SCSS，原因很簡單，它的學習曲線相對較緩，從上面的範例可以看出，你甚至將原本的 <code>*.css</code> 檔案更改為 <code>*.scss</code> 也不會有任何問題，兩者的語法是一模一樣的，SCSS 就是在原本的 CSS 增加程式語言的基礎形成的預處理器，故之後的介紹都會是以 SCSS 為主。</p>
<p>目前我們已經了解何謂 CSS 預處理器，也了解 Sass 與 SCSS 的差別，這邊還有一個重點是，所有的 CSS 預處理器都得透過編譯器使之編譯成 CSS 才能供 HTML 引入，不然 Browser 是無法識別這個東西的，接下來我們就來建立預處理器的編譯環境吧！</p>
<h2 id="編譯環境建立-使用官方-sass-套件"><a href="#編譯環境建立-使用官方-sass-套件" class="headerlink" title="編譯環境建立 - 使用官方 sass 套件"></a>編譯環境建立 - 使用官方 sass 套件</h2><p>新增基本的專案環境：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── scss&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── all.scss</span><br><span class="line">│</span><br><span class="line">└─── index.html</span><br></pre></td></tr></table></figure>

<p>我們先來測試 SCSS 是否能正確被 HTML 識別：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"scss/all.scss"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此時會跳出：</p>
<p><img src="https://i.imgur.com/qeMvDOK.png" alt="HTML 無法解析 .scss 的文件"></p>
<p>如同我們之前所說，HTML 是無法解析 <code>*.scss</code> 文件的，任何的 CSS 預處理器都得透過編譯器使之編譯成 CSS 才能被正確解析，接著使用以下指令安裝官方的 Sass / SCSS 編譯器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install sass -g</span><br></pre></td></tr></table></figure>

<p>檢查是否成功安裝：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sass --version</span><br></pre></td></tr></table></figure>

<p>此篇文章並不會介紹 SCSS 的相關語法，這會等到之後再做專門的介紹，請先複製以下代碼至 <code>all.scss</code> 內：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$primary</span>: blue;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用以下指令編譯 <code>all.scss</code> 檔案：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sass .\scss\all.scss .\css\all.css</span><br></pre></td></tr></table></figure>

<p>上面這道指令指的是編譯 <code>.\scss\all.scss</code> 檔案到 <code>.\css\all.css</code> 內，不存在及建立，此時就會生成編譯好的 <code>all.css</code> 檔案：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> project/</span><br><span class="line"> │</span><br><span class="line"><span class="addition">+├─── css/</span></span><br><span class="line"><span class="addition">+│   │</span></span><br><span class="line"><span class="addition">+│   ├─── all.css</span></span><br><span class="line"><span class="addition">+│   └─── all.css.map</span></span><br><span class="line"> │</span><br><span class="line"> ├─── scss/</span><br><span class="line"> │   │</span><br><span class="line"> │   └─── all.scss</span><br><span class="line"> │</span><br><span class="line"> └─── index.html</span><br></pre></td></tr></table></figure>

<p><code>all.css</code> 的檔案內容為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>恭喜你已經完成編譯環境的建立了，就是這麼簡單，我們可在 <code>all.scss</code> 任意撰寫 SCSS 的內容，最後透過指令編譯成實體的 CSS 檔案，如果你嫌每次都要輸入指令太麻煩，可以傳遞 <code>--watch</code> 參數：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sass  --watch .\scss\all.scss .\css\all.css</span><br></pre></td></tr></table></figure>

<p>這樣它就會監聽指定的檔案，如有任何更動即自動編譯，達到自動化的目的。</p>
<p>預設的配置就會生成對應的 <code>.map</code> 檔，這個大家應該很熟悉了才對，你也可以開啟 <code>index.html</code> 檔案查看是否正確的映射原始的 SCSS 檔案。</p>
<p>關於官方套件的說明，差不多就到這邊，你可以自己去玩看看它每個參數的作用，基本上它的作用就只有將 Sass /SCSS 編譯成 CSS 而已。</p>
<h2 id="編譯環境建立-使用-VSCode-的-Live-Sass-Compiler-套件"><a href="#編譯環境建立-使用-VSCode-的-Live-Sass-Compiler-套件" class="headerlink" title="編譯環境建立 - 使用 VSCode 的 Live Sass Compiler 套件"></a>編譯環境建立 - 使用 VSCode 的 Live Sass Compiler 套件</h2><p>如果你跟我一樣，覺得單純的編譯 Sass / SCSS 還要另外下載 npm 的套件並透過命令行方式進行很麻煩，在這邊推薦你另一個方法，但這只限定於你的 IDE 是 Visual Studio Code，別的 IDE 可能也有類似套件，這點大家可以自行 Google 看看，以下示範如何使用 Live Sass Compiler 進行編譯。</p>
<p>安裝 Live Sass Compiler 延伸模組：</p>
<p><img src="https://i.imgur.com/Fx83gRG.png" alt="安裝 Live Sass Compiler"></p>
<p>檔案 &gt; 喜好設定 &gt; 設定 &gt; 開啟設定 (JSON)：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"liveSassCompile.settings.formats"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"format"</span>: <span class="string">"expanded"</span>,</span><br><span class="line">      <span class="attr">"extensionName"</span>: <span class="string">".css"</span>,</span><br><span class="line">      <span class="attr">"savePath"</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是此模組的預設配置，在這邊我們先不管它，直接進行編譯看看：</p>
<p><img src="https://i.imgur.com/REtKY29.png" alt="Watch Sass"></p>
<p>要啟用編譯很簡單，只需要點擊狀態列的 <code>Watch Sass</code> 或是 <code>F1</code> 搜尋 <code>Live Sass</code> 選擇 <code>Watch Sass</code> 也能達到同樣效果，編譯完成後會再 <code>*.scss</code> 的同層目錄生成相關的 CSS 檔案：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> project/</span><br><span class="line"> │</span><br><span class="line"> ├─── scss/</span><br><span class="line"> │   │</span><br><span class="line"><span class="addition">+│   ├─── all.css</span></span><br><span class="line"><span class="addition">+│   └─── all.css.map</span></span><br><span class="line"> │   └─── all.scss</span><br><span class="line"> │</span><br><span class="line"> └─── index.html</span><br></pre></td></tr></table></figure>

<p>預設的生成路徑就是在同層目錄下，這顯然不是我們要的結果，我們想要把它放置在獨立的 CSS 資料夾內，此時可以更改 <code>savePath</code> 這個選項：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"liveSassCompile.settings.formats"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"format"</span>: <span class="string">"expanded"</span>,</span><br><span class="line">      <span class="attr">"extensionName"</span>: <span class="string">".css"</span>,</span><br><span class="line">      <span class="attr">"savePath"</span>: <span class="string">"~/../css"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>savePath</code> 的選項中，有以下關鍵字可做使用：</p>
<ul>
<li><code>null</code>：在 <code>*.sass</code> / <code>*.scss</code> 同層的位置生成檔案</li>
<li><code>/</code>：相對於根目錄</li>
<li><code>~</code>：相對於每個 <code>*.sass</code> / <code>*.scss</code> 檔案的同層位置</li>
</ul>
<p>而我們上面這樣配置的意思是，在 <code>*.scss</code> 同層目錄的上層目錄名為 CSS 的資料夾生成檔案，這樣就可以達到預期的位置了，此時的編譯結果為：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> project/</span><br><span class="line"> │</span><br><span class="line"><span class="addition">+├─── css/</span></span><br><span class="line"><span class="addition">+│   │</span></span><br><span class="line"><span class="addition">+│   ├─── all.css</span></span><br><span class="line"><span class="addition">+│   └─── all.css.map</span></span><br><span class="line"> │</span><br><span class="line"> ├─── scss/</span><br><span class="line"> │   │</span><br><span class="line"> │   └─── all.scss</span><br><span class="line"> │</span><br><span class="line"> └─── index.html</span><br></pre></td></tr></table></figure>

<p>這邊我們補充介紹 <code>format</code> 與 <code>extensionName</code> 這兩個選項，修改為以下配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"liveSassCompile.settings.formats"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"format"</span>: <span class="string">"expanded"</span>,</span><br><span class="line">      <span class="attr">"extensionName"</span>: <span class="string">".css"</span>,</span><br><span class="line">      <span class="attr">"savePath"</span>: <span class="string">"~/../css"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"format"</span>: <span class="string">"compressed"</span>,</span><br><span class="line">      <span class="attr">"extensionName"</span>: <span class="string">".min.css"</span>,</span><br><span class="line">      <span class="attr">"savePath"</span>: <span class="string">"~/../css"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>format</code> 代表的是輸出的格式 (樣式)，以下模式可做使用：</p>
<ul>
<li><code>expanded</code>：預設模式，即不做任何壓縮處理</li>
<li><code>nested</code>：類似 <code>expanded</code> 模式，但會處理縮排</li>
<li><code>compressed</code>：最小化處理，即常見的程式碼壓縮</li>
<li><code>compact</code>：類似 <code>compressed</code> 模式，但不處理空白字元</li>
</ul>
<p><code>extensionName</code> 代表的是附檔名的名稱，通常都會設為 <code>.css</code> 或 <code>.min.css</code>。每一個物件即代表生成一個檔案，上面的配置會生成兩個檔案，分別為 <code>expanded</code> 模式的 <code>*.css</code> 檔案，與 <code>compressed</code> 模式的 <code>*.min.css</code> 檔案：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> project/</span><br><span class="line"> │</span><br><span class="line"><span class="addition">+├─── css/</span></span><br><span class="line"><span class="addition">+│   │</span></span><br><span class="line"><span class="addition">+│   ├─── all.css</span></span><br><span class="line"><span class="addition">+│   ├─── all.css.map</span></span><br><span class="line"><span class="addition">+│   ├─── all.min.css</span></span><br><span class="line"><span class="addition">+│   └─── all.min.css.map</span></span><br><span class="line"> │</span><br><span class="line"> ├─── scss/</span><br><span class="line"> │   │</span><br><span class="line"> │   └─── all.scss</span><br><span class="line"> │</span><br><span class="line"> └─── index.html</span><br></pre></td></tr></table></figure>

<p>是不是挺方便的？如果你有嘗試去觀察編譯的結果，你會發現它連同 Prefix 也幫我們加入了：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">display</span>: -ms-flexbox;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就如同 PostCSS 使用 Autoprefixer 一般，以往我們都是使用 <code>.browserslist</code> 或 <code>&quot;browserslist&quot;</code> 去配置想要的版本，這邊一樣也可以，只不過得換在 <code>autoprefix</code> 做配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"liveSassCompile.settings.autoprefix"</span>: [<span class="string">"last 1 version"</span>, <span class="string">"&gt; 1%"</span>, <span class="string">"IE 10"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Live Sass Compiler 的配置差不多就這樣，還有其他比較冷門的配置，你可以到它的 <a href="https://github.com/ritwickdey/vscode-live-sass-compiler/blob/master/docs/settings.md" target="_blank" rel="external nofollow noopener noreferrer">文檔</a> 去做查看。</p>
<h2 id="編譯環境建立-使用-gulp-sass-套件"><a href="#編譯環境建立-使用-gulp-sass-套件" class="headerlink" title="編譯環境建立 - 使用 gulp-sass 套件"></a>編譯環境建立 - 使用 gulp-sass 套件</h2><p>由於篇幅較長，可至相關文章進行閱讀：</p>
<ul>
<li><a href="https://awdr74100.github.io/2019-12-31-gulp-gulpsass/">Gulp 前端自動化 - 編譯 Sass/SCSS</a></li>
</ul>
<h2 id="編譯環境建立-使用-sass-loader-套件"><a href="#編譯環境建立-使用-sass-loader-套件" class="headerlink" title="編譯環境建立 - 使用 sass-loader 套件"></a>編譯環境建立 - 使用 sass-loader 套件</h2><p>由於篇幅較長，可至相關文章進行閱讀：</p>
<ul>
<li><a href="https://awdr74100.github.io/2020-03-04-webpack-sassloader/">Webpack 前端打包工具 - 使用 sass-loader 編譯 Sass/SCSS 預處理器</a></li>
</ul>
]]></content>
      <categories>
        <category>SCSS</category>
      </categories>
      <tags>
        <tag>SCSS</tag>
        <tag>w3HexSchool</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Sass / SCSS 預處理器 - Nesting 巢狀結構與 Parent 父選擇器</title>
    <url>/2020-05-21-scss-nesting/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一次我們已經將 SCSS 的編譯環境給建立好了，接下來讓我們正式進入到語法的章節，首先介紹的是 nesting 巢狀結構與父選擇器，巢狀結構是 Sass / SCSS 最具特色的功能之一，之前我們有提到傳統 CSS 可能會發生父對象重複撰寫的問題，為了避免汙染到其他樣式，我們必須明確地寫出父子對象的關係，搞到最後才發現浪費了許多時間，如果改使用 Sass / SCSS 中的巢狀結構語法並搭配父選擇器，不僅可解決此類問題，同時也能改善傳統樣式表可讀性低落的問題。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>巢狀結構</li>
<li>巢狀屬性</li>
<li>父選擇器</li>
</ul>
<h2 id="巢狀結構"><a href="#巢狀結構" class="headerlink" title="巢狀結構"></a>巢狀結構</h2><p>讓我們先來回顧一下先前提到的問題：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你不覺得這樣子很累嗎？不寫父元素又怕會汙染到其他樣式，且也不符合近年來推崇的 <strong>DRY (Don’t Repeat Your CSS)</strong> 與 <strong>KISS (Keep It Simple Stupid)</strong> 原則，何不我們嘗試使用 SCSS 來撰寫？改寫如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: black;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: white;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是很酷？最後的結果與之前相同，但可讀性提高了不少，我們可以很明確的知道元素之間的依賴關係，日後如果更換了父元素的名稱，也不需要 <code>Ctrl + D</code> 累得半死做修改，直接更改父元素的名稱，之後再重新編譯一次即可，讓我們在試一次：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line"></span><br><span class="line">  &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>撰寫的關鍵就在於元素之間是否存有依賴關係，如果有，即把子樣式撰寫在父樣式內，就等同於子對象選擇器的撰寫目的，包含全部的 CSS 選擇器，都可以去做使用，<strong>你不用把它想得太複雜，就只是把子對象改成巢狀結構而已</strong>，這邊在做個補充，假設 <code>a</code> 元素內還有 <code>span</code> 元素的樣式：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line"></span><br><span class="line">  &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: red;</span><br><span class="line"></span><br><span class="line">      <span class="selector-tag">span</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">a</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這邊就存在一個問題了，那就是階層數可能有點太多了，存在可讀性降低、可維護性降低、渲染效率變差等問題，並不是說 3 層結構就是極限，嚴格來講應該是盡量能避免階層數過多就避免，我們可針對上面做改寫：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line"></span><br><span class="line">  &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">span</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這樣的寫法也可以達到同樣的選染效果，前提是 <code>a</code> 元素的同層元素中並沒有 <code>span</code> 元素，在每次撰寫樣式時，盡量去思考撰寫對象真的存在必要的依賴關係嗎，避免樣式表存在不必要的需優化及效能問題。</p>
<h2 id="巢狀屬性"><a href="#巢狀屬性" class="headerlink" title="巢狀屬性"></a>巢狀屬性</h2><p>在上面我們都是針對 CSS 選擇器做巢狀結構，這邊再補充一點，假如我們正在撰寫關於 <code>background</code> 或 <code>font</code> 的樣式：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bg-cover</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">'..'</span>);</span><br><span class="line">  <span class="attribute">background-position</span>: center center;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.font-weight-bold</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">font-family</span>: Arial, Helvetica, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這樣寫確實挺正常的，但假設你是個極度追求效率的人，懶得寫這麼多的重複字樣，可以改寫如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bg-cover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: &#123;</span><br><span class="line">    image: url(<span class="string">'..'</span>);</span><br><span class="line">    <span class="attribute">position</span>: center center;</span><br><span class="line">    repeat: no-repeat;</span><br><span class="line">    size: cover;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.font-weight-bold</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: &#123;</span><br><span class="line">    size: <span class="number">1em</span>;</span><br><span class="line">    weight: bold;</span><br><span class="line">    family: Arial, Helvetica, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bg-cover</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'..'</span>);</span><br><span class="line">  <span class="attribute">background-position</span>: center center;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.font-weight-bold</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">font-family</span>: Arial, Helvetica, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是很酷？我們就只需要寫一次 <code>background</code> 或 <code>font</code> 等字樣，後面在撰寫其相關屬性即可，這邊要記得加入冒號，以告知編譯器此為子屬性並不是子對象。</p>
<p>雖然說這樣看似的確更方便了，但我一般不太會這樣寫，巢狀結構確實有其存在的必要，提高了其撰寫樣式表的效率，但巢狀屬性就見仁見智了，我認為可能會發生可閱讀性降低的問題，我自己是不太習慣，各位可以自己評估看看。</p>
<h2 id="父選擇器"><a href="#父選擇器" class="headerlink" title="父選擇器"></a>父選擇器</h2><p>最後我們針對巢狀結構在做個補充，前面已經提到巢狀結構所帶來的好處了，主要解決父對象名稱大量重複的問題，但在某些情況下似乎還是無可避免，如下範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line"></span><br><span class="line">  &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">a</span>:hover &#123;</span><br><span class="line">      <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>發現問題了嗎？<code>a</code> 元素還是發生名稱重複的問題了，你可能會想，這一個 <code>:hover</code> 偽類為何不寫在 <code>a</code> 元素的下個階層呢？這樣即會導致 <code>:hover</code> 被當成子對象編譯，形成 <code>a :hover</code> 的無意義宣告，我們要的是 <code>a:hover</code> 的結果阿！此時我們就可使用 Sass / SCSS 名為父選擇器的 <code>&amp;</code> 符號解決此問題，如下範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line"></span><br><span class="line">  &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: red;</span><br><span class="line"></span><br><span class="line">      &amp;:hover &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&amp;</code> 符號可把父對象連接在一起，類似字串相加的概念，被連接的對象編譯的階層就會與父對象同層，此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大功告成！看起來代碼的簡潔性又提升了不少，讓我們在試一次：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line"></span><br><span class="line">  &amp;__item &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line"></span><br><span class="line">    &amp;--active &#123;</span><br><span class="line">      <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這是一個基本的 <a href="http://getbem.com/" target="_blank" rel="external nofollow noopener noreferrer">BEM</a> 結構，這邊先不用理解 BEM 是什麼，之後會有單獨的文章做介紹，此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list__item</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list__item--active</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由於 <code>&amp;__item</code> 與 <code>&amp;--active</code> 都使用了父選擇器，故最後的編譯結果就都與 <code>.list</code> 同階層，這應該蠻好理解的，在實務中，我也很常使用此技法來撰寫樣式，可有效提升其閱讀性，這邊要注意，前面都是將 <code>&amp;</code> 放置在 CSS 選擇器之前，你也可以把它放在 CSS 選擇器之後：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.menu</span> &#123;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">0px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.open</span> &amp; &#123;</span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">300px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.menu</span> &#123;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.open</span> <span class="selector-class">.menu</span> &#123;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是覺得很熟悉？這不就是 hamburger menu 的手法嗎？以往我們都得在額外區塊撰寫樣式，現在利用 <code>&amp;</code> 即可輕鬆完成任務，且很明顯的可以看出兩者是有其關聯性的，並不像之前散落在各自的區塊上。</p>
]]></content>
      <categories>
        <category>SCSS</category>
      </categories>
      <tags>
        <tag>SCSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Sass / SCSS 預處理器 - Variables 變數宣告與 !global、!default 標誌定義</title>
    <url>/2020-05-25-scss-variables/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先前我們就有提到 Sass / SCSS 真正意義上的將樣式表變為了一門程式語言，即 SassScript，而身為程式語言，想當然就會有所謂的變數可以使用，這也是我跳坑的其中一個原因，你能想像樣式表居然能夠使用變數做撰寫嗎？這指的變數與其他語言差不多，同樣有分為字串、陣列、物件等型態可做使用，大幅提高了代碼的重用性，以後如有更改的需求，也只需針對變數做處理即可，改善傳統樣式表不易維護問題。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>變數的宣告與取用</li>
<li>!global、!default 標誌定義</li>
<li>Sass 的計算功能</li>
<li>Sass 的內建函式</li>
</ul>
<h2 id="變數的宣告與取用"><a href="#變數的宣告與取用" class="headerlink" title="變數的宣告與取用"></a>變數的宣告與取用</h2><p>Sass / SCSS 變數的宣告主要依靠 <code>$</code> 關鍵字，並且依造屬性聲明來做撰寫，其中的資料型態有：</p>
<ul>
<li>數值 (Number)：<code>12</code>、<code>100px</code> (可能有或沒有單位)</li>
<li>字串 (String)：<code>Microsoft JhengHei</code> (可能有或沒有引號)</li>
<li>顏色 (Color)：<code>blue</code>、<code>#4cb5fc</code>、<code>hsl(204, 97%, 64%)</code></li>
<li>列表 (List)：<code>0 0.5rem 1rem #0000ff</code>、<code>Helvetica, Arial, sans-serif</code></li>
<li>地圖 (Maps)：<code>(primary: blue, danger: red)</code></li>
<li>布林 (Boolean)：<code>true</code>、<code>false</code></li>
<li>空值 (Null)：<code>null</code></li>
<li>函式參考 (Function references)：可參考 <a href="https://sass-lang.com/documentation/values" target="_blank" rel="external nofollow noopener noreferrer">官方文檔</a> 說明</li>
</ul>
<p>這邊比較特別就是 Maps 這個資料型態，其實它就類似 JavaScript 中的 Object，只不過將其 <code>{}</code> 換成 <code>()</code> 而已，下面會再做示範，讓我們先來看以下範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$primary</span>: <span class="number">#2050ec</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有關變數的取用應該是蠻好理解的，就只是將其宣告在上方並在指定位置進行取用而已，這邊要注意的是，<strong>SCSS 中的變數就如同 JavaScript 用 let 宣告的變數</strong>，這也代表著變數必定要在取用之前進行宣告，不然會跳出 <code>Undefined</code> 的錯誤，此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#2050ec</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>數值、字串、顏色取用過程幾乎差不多，這邊就不再做示範，比較有疑問的可能是 List 這型態，其實它就類似一般所謂的 Array，如下範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sizes</span>: <span class="number">10px</span> <span class="number">20px</span> <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.p-5</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="variable">$sizes</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>List 是在 SCSS 中用來表達 CSS 樣式的方法，像是 <code>10px 20px 10px 20px</code> 或 <code>Helvetica, Arial</code> 等，並不一定要像一般 Array 需用逗號隔開以辨識每一個項目，在 List 你也可以使用空格做區隔，如果要取用其中的項目，可使用內建的 <code>nth</code> 函式：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sizes</span>: <span class="number">10px</span> <span class="number">20px</span> <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.pt-5</span> &#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: nth(<span class="variable">$sizes</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.pt-5</span> &#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>List 的初始值即為 1，並不像一般語言中的 Array 初始值為 0</p>
<p><code>nth</code> 函式的第一個參數為作用的 List，第二個為取用的位置，這邊比較特殊的是，<strong>List 的初始值即為 1，並不像一般語言中的 Array 為 0</strong>，以及所有的函式都是作用在 List 的副本，這代表原有的 List 不會受任何更動，除了 <code>nth</code> 之外，還有以下函式可使用：</p>
<ul>
<li><code>set-nth($list, $n, $value)</code>：修改 List 副本的指定項目並返回</li>
<li><code>append($list, $value)</code>：在 List 副本最後位置新增項目並返回</li>
<li><code>join($list1, $list2)</code>：將 List 副本進行合併並返回</li>
<li><code>length($list)</code>：計算 List 長度並返回</li>
</ul>
<p>這邊只列出幾個比較常用到的函式，其它函式可在至官方的 <a href="https://sass-lang.com/documentation/modules/list" target="_blank" rel="external nofollow noopener noreferrer">Built-In Modules</a> 文檔進行查看，接著讓我們來看 Maps 型態：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$theme-colors</span>: (</span><br><span class="line">  primary: blue,</span><br><span class="line">  danger: red,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bg-primary</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="variable">$theme-colors</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Maps 就如同 JavaScript 的 Object，只不過須將其 <code>{}</code> 更改為 <code>()</code>，且 Maps 無法直接進行取用，像是上面這樣子的寫法就是錯誤的，沒有任何一個 CSS 屬性有這樣子的格式，故編譯時即會跳錯，如果你想讓編譯器堅持輸出 Maps 的內容，可使用 <code>inspect</code> 函式：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$theme-colors</span>: (</span><br><span class="line">  primary: blue,</span><br><span class="line">  danger: red,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bg-primary</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: inspect(<span class="variable">$theme-colors</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>inspect</code> 就類似 JavaScript 中的 <code>console.log</code>，主要都是用於輸出指定的對象，方便我們測試用，此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bg-primary</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: (primary: blue, danger: red);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如同我們前面所說，沒有半個 CSS 屬性格式是長這樣，正確的做法應該是讀取其鍵以取用其值才對，此時可使用 <code>map-get</code> 函式：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$theme-colors</span>: (</span><br><span class="line">  primary: blue,</span><br><span class="line">  danger: red,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bg-primary</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: map-get(<span class="variable">$theme-colors</span>, primary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>map-get</code> 主要用來取用 Maps 的內容，第一個參數為作用的 Maps，第二個參數為須取用值的鍵，此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bg-primary</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這樣就能完成像是一般語言取用物件的目的，除了 <code>map-get</code> 之外，還有以下函式可使用：</p>
<ul>
<li><code>map-merge($map1, $map2)</code>：將 map 副本進行合併並返回 (如有重複項，後者將覆蓋前者)</li>
<li><code>map-remove($map, $key1, $key2...)</code>：刪除 map 副本中的指定項目並返回</li>
<li><code>map-keys($map)</code>：將 map 中的鍵以 List 型式返回</li>
<li><code>map-values($map)</code>：將 map 中的值以 List 型式返回</li>
</ul>
<p>這時你可能會想，List 與 Maps 實用性看起來好像不高？光是取個值就得大費周章，那是因為我們還沒提到迴圈的使用，這兩個型別通常都是與迴圈共同使用才能發揮其強大，在下一篇文章會有詳細的介紹，這邊先寫個簡單的範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$theme-colors</span>: (</span><br><span class="line">  primary: blue,</span><br><span class="line">  danger: red,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$theme-colors</span> &#123;</span><br><span class="line">  <span class="selector-class">.text-</span>#&#123;<span class="variable">$key</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-danger</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="global、-default-標誌定義"><a href="#global、-default-標誌定義" class="headerlink" title="!global、!default 標誌定義"></a>!global、!default 標誌定義</h2><p>SCSS 的變數與一般語言的變數同樣都有作用範圍之分，直接來看範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$primary</span>: blue;</span><br><span class="line"><span class="variable">$primary</span>: red;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我們有提到 SCSS 的變數就如同 JavaScript 用 <code>let</code> 宣告的變數，與 <code>const</code> 宣告的常數不同，<code>let</code> 宣告的變數可以被重新賦值，此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重複的變數宣告就如同重新賦值，這才導致此結果，只要記住 SCSS 是由上到下進行編譯就很好理解了，讓我們來看下個範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$primary</span>: blue;</span><br><span class="line"><span class="variable">$primary</span>: red !default;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這次我們加入了 <code>!default</code> 標誌，此標誌可針對變數設定預設值，如變數前或後都沒有重新賦值的發生，即使用此預設值，此時的編譯結果為：</p>
<div class="note warning">補充：除非變數前的設定值為 null，不然預設值的權重必定是最小的，任何都能將其覆蓋</div>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由於 <code>$primary</code> 發生了重新賦值的操作，故使用預設值除外的設定值，如果同時發生預設值之前之後都有設定值，此時會使用之後的設定值，因為 SCSS 是由上到下進行編譯的，讓我們來看下個範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="variable">$primary</span>: red;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bg-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>變數不只可以宣告在全域環境 (不在任何大括號內宣告之變數)，也可以宣告在區域環境 (大括號內所宣告之變數)，以上面範例來說，<code>.bg-primary</code> 是存取不到 <code>$primary</code> 這個區域變數的，此時會跳 <code>Undefined</code> 的提示，如果堅持要存取這個變數，可使用 <code>!global</code> 標誌：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="variable">$primary</span>: red !global;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bg-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時 <code>$primary</code> 變數就會被拉升到全域環境內，意即不再任何大括號宣告之變數，<code>.bg-primary</code> 自然就能夠取用這個變數，這邊再補充一個範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="variable">$primary</span>: red;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary</span>;</span><br><span class="line"></span><br><span class="line">  &amp;__item &#123;</span><br><span class="line">    <span class="variable">$primary</span>: blue !global;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$primary</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如同 JavaScript 的作用域觀念，變數取用會先以當下區域進行尋找，如果找不到再往上層尋找，以上面的範例來說，<code>list__item</code> 宣告的 <code>$primary</code> 變數被拉升到了全域環境裡，表示區域已經不存在變數，故往上層尋找是否存在此變數，此時找到了值為 <code>red</code> 的 <code>$primary</code> 變數，最後的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list__item</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Sass-的計算功能"><a href="#Sass-的計算功能" class="headerlink" title="Sass 的計算功能"></a>Sass 的計算功能</h2><p>傳統的 CSS 需要依靠其 <code>calc()</code> 函式才能完成數值加減乘除的目的，在 Sass / SCSS 中，一切似乎變得更容易了，讓我們直接來看範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$gutter-width</span>: <span class="number">30px</span>;</span><br><span class="line"><span class="variable">$grid-sum</span>: <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-4</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span> * (<span class="number">4</span> / <span class="variable">$grid-sum</span>);</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> (<span class="number">100%</span> * (<span class="number">4</span> / <span class="variable">$grid-sum</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如同我們之前所強調，Sass / SCSS 讓 CSS 真正意義上的成為了一門程式語言，而程式語言理所當然就會有數值計算的功能，不管是哪種運算方式都難不倒它，你不需要特別使用函式，如同一般語言撰寫其算式即可，此時的編譯結果為：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.col-4</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">33.33333%</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">33.33333%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了基本的加減乘除外，取餘數也難不倒它，最扯的是連顏色都可以計算：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$base</span>: <span class="number">16px</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">letter-spacing</span>: <span class="variable">$base</span> % <span class="number">6</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ff0000</span> + <span class="number">#002fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">letter-spacing</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ff2fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般的程式語言數值並不會像 SCSS 有 <code>px</code>、<code>em</code>、<code>%</code> 之分，此時如果進行運算，可能就會跳出錯誤：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span> - <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像這樣不同單位間的計算就會跳出 <code>Incompatible units</code> 的提示，導致編譯失敗，Sass / SCSS 是屬於 CSS 的預處理器，它無法像 <code>calc()</code> 函式作用在 Browser 可得知當下的數值並加以計算，盡量在撰寫時都是以同單位做計算，<code>px</code> 就對 <code>px</code>，<code>em</code> 就對 <code>em</code>，如果真的有不同單位間的計算需求，就使用 CSS3 的 <code>calc()</code> 函式：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: calc(<span class="number">100%</span> - <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>並沒有說使用 Sass / SCSS 就無法撰寫 CSS 的函式，畢竟底層就是 CSS，也就不存在兼容的問題，這邊再做個非常重要的補充：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$base</span>: <span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: calc(<span class="variable">$base</span> - <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能會想，這不就是個基本的變數取用嗎？還需要特別介紹？這你就錯了，讓我們先來看編譯結果：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="built_in">calc</span>($base - 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>雖然編譯是成功了，但其變數並沒有成功被解析出來，此時就會導致 CSS 無法辨認其值進而產生錯誤的問題，這也是我特別要提的點，<strong>在某些情況下，SCSS 無法辨認其值是屬於需解析的變數還是預設的屬性值</strong>，這是很麻煩的一件事，但其實不用太過擔心，這問題發生的機率非常低，通常都是在某些較為特殊的情況下才會發生，解決方式也很簡單，只需利用 SCSS 提供的 <a href="https://sass-lang.com/documentation/interpolation" target="_blank" rel="external nofollow noopener noreferrer">Interpolation</a> 方法：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$base</span>: <span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: calc(#&#123;<span class="variable">$base</span>&#125; - <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>#{}</code> 將變數給帶入，用以告知編譯器此段需進行編譯，此時的結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="built_in">calc</span>(100% - 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最後的編譯結果就會如同預期，這時你可能會問，那是否所有屬性有帶入變數的地方都使用 <code>#{}</code> 比較安全？答案是否定的，這樣會顯得代碼很雜亂，有需要再使用就好了，畢竟此問題發生的機率真的非常低。</p>
<h2 id="Sass-的內建函式"><a href="#Sass-的內建函式" class="headerlink" title="Sass 的內建函式"></a>Sass 的內建函式</h2><p>Sass 提供了許多內建函式，這些函式可以更快速的讓我們達到某些目的，其中包含的種類有：</p>
<ul>
<li><a href="https://sass-lang.com/documentation/modules/math" target="_blank" rel="external nofollow noopener noreferrer">sass:math</a>：提供對數值進行運算的功能</li>
<li><a href="https://sass-lang.com/documentation/modules/string" target="_blank" rel="external nofollow noopener noreferrer">sass:string</a>：使組合、搜索或拆分變的更加容易</li>
<li><a href="https://sass-lang.com/documentation/modules/color" target="_blank" rel="external nofollow noopener noreferrer">sass:color</a>：根據現有顏色生成新顏色，從而輕鬆構建主題顏色</li>
<li><a href="https://sass-lang.com/documentation/modules/list" target="_blank" rel="external nofollow noopener noreferrer">sass:list</a>：使你可以訪問和修改列表中的值</li>
<li><a href="https://sass-lang.com/documentation/modules/map" target="_blank" rel="external nofollow noopener noreferrer">sass:map</a>：可以查找、編輯地圖中指定鍵匹配的值</li>
<li><a href="https://sass-lang.com/documentation/modules/selector" target="_blank" rel="external nofollow noopener noreferrer">sass:selector</a>：提供對 Sass 強大選擇器引擎的訪問</li>
<li><a href="https://sass-lang.com/documentation/modules/meta" target="_blank" rel="external nofollow noopener noreferrer">sass:meta</a>：公開了 Sass 內部工作的細節</li>
</ul>
<p>像是之前介紹的 <code>nth</code>、<code>append</code> 這些就屬於 list 的內建函式，這邊補充關於顏色的內建函式：</p>
<ul>
<li><code>darken($color, $amount)</code>：暗化指定顏色並返回</li>
<li><code>lighten($color, $amount)</code>：亮化指定顏色並返回</li>
<li><code>invert($color)</code>：反轉指定顏色並返回</li>
<li><code>fade-in($color, $amount)</code>：使指定顏色更加不透明並返回 (限 0 到 1 的 Alpha 值)</li>
<li><code>fade_out($color, $amount)</code>：使指定顏色更加透明並返回 (限 0 到 1 的 Alpha 值)</li>
</ul>
<p>以下為範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$primary</span>: <span class="number">#0084ff</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="variable">$primary</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="variable">$primary</span>;</span><br><span class="line"></span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: darken(<span class="variable">$primary</span>, <span class="number">10%</span>);</span><br><span class="line">    <span class="attribute">border-color</span>: darken(<span class="variable">$primary</span>, <span class="number">10%</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &amp;:active &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: lighten(<span class="variable">$primary</span>, <span class="number">10%</span>);</span><br><span class="line">    <span class="attribute">border</span>: lighten(<span class="variable">$primary</span>, <span class="number">10%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.btn-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#0084ff</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#0084ff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn-primary</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#006acc</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#006acc</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn-primary</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#339dff</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">#339dff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是挺方便的？我們就不需要自己慢慢的調整，通通透過內建函式即可自動判斷其目標的顏色，相關的函式還有很多，由於篇幅問題，這邊就不做一一介紹，相關連結可參考上面。</p>
]]></content>
      <categories>
        <category>SCSS</category>
      </categories>
      <tags>
        <tag>SCSS</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>Sass / SCSS 預處理器 - @if、@else if 條件判斷與 @for、@each 迴圈處理</title>
    <url>/2020-05-26-scss-conditions-loops/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>雖然說撰寫樣式表其複雜性遠遠低於一般的主流程式語言，但無法否認在某些時候我們確實需要更高效的做法來達到目的，迴圈處理就是個很好的例子，傳統 CSS 撰寫樣式必定是透過手動輸入的方式來完成，而 Sass / SCSS 提供了像是 @for、@each、@while 語句，讓我們透過迴圈的方式快速產出樣式，藉此達到高效開發的目的，其中也包含像是 @if、@else if 等條件判斷式，可根據其判斷輸出不同的樣式，讓我們在較複雜的情境依然能夠保持其樣式表的靈活度。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>條件判斷式與邏輯運算子</li>
<li>迴圈處理與實際應用</li>
</ul>
<h2 id="條件判斷式與邏輯運算子"><a href="#條件判斷式與邏輯運算子" class="headerlink" title="條件判斷式與邏輯運算子"></a>條件判斷式與邏輯運算子</h2><p>像是 <code>if</code>、<code>else if</code> 這種條件判斷式有接觸過任一程式語言的人應該都很熟悉了才對，能夠幫助我們依造判斷的結果選用不同的內容，讓我們直接來看範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$device</span>: mobile;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$device</span> == desktop &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.5rem</span>;</span><br><span class="line">  &#125; @<span class="keyword">else</span> if <span class="variable">$device</span> == pad &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.25rem</span>;</span><br><span class="line">  &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1rem</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就如同一般程式語言的條件判斷式寫法，這應該蠻好理解的，但這邊要注意 SCSS 並未提供像是 <code>switch</code> 等語句，僅提供以下條件判斷式語句：</p>
<ul>
<li><code>@if</code>：如果為 <code>true</code>，則該塊被運行</li>
<li><code>@else</code>：跟隨 <code>@if</code> 規則，如果為 <code>false</code>，則該塊被運行</li>
<li><code>@else if</code>：在 <code>@else</code> 評估其規則，運作如同 <code>@if</code></li>
</ul>
<p>與 Python 類似，僅提供以上三種判斷式語句，且比對的方法也幾乎差不多，如果你是 JavaScript 的開發者，應該很常使用像是 <code>===</code> 進行比對，在 SCSS 你不必這樣做，也不能這樣做，只需要撰寫傳統的 <code>==</code>、<code>!=</code>、<code>&gt;=</code> 比較其目標即可，這邊針對邏輯運算子做個補充：</p>
<ul>
<li><code>and</code>：兩個運算式都是 <code>true</code> 時才會回傳 <code>true</code></li>
<li><code>or</code>：兩個運算式有任一個是 <code>true</code> 時就會回傳 <code>true</code></li>
<li><code>not</code> 反轉運算式結果</li>
</ul>
<p>一樣與 Python 類似，其邏輯判斷子都變得更為直接，這邊我們再來看個範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$primary</span>: rgb(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  @<span class="keyword">if</span> (<span class="variable">$primary</span> == black and <span class="variable">$primary</span> == <span class="number">#000000</span>) &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$primary</span>;</span><br><span class="line">  &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般對於這種邏輯運算子不外乎就是比較字串或數值之間的關係，在 SCSS 定義了像是 <code>#000000</code> 顏色的型態，我們可透過相同方式比較顏色之間的關係，當初看到也覺得很新奇，居然連顏色也可以比較，雖然使用頻率可能未必來的比基本型態高，但確實在某些時候可能能夠帶來關鍵性的作用。</p>
<h2 id="迴圈處理與實際應用"><a href="#迴圈處理與實際應用" class="headerlink" title="迴圈處理與實際應用"></a>迴圈處理與實際應用</h2><p>接下來進入到迴圈處理的環節，在這邊要先強調，SCSS 並未像一般程式語言需處理各種複雜的情境，為了方便開發者的處理流程，進而衍伸出像是 JavaScript 中的 <code>for in</code>、<code>for of</code> 等方法，這些東西在 SCSS 都不存在，SCSS 就只有提供像 <code>@for</code>、<code>@each</code>、<code>@while</code> 等基本迴圈處理方法，畢竟需求很單純，這點在下面會在做說明，讓我們先從 <code>@for</code> 開始介紹：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">for</span> <span class="variable">$var</span> from 1 to 3 &#123;</span><br><span class="line">  <span class="selector-class">.mt-</span>#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="variable">$var</span> * <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這邊的 <code>$var</code> 就類似於 JavaScript 中用 <code>let</code> 宣告的變數，區塊外是讀不到這個變數的，其他字詞的解釋如下：</p>
<ul>
<li><code>start</code>：迴圈的起始值，這裡為 <code>1</code></li>
<li><code>end</code>：迴圈的結束值，這裡為 <code>3</code></li>
<li><code>to</code>：處理方式為 <code>start &lt; end</code>，不包含迴圈的結束值</li>
<li><code>through</code>：處理方式為 <code>start &lt;= end</code>，包含迴圈的結束值</li>
</ul>
<p>如同上面解釋，使用 <code>to</code> 的話迴圈只會跑兩次，我們想要跑三次，故這邊使用 <code>through</code> 來進行：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">for</span> <span class="variable">$var</span> from 1 through 3 &#123;</span><br><span class="line">  <span class="selector-class">.mt-</span>#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="variable">$var</span> * <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這邊還有一點要注意，在之前我們有提到在某些時候 SCSS 無法辨認其值是屬於需解析的變數還是預設的屬性值，其中的屬性值也有可能是字串，以上面範例來說，當我們把 <code>$var</code> 寫在 class 名稱時，就會產生此問題，解決辦法如之前，使用 <code>#{}</code> 將變數包裝起來即可，讓我們來看最後的編譯結果：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.mt-1</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.mt-2</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.mt-3</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用迴圈處理，我們就能快速產生需要的樣式，這樣子的結果就如同 Bootstrap 中的 Spacing 處理一般，大幅提高了其開發效率，讓我們在試一次：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$list</span>: red blue black;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">for</span> <span class="variable">$var</span> from 1 through length(<span class="variable">$list</span>) &#123;</span><br><span class="line">  <span class="selector-class">.text-</span>#&#123;nth(<span class="variable">$list</span>,<span class="variable">$var</span>)&#125; &#123;</span><br><span class="line">    <span class="attribute">color</span>: nth(<span class="variable">$list</span>, <span class="variable">$var</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這也是我們在撰寫一般程式語言最常用到的迴圈處理，利用迴圈產生數值進而取出陣列中的值，但在這邊我不太推薦以 <code>@for</code> 下去做，從編譯結果就可以得知：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-red</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-blue</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-black</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般我們不會取作像 <code>.text-blue</code> 這樣的 class 名稱，如果其樣式顏色做了更改，這會導致名稱與內容不相符的狀況，搞的很詭異，盡量都是以工具性質去做命名，不要以語意化方式命名，這時就是 <code>maps</code> 出場的時候了：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$theme-colors</span>: (</span><br><span class="line">  primary: <span class="number">#0000ff</span>,</span><br><span class="line">  success: <span class="number">#008000</span>,</span><br><span class="line">  warning: <span class="number">#ffff00</span>,</span><br><span class="line">  danger: <span class="number">#ff0000</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>maps</code> 型態就如同一般語言的 Object，關於 <code>maps</code> 的介紹可參考上一篇文章，一般語言如果要遍歷 Object 可使用 <code>for in</code> 語句，但 SCSS 並沒有 <code>for in</code> 語句，取而代之的是 <code>@each</code> 語句，如下範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$theme-colors</span> &#123;</span><br><span class="line">  <span class="selector-class">.text-</span>#&#123;<span class="variable">$key</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這邊的 <code>@each</code> 就類似於 Python 的 <code>for in</code> 語句，我個人是把它記成 JavaScript 中 <code>for of</code> 結合 <code>Object.entries()</code> 並搭配解構的處理方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// primary</span></span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 0000ff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果將被賦值的兩個變數更改為一個，此時這一個變數拿到的就是單獨的 List 物件，你可以從 JavaScript 解構的方向去思考，更可以直接拿掉 <code>$value</code> 變數，直接讀取 <code>$key</code> 變數看看，這個變數就會得到 <code>iterator</code> 的結果，讓我們來看最後的編譯結果為何：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0000ff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-success</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#008000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-warning</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ffff00</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-danger</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有沒有似曾相似的感覺？沒錯，Bootstrap 中的主題顏色就是依靠此方式生成的，可以參考 <a href="https://github.com/twbs/bootstrap/blob/master/scss/_variables.scss" target="_blank" rel="external nofollow noopener noreferrer">官方文檔</a>，其中也包含像 <code>.bg-primary</code>、<code>btn-primary</code> 等樣式，原理都是一模一樣的，相比於傳統 CSS 依靠手動方式撰寫樣式，使用 SCSS 能夠快速並符合結構化方式自動生成樣式，這也是為什麼 SCSS 越來越火紅的原因，這個坑跳了就不想回去了，最後來介紹 <code>@while</code> 迴圈處理語句：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$num</span>: <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">while</span> <span class="variable">$num</span> &lt;= 3 &#123;</span><br><span class="line">  <span class="selector-class">.pt-</span>#&#123;<span class="variable">$num</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="variable">$num</span> * <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable">$num</span>: <span class="variable">$num</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就如同一般語言的 <code>while</code> 語句，透過 <code>true</code> 或 <code>false</code> 控制迴圈流程，我比較不建議使用 <code>@while</code> 來處理迴圈，就連官方自己也說除非是特別複雜的情境，不然盡量不要使用 <code>@while</code> 語句，易造成可讀性低落的問題，更好的選擇應該是 <code>@for</code> 或 <code>@each</code> 才對。</p>
]]></content>
      <categories>
        <category>SCSS</category>
      </categories>
      <tags>
        <tag>SCSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Sass / SCSS 預處理器 - @mixin 建立混入與 @include 載入混入</title>
    <url>/2020-05-30-scss-mixin-include/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>傳統在撰寫樣式表上很常發生重工的現象，雖然說作用的對象是不同的，這指 CSS 選擇器作用的目標，但無法否認確實降低了我們的開發效率，最理想的做法應該是將會重用的樣式包裝成一個物件，每當有相同樣式的撰寫需求時，只需要取用這一個物件即可達到目的，而 Sass / SCSS 正好有提供像是 @mixin 的語句，用法就類似於 Vue.js 的 mixin，只不過將其撰寫內容更改為樣式而已，最後使用 @include 載入 mixin 即可完成取用動作，藉此達到減少重工發生可能的目的。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>建立混入與載入混入</li>
<li>添加並傳入其餘參數</li>
<li>添加並傳入可選參數</li>
<li>添加並傳入關鍵字參數</li>
<li>結合 @content 構建 RWD 混入</li>
</ul>
<h2 id="建立混入與載入混入"><a href="#建立混入與載入混入" class="headerlink" title="建立混入與載入混入"></a>建立混入與載入混入</h2><p>要在 SCSS 使用 mixin 相當簡單，先使用 <code>@mixin</code> 指令將其建立，如下範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> size &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這樣就建立好屬於我們自己的 mixin 了，接著要載入 mixin 可使用 <code>@include</code> 指令：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> size;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是相當容易？其實就只是單純把可能會重用的樣式利用 <code>@mixin</code> 將其包裝成 mixin，每當要取用時就使用 <code>@include</code> 將 mixin 的樣式附加在當前的區塊內，讓我們來看更實際的案例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> clearfix &#123;</span><br><span class="line">  &amp;::after &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> clearfix;</span><br><span class="line"></span><br><span class="line">  &amp;__item &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list__item</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以往我們都得在各別的 float 父元素添加 clearfix 樣式，現在使用 SCSS 中的 mixin 即可快速的產生清除樣式，這邊做個強調，<strong>mixin 不只可以包裝 CSS 樣式，嚴格來講可以包裝 CSS 和 SCSS 中的任何有效內容</strong>，比如說 mixin 內使用 <code>@include</code> 載入另個 mixin：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> font-reset &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Arial, Helvetica, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">mixin</span> horizontal-center &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">  @<span class="keyword">include</span> font-reset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.nav</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> horizontal-center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.nav</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">  <span class="attribute">font-family</span>: Arial, Helvetica, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面所建立的 <code>@mixin</code> 都是屬於無參數型的 mixin，我們可透過大括號將參數傳遞進去使之成為參數型 <code>@mixin</code>，先將上面範例做一個改寫：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> size() &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>與一般語言中的函式類似，函式名稱旁都有個小括號可帶入參數，這邊你可以先把 mixin 理解為一般語言中的函式，但不要直接把他認知成函式，雖然這樣講有點矛盾，因為 SCSS 確實還有另個 <code>@function</code> 方法更貼近於函式，這點以後再做討論，在 <code>@mixin</code> 新增接收參數的變數並傳入參數：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> size(<span class="variable">$num1</span>, <span class="variable">$num2</span>) &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$num1</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="variable">$num2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> size(<span class="number">200px</span>, 200px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這應該蠻好理解的，就只是將 mixin 內宣告的變數進行使用，最後 <code>@include(num1, num2)</code> 的結果就會是相對應處理後的結果，如同一般語言中函式的處理方式。</p>
<h2 id="添加並傳入其餘參數"><a href="#添加並傳入其餘參數" class="headerlink" title="添加並傳入其餘參數"></a>添加並傳入其餘參數</h2><p>每當我們要傳入參數時，mixin 就必須要有對應的變數已接收此參數，這樣不是很麻煩嗎？有沒有辦法是直接在 mixin 定義一個能接收全部參數的變數呢？答案是有的，概念類似於 JavaScript 中的 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Functions/rest_parameters" target="_blank" rel="external nofollow noopener noreferrer">Rest parameter</a>，直接來看範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> size(<span class="variable">$num1</span>, <span class="variable">$num</span>...) &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$num1</span>;</span><br><span class="line">  <span class="attribute">height</span>: inspect(<span class="variable">$num</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> size(<span class="number">100</span>, 200, 300);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了指定參數 <code>$num1</code> 所接受到的數值外，其餘都屬於 <code>$num</code> 的部分，所得到的資料型態會以 List 表示，結果如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200</span>, <span class="number">300</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面主要為示範才會使用 <code>inspect</code> 函式，正確的做法應該是使用 <code>nth</code> 取出 List 對應的值才對：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> size(<span class="variable">$num1</span>, <span class="variable">$num</span>...) &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$num1</span>;</span><br><span class="line">  <span class="attribute">height</span>: nth(<span class="variable">$num</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="attribute">font-weight</span>: nth(<span class="variable">$num</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> size(<span class="number">100</span>, 200, 300);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能會覺得與 JavaScript 將 <code>...</code> 放在變數前面有所出入，SCSS 是將 <code>...</code> 放在變數後面，剛開始我也不太習慣時常打錯，後來習慣後就沒這個問題了，我想可能是要區別兩者的獨特性吧？</p>
<h2 id="添加並傳入可選參數"><a href="#添加並傳入可選參數" class="headerlink" title="添加並傳入可選參數"></a>添加並傳入可選參數</h2><p>所謂的可選參數其實就是預設參數的意思，代表應該被接收的變數就算不傳入還是可直接向預設參數取值進而避免處理時發生錯誤，直接來看例子：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> size(<span class="variable">$num1</span>: 150px, <span class="variable">$num2</span>: 150px) &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$num1</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="variable">$num2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> size(<span class="number">120px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SCSS 預設參數賦值是使用 <code>:</code> 關鍵字，就如同宣告變數一般，與一般語言中使用 <code>=</code> 關鍵字有所不同，這邊要多加留意，以下為編譯結果：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由於我們只有傳入 <code>$num1</code> 參數的內容，故 <code>$num2</code> 就會使用預設的參數值做處理，而 <code>$num1</code> 則會覆蓋預設值以傳入的數值為目標完成操作。</p>
<h2 id="添加並傳入關鍵字參數"><a href="#添加並傳入關鍵字參數" class="headerlink" title="添加並傳入關鍵字參數"></a>添加並傳入關鍵字參數</h2><p>除了基本依造順序將參數傳遞進去以外，我們也可透過關鍵字，這指接收參數的變數名稱，將參數傳遞給指定的變數，如下範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> size(<span class="variable">$num1</span>: 150px, <span class="variable">$num2</span>: 150px) &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$num1</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="variable">$num2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> size(<span class="variable">$num2</span>: 300px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是蠻新奇的？以往參數都必須依照順序傳入以保證對象如預期被接收，在 SCSS 你可以不必這樣做，直接以關鍵字方式傳入參數值即可，此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>雖然說方便度提高了不少，但我認為這樣子的寫法可能存在可讀性低落的問題，你沒辦法立即得知那些參數未傳入那些參數已傳入，最後可能就會跳出錯誤。</p>
<h2 id="結合-content-構建-RWD-混入"><a href="#結合-content-構建-RWD-混入" class="headerlink" title="結合 @content 構建 RWD 混入"></a>結合 @content 構建 RWD 混入</h2><p><code>@mixin</code> 最常被用來包裝 RWD (Responsive Web Design) 的 <code>@media</code> 以解決 media queries 重複撰寫問題，先來看傳統上我們是怎麼撰寫 RWD 的：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.col-md-4</span>,</span><br><span class="line"><span class="selector-class">.col-md-6</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: 768px) &#123;</span><br><span class="line">  <span class="selector-class">.col-md-4</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> (<span class="number">100%</span> * <span class="number">4</span>/<span class="number">12</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.col-md-6</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> (<span class="number">100%</span> * <span class="number">6</span>/<span class="number">12</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我習慣將 RWD 代碼撰寫在樣式表的尾端以方便做管理，但這有一個問題是，假如我們的代碼量很龐大呢？豈不是要在每次撰寫時都得滑個老半天？且之前就有提到 SCSS 主要解決我們重工的問題，如果其他的 <a href="https://sass-lang.com/guide#topic-4" target="_blank" rel="external nofollow noopener noreferrer">Partials</a> 也要使用的話不就又造成重工的問題了嗎？這時我們可利用前面學到的 <code>@mixin</code> 將 <code>@media</code> 包裝起來：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> pad(<span class="variable">$col</span>) &#123;</span><br><span class="line">  @<span class="keyword">media</span> screen and (min-width: 768px) &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> (<span class="number">100%</span> * <span class="variable">$col</span>/<span class="number">12</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-md-4</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">  @<span class="keyword">include</span> pad(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-md-6</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">  @<span class="keyword">include</span> pad(<span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.col-md-4</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.col-md-4</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">33.33333%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-md-6</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.col-md-6</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">50%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這邊你可能會對 <code>@mixin</code> 與 <code>@media</code> 的結合感到困惑，為何 <code>@media</code> 會自動跳脫到外層呢？當時的我也感到困惑，後來看到官方的 <a href="https://sass-lang.com/documentation/at-rules/css" target="_blank" rel="external nofollow noopener noreferrer">CSS At-Rules</a> 發現這其實是 SCSS 其中一種處理方式，你可以嘗試編譯下面範例看看：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.print-only</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line"></span><br><span class="line">  @<span class="keyword">media</span> print &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>編譯器對 @media 的巢狀結構處理是將其跳脫到外層去</strong>，畢竟沒有人會將 CSS 寫做 <code>.print-only @media</code>，這才導致這樣子的結果，這也是前面 RWD 能夠結合 <code>@mixin</code> 的關鍵，是不是覺得這樣子清楚許多？但在這邊還有一個小問題是，目前都是依靠參數去做響應變化，參數一多容易造成可讀性低落問題，比較好的做法是使用 <code>@content</code> 才對：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> pad &#123;</span><br><span class="line">  @<span class="keyword">media</span> screen and (min-width: 768px) &#123;</span><br><span class="line">    @<span class="keyword">content</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-md-4</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">  @<span class="keyword">include</span> pad &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> (<span class="number">100%</span> * <span class="number">4</span>/<span class="number">12</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-md-6</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">  @<span class="keyword">include</span> pad &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> (<span class="number">100%</span> * <span class="number">6</span>/<span class="number">12</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.col-md-4</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.col-md-4</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">33.33333%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-md-6</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.col-md-6</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">50%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>與前面使用參數傳遞的結果相同，但靈活度卻提高了不少，事實上 <code>@include</code> 還可以透過大括號進行傳遞，而 <code>@mixin</code> 則是透過 <code>@content</code> 接收，我自己是蠻常使用此方式撰寫 RWD，不覺得這樣直覺多了嗎？雖然說編譯後會產生多餘的代碼，但以開發體驗來說，我認為完全是不同等級的，這邊做個最後的補充：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> hamburger &#123;</span><br><span class="line">  <span class="selector-class">.open</span> &amp; &#123;</span><br><span class="line">    @<span class="keyword">content</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.menu</span> &#123;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">0px</span>;</span><br><span class="line">  @<span class="keyword">include</span> hamburger &#123;</span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">300px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>還記得之前介紹的 <code>&amp;</code> 父選擇器搭配 hamburger menu 範例嗎？我們同樣可把它包裝成 <code>@mixin</code> 並搭配 <code>@content</code> 使之更具靈活度，可以參考上面範例。</p>
]]></content>
      <categories>
        <category>SCSS</category>
      </categories>
      <tags>
        <tag>SCSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Sass / SCSS 預處理器 - @function 建立函式與 @return 返回結果</title>
    <url>/2020-06-01-scss-function-return/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前介紹 @mixin 時是以一般語言的函式做為參考進行操作，事實上 SCSS 有更符合函式定義的語法名為 @function，與 @mixin 不同的地方在於 @function 無法直接將 CSS 樣式加載至當前所在的 CSS 塊內，反而是透過 @return 將函式內處理的結果返回給呼叫的對象後續再進行相關處理，簡單來講就是 @mixin 負責包裝 CSS 樣式，而 @function 則是包裝需透過處理使之形成的有效對象，該如何透過 @function 進一步提升開發效率也就是本篇的重點。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>建立函式與返回結果</li>
<li>添加並傳入其餘參數</li>
<li>添加並傳入可選參數</li>
<li>添加並傳入關鍵字參數</li>
</ul>
<h2 id="建立函式與返回結果"><a href="#建立函式與返回結果" class="headerlink" title="建立函式與返回結果"></a>建立函式與返回結果</h2><p>目前都是推薦使用 LibSass 做為 Sass 實現的對象，關於 LibSass 與 Dart Sass 的差別可參考我之前寫過的 <a href="https://awdr74100.github.io/2020-03-04-webpack-sassloader/#%E8%A3%9C%E5%85%85%EF%BC%9ADart-Sass-%E8%88%87-Node-Sass">文章</a>，而 LibSass 本身並沒有 <code>math.pow</code> 方法，此方法只能在 Dart Sass 的環境下使用，不如我們利用函式手刻出效果不就得了？直接來看範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@function pow(<span class="variable">$base</span>, <span class="variable">$exponent</span>) &#123;</span><br><span class="line">  <span class="variable">$result</span>: <span class="number">1</span>;</span><br><span class="line">  @<span class="keyword">for</span> <span class="variable">$var</span> from 1 through <span class="variable">$exponent</span> &#123;</span><br><span class="line">    <span class="variable">$result</span>: <span class="variable">$result</span> * <span class="variable">$base</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  @return <span class="variable">$result</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">z-index</span>: pow(<span class="number">2</span>, <span class="number">10</span>) * <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 SCSS 宣告函式可使用 <code>@function</code> 關鍵字，當產生結果時可使用 <code>@return</code> 將其返回給呼叫的對象，其實與一般語言的函式沒啥兩樣，以下為編譯結果：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1024px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你是 JavaScript 的開發者，可能會嘗試使用 ES7 的指數運算符 <code>**</code> 來完成任務，在 SCSS 你不能這樣做，因為本身並沒有相關的運算符可做使用，只能依靠自己將其效果手刻出來，讓我們再來看個例子：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _variables.scss</span></span><br><span class="line"><span class="variable">$theme-colors</span>: map-merge(</span><br><span class="line">  (</span><br><span class="line">    <span class="string">'primary'</span>: <span class="number">#007bff</span>,</span><br><span class="line">    <span class="string">'secondary'</span>: <span class="number">#6c757d</span>,</span><br><span class="line">    <span class="string">'success'</span>: <span class="number">#28a745</span>,</span><br><span class="line">  ),</span><br><span class="line">  ()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// _functions.scss</span></span><br><span class="line">@function theme-color(<span class="variable">$key</span>) &#123;</span><br><span class="line">  @return map-get(<span class="variable">$theme-colors</span>, <span class="variable">$key</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: theme-color(primary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Bootstrap 的 SCSS 檔案中，你會多次看到上面這種寫法，起初我本來以為 <code>theme-color</code> 是 SCSS 內建的方法，後來才發現原來是 <code>_functions.scss</code> 這隻檔案宣告的函式阿，這時你可能會想，這樣不是多此一舉嗎？我直接使用 <code>map-get</code> 不就能取得對應的顏色了嗎？幹嘛還要使用函式方式做取得？老實講我也不太能理解這樣的處理手段，我認為這也是 <code>@function</code> 使用頻率較低的原因，畢竟 SCSS 的撰寫是以樣式為主，在這種情況下 <code>@mixin</code> 往往來的比 <code>@function</code> 更好用，且在 SCSS 不需要處理一般語言中這麼複雜的對象，<code>@function</code> 的存在也就越來越模糊。</p>
<h2 id="添加並傳入其餘參數"><a href="#添加並傳入其餘參數" class="headerlink" title="添加並傳入其餘參數"></a>添加並傳入其餘參數</h2><p>與 <code>@mixin</code> 處理手法相同，<code>@function</code> 同樣也可添加類似於 JavaScript 中的 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Functions/rest_parameters" target="_blank" rel="external nofollow noopener noreferrer">Rest parameter</a>，直接來看範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@function px-to-rem(<span class="variable">$sizes</span>...) &#123;</span><br><span class="line">  <span class="variable">$result</span>: ();</span><br><span class="line">  @<span class="keyword">each</span> <span class="variable">$value</span> in nth(<span class="variable">$sizes</span>, 1) &#123;</span><br><span class="line">    <span class="variable">$result</span>: append(<span class="variable">$result</span>, (<span class="variable">$value</span> / <span class="number">16px</span>) * <span class="number">1rem</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  @return <span class="variable">$result</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: px-to-rem(<span class="number">20px</span>);</span><br><span class="line">  <span class="attribute">padding</span>: px-to-rem(<span class="number">20px</span> <span class="number">16px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所謂的其餘參數就是指將未明確定義其接收變數的參數通通放在 <code>$...</code> 變數裡頭，這一個 <code>$...</code> 變數會以 List 的形式存在，接下來就看要用迴圈還是相關方法進行取用動作。</p>
<h2 id="添加並傳入可選參數"><a href="#添加並傳入可選參數" class="headerlink" title="添加並傳入可選參數"></a>添加並傳入可選參數</h2><p>所謂的可選參數其實就是預設參數的意思，代表應該被接收的變數就算不傳入還是可直接向預設參數取值進而避免處理時發生錯誤，直接來看例子：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@function getUrl(<span class="variable">$fileName</span>, <span class="variable">$ext</span>: <span class="string">'png'</span>) &#123;</span><br><span class="line">  <span class="variable">$baseUrl</span>: <span class="string">'/src/assets/img/'</span>;</span><br><span class="line">  @return <span class="variable">$baseUrl</span> + <span class="variable">$fileName</span> + <span class="string">'.'</span> + <span class="variable">$ext</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.logo</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(getUrl(<span class="string">'logo'</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(getUrl(<span class="string">'facebook'</span>, <span class="string">'svg'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SCSS 預設參數賦值是使用 <code>:</code> 關鍵字，就如同宣告變數一般，與一般語言中使用 <code>=</code> 關鍵字有所不同，這邊要多加留意，以下為編譯結果：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.logo</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'/src/assets/img/logo.png'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'/src/assets/img/facebook.svg'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加並傳入關鍵字參數"><a href="#添加並傳入關鍵字參數" class="headerlink" title="添加並傳入關鍵字參數"></a>添加並傳入關鍵字參數</h2><p>除了基本依造順序將參數傳遞進去以外，我們也可透過關鍵字，這指接收參數的變數名稱，將參數傳遞給指定的變數，如下範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@function sqrt(<span class="variable">$str</span>: <span class="string">'undefined'</span>, <span class="variable">$num</span>: 10) &#123;</span><br><span class="line">  <span class="variable">$x0</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="variable">$x1</span>: <span class="variable">$x0</span>;</span><br><span class="line">  @<span class="keyword">for</span> <span class="variable">$i</span> from 1 through 10 &#123;</span><br><span class="line">    <span class="variable">$x1</span>: <span class="variable">$x0</span> - (<span class="variable">$x0</span> * <span class="variable">$x0</span> - abs(<span class="variable">$num</span>)) / (<span class="number">2</span> * <span class="variable">$x0</span>);</span><br><span class="line">    <span class="variable">$x0</span>: <span class="variable">$x1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  @return <span class="variable">$x1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: sqrt(<span class="variable">$num</span>: <span class="number">100</span>) * <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是蠻新奇的？以往參數都必須依照順序傳入以保證對象如預期被接收，在 SCSS 你可以不必這樣做，直接以關鍵字方式傳入參數值即可，此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>雖然說方便度提高了不少，但我認為這樣子的寫法可能存在可讀性低落的問題，你沒辦法立即得知那些參數未傳入那些參數已傳入，最後可能就會跳出錯誤。</p>
]]></content>
      <categories>
        <category>SCSS</category>
      </categories>
      <tags>
        <tag>SCSS</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>Sass / SCSS 預處理器 - @entend 繼承樣式與 Placeholder 佔位符選擇器</title>
    <url>/2020-06-03-scss-extend/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前面我們有提到可使用 @mixin 將發生重用的樣式給包裝起來，進而減少重複撰寫樣式的時間，但在這邊有一個問題是，此做法會造成編譯後的 CSS 發生樣式大量重複的問題，搞得檔案異常肥大，在較為嚴苛的環境下，此問題是不被允許的，建議的作法是使用 @entend 並搭配 placeholder 選擇器將重用樣式給綑綁起來，@extend 就類似於 @mixin，不同的地方在於 @extend 會將目標對象進行合併而不是載入，而 placeholder 選擇器主要用來創建重用對象，在不被編譯的狀態下給予 @extend 繼承用。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>繼承樣式</li>
<li>佔位符選擇器</li>
<li>@extend 與 @mixin 使用時機和差異</li>
</ul>
<h2 id="繼承樣式"><a href="#繼承樣式" class="headerlink" title="繼承樣式"></a>繼承樣式</h2><p>讓我們先來回顧 <code>@mixin</code> 是怎麼解決樣式重用問題的：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> flex-center &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> flex-center;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> flex-center;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> flex-center;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@mixin</code> 是我最常使用的 SCSS 功能，只需要在 <code>@include</code> 之前撰寫一次會發生重用的樣式，後續就都利用 <code>@include</code> 載入其樣式即可，此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>雖然說編譯後的檔案我們通常不會有太多的關注，但在某些情況下，我們確實需要做些改善以符合當前專案的規範，比如說樣式表的檔案大小，從上面結果你會發現 <code>@mixin</code> 形成了許多重複樣式，也因為這些重複樣式造成樣式表異常的肥大，建議的做法是將發生重用的樣式以合併的方式進行處理，如下所示：</p>
<!-- prettier-ignore-start -->
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.header</span>, <span class="selector-class">.section</span>, <span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>合併樣式的目的在於保持代碼的精簡性，以不發生重複代碼為原則，依然保持樣式作用於對象，為了滿足合併樣式的目的，我們可改使用 <code>@extend</code> 方法，直接來看範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flex-center</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  @<span class="keyword">extend</span> .flex-center;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  @<span class="keyword">extend</span> .flex-center;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  @<span class="keyword">extend</span> .flex-center;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@extend</code> 的目的在於繼承其指定樣式，呼叫 <code>@extend</code> 的對象會被合併到指定的對象上，相較於 <code>@mixin</code> 的處理方式，此方法既能減少重複樣式的撰寫也能達到編譯後 CSS 精簡化的目的，此時的編譯結果為：</p>
<!-- prettier-ignore-start -->
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flex-center</span>, <span class="selector-class">.header</span>, <span class="selector-class">.section</span>, <span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>這不就是我們要的結果嗎？相關的樣式都被合併到了指定樣式上，讓我們再來看個範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.font-base</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#1d1d1d</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.5em</span>;</span><br><span class="line">    @<span class="keyword">extend</span> .font-base;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">  <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.25em</span>;</span><br><span class="line">    @<span class="keyword">extend</span> .font-base;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如同我們前面所說，呼叫 <code>@extend</code> 的對象會被合併到指定對象上，這邊所指的對象為 <code>.header h1</code> 與 <code>.footer h1</code>，並不是指單純的 <code>h1</code> 對象，最後的編譯結果為：</p>
<!-- prettier-ignore-start -->

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.font-base</span>, <span class="selector-class">.header</span> <span class="selector-tag">h1</span>, <span class="selector-class">.footer</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#1d1d1d</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.25em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<h2 id="佔位符選擇器"><a href="#佔位符選擇器" class="headerlink" title="佔位符選擇器"></a>佔位符選擇器</h2><p>在前面範例中，我們必定是要宣告個對象用以讓其他對象 <code>@extend</code>，這不就會導致產生無意義的樣式對象了嗎？如之前的 <code>.flex-center</code>、<code>.font-base</code> 等，如果繼承的對象沒有任何作用，我們可改使用 SCSS 獨特的佔位符選擇器將其宣告，這樣就不會有實體的樣式對象了，如下範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">%<span class="attribute">flex</span>-center &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>佔位符選擇器顧名思義就是使用 <code>%</code> 符號將其宣告，與傳統 <code>class</code>、<code>id</code> 選擇器較不同的地方在於它不會產生實體的對象，你可以嘗試編譯上面範例，最後並不會有任何的樣式被編譯出來，利用此特性我們可針對之前範例做個改寫：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">%<span class="attribute">flex</span>-center &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  @<span class="keyword">extend</span> %flex-center;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  @<span class="keyword">extend</span> %flex-center;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  @<span class="keyword">extend</span> %flex-center;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>將原本利用 <code>class</code> 選擇器宣告的對象更改為 <code>%</code> 宣告，同時 <code>@extend</code> 此對象，最後的編譯結果為：</p>
<!-- prettier-ignore-start -->
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.header</span>, <span class="selector-class">.section</span>, <span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>大功告成！編譯結果與當初設定目標一模一樣，佔位符選擇器的應用範圍可能也只有供予 <code>@extend</code> 繼承用，畢竟它不會被實體編譯出來，在多的延伸也沒有其意義。</p>
<h2 id="extend-與-mixin-使用時機和差異"><a href="#extend-與-mixin-使用時機和差異" class="headerlink" title="@extend 與 @mixin 使用時機和差異"></a>@extend 與 @mixin 使用時機和差異</h2><p>如果你對 <code>@extend</code> 與 <code>@mixin</code> 的使用時機和差異感到困惑，可以從以下兩點去做思考：</p>
<ul>
<li>是否需要傳遞參數？</li>
<li>是否在意樣式表大小？</li>
</ul>
<p>傳遞參數這點沒啥好說的，你只能使用 <code>@mixin</code> 來完成任務，因為 <code>@extend</code> 是無法傳遞任何參數的，而 <code>@mixin</code> 與 <code>@function</code> 相同，都可傳入任意的參數做使用，可參考以下範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> size(<span class="variable">$num1</span>, <span class="variable">$num2</span>) &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$num1</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="variable">$num2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> size(<span class="number">200px</span>, 200px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@extend</code> 自然是無法完成上面任務的，畢竟它沒辦法傳遞任何參數，還有另外一個判斷的依據為是否在意樣式表大小，可參考以下範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">%<span class="selector-tag">col</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">for</span> <span class="variable">$var</span> from 1 through 12 &#123;</span><br><span class="line">  <span class="selector-class">.col-</span>#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">    @<span class="keyword">extend</span> %col;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面使用了 <code>@extend</code> 來完成任務，將所有相關的樣式進行合併以減少樣式表大小，同樣道理，你也可以使用 <code>@mixin</code> 來完成，參考以下範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> col &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">for</span> <span class="variable">$var</span> from 1 through 12 &#123;</span><br><span class="line">  <span class="selector-class">.col-</span>#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">    @<span class="keyword">include</span> col;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時的編譯結果為：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.col-1</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 省略 .col-2 ~ .col-11 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-12</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>發現問題了嗎？明明所有對象都是套用相同的樣式，使用 <code>@mixin</code> 就硬生生的生成了全部實體樣式，像在這種情況就推薦使用 <code>@extend</code> 來完成，其編譯結果為：</p>
<!-- prettier-ignore-start -->
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.col-1</span>, <span class="selector-class">.col-2</span>, <span class="selector-class">.col-3</span>, <span class="selector-class">.col-4</span>, <span class="selector-class">.col-5</span>, <span class="selector-class">.col-6</span>, <span class="selector-class">.col-7</span>, <span class="selector-class">.col-8</span>, <span class="selector-class">.col-9</span>, <span class="selector-class">.col-10</span>, <span class="selector-class">.col-11</span>, <span class="selector-class">.col-12</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>這樣不是好多了嗎？所有對象都被合併到了 <code>%col</code> 對象內，如果你並不在意樣式表的大小，大可使用 <code>@mixin</code> 來完成任務，但我個人推薦使用 <code>@extend</code> 就是了。</p>
]]></content>
      <categories>
        <category>SCSS</category>
      </categories>
      <tags>
        <tag>SCSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Sass / SCSS 預處理器 - @import 載入模組與 Partials 建立部分模組</title>
    <url>/2020-06-05-scss-import-partials/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>模組化一直以來都是網頁端一項很重要的處理，有效的模組化可讓程式碼進一步提升其閱讀性，以讓後續維護人員更快速的進入狀況，且利用模組可重用的特性，我們也不需要撰寫這麼多的重複代碼，載入即完成，可說是大幅提高了其開發效率。在 CSS 可使用 @import 來拆分模組，而 SCSS 同樣也是使用 @import 來拆分模組，兩者不同的地方在於 CSS 的 @import 會產生額外的 request，而 SCSS 主要利用其特殊的 partial 檔案形成模組化的效果，再不產生額外 request 下達到模組化目的。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>建立部分模組</li>
<li>載入模組</li>
</ul>
<h2 id="建立部分模組"><a href="#建立部分模組" class="headerlink" title="建立部分模組"></a>建立部分模組</h2><p>所謂的部分模組其實就是指不會被編譯出實體檔案的模組，請先新增以下檔案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── scss&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── a.scss</span><br><span class="line">│   └─── b.scss</span><br></pre></td></tr></table></figure>

<p>前面我們都是示範在單個 SCSS 檔案進行開發，並透過編譯器生成對應的 CSS 檔案，那如果是兩個 SCSS 檔案呢？此時的編譯結果為：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> project/</span><br><span class="line"> │</span><br><span class="line"><span class="addition">+├─── css/</span></span><br><span class="line"><span class="addition">+│   │</span></span><br><span class="line"><span class="addition">+│   ├─── a.css</span></span><br><span class="line"><span class="addition">+│   └─── b.css</span></span><br><span class="line"> │</span><br><span class="line"> ├─── scss/</span><br><span class="line"> │   │</span><br><span class="line"> │   ├─── a.scss</span><br><span class="line"> │   └─── b.scss</span><br></pre></td></tr></table></figure>

<p>沒錯，這樣就會生成兩個 CSS 檔案，這應該是蠻好理解的，每一個 SCSS 檔案都是獨立的存在，編譯器會針對每個 SCSS 檔案生成對應的 CSS 檔案，如果你不想讓編譯器針對 SCSS 檔案生成實體檔案，可改使用 <code>_</code> 為開頭將其建立，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── scss&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── a.scss</span><br><span class="line">│   └─── _b.scss</span><br></pre></td></tr></table></figure>

<p>在這邊我們將 <code>b.scss</code> 更改為 <code>_b.scss</code>，神奇的事情要發生了，直接進行編譯：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> project/</span><br><span class="line"> │</span><br><span class="line"><span class="addition">+├─── css/</span></span><br><span class="line"><span class="addition">+│   │</span></span><br><span class="line"><span class="addition">+│   └─── a.css</span></span><br><span class="line"> │</span><br><span class="line"> ├─── scss/</span><br><span class="line"> │   │</span><br><span class="line"> │   └─── a.scss</span><br><span class="line"> │   └─── b.scss</span><br></pre></td></tr></table></figure>

<p>你會發現 <code>_b.scss</code> 沒有被編譯出實體檔案，在 SCSS 會稱其為 <code>partial</code>，以 <code>_</code> 開頭的 <code>.scss</code> 或 <code>.sass</code> 檔案都屬於 <code>partial</code> 類型檔案，用以告知編譯器不要嘗試自行編譯這些檔案。</p>
<p>你可能會問，這樣的用意是什麼？你可以把 <code>partial</code> 理解為只供予其他檔案 <code>@import</code> 的模組，如果單獨存在，本身是沒有任何意義的，通常都是與 <code>@import</code> 搭配居多，讓我們繼續看下去。</p>
<h2 id="載入模組"><a href="#載入模組" class="headerlink" title="載入模組"></a>載入模組</h2><p>前面已經介紹 <code>partial</code> 的作用了，接著讓我們正式進入到 SCSS 模組化的章節，先建立以下結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── scss&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── helpers&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       ├─── _mixins.scss</span><br><span class="line">│       └─── _variables.scss</span><br><span class="line">│   │</span><br><span class="line">│   └─── all.scss</span><br></pre></td></tr></table></figure>

<p>一般來說我們都會把 SCSS 的模組彙整到 <code>all.scss</code> 檔案中，而模組的命名必定會以 <code>_</code> 為開頭 ，這點在前面已經有解釋過，最後的編譯結果就只會生成 <code>all.scss</code> 對應的 <code>all.css</code> 檔案，接著在每個模組檔案撰寫其對應內容：</p>
<p><code>./scss/helpers/_variables.scss</code> 檔案內容：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$theme-colors</span>: (</span><br><span class="line">  primary: blue,</span><br><span class="line">  success: green,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>./scss/helpers/_mixins.scss</code> 檔案內容：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> bg-invert(<span class="variable">$color</span>) &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: invert(<span class="variable">$color</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>./scss/all.scss</code> 檔案內容：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/variables'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/mixins'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 測試輸出</span></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$theme-colors</span> &#123;</span><br><span class="line">  <span class="selector-class">.text-</span>#&#123;<span class="variable">$key</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$value</span>;</span><br><span class="line">    @<span class="keyword">include</span> bg-invert(<span class="variable">$value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@import</code> 語句可用來載入其他模組，並且不需要撰寫 <code>_</code> 與 <code>.scss</code> 字樣，SCSS 能夠自動辨認其模組，上面範例就等同於將全部代碼撰寫在 <code>all.scss</code> 中，如下所示：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$theme-colors</span>: (</span><br><span class="line">  primary: blue,</span><br><span class="line">  success: green,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">@<span class="keyword">mixin</span> bg-invert(<span class="variable">$color</span>) &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: invert(<span class="variable">$color</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 測試輸出</span></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$theme-colors</span> &#123;</span><br><span class="line">  <span class="selector-class">.text-</span>#&#123;<span class="variable">$key</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$value</span>;</span><br><span class="line">    @<span class="keyword">include</span> bg-invert(<span class="variable">$value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這邊你應該就能理解何謂 SCSS 模組化了，其實到頭來我們都是在呼叫 <code>@import</code> 的對象 <code>all.scss</code> 做撰寫，只不過將其撰寫內容拆分到被呼叫的 <code>@import</code> 對象而已，這也是與傳統 CSS 模組化最大的不同，SCSS 的模組化是發生在未編譯之前，這時你可以任意的拆分模組，反正不影響編譯生成的 CSS 檔案數量，而 CSS 的模組化是發生在 Browser 讀取到其 <code>@import</code> 字樣，進而發送 HTTP Request 時，這也是為什麼一般都推薦使用 SCSS 來完成模組化目的。</p>
<p>這邊還有一點要注意的是，通常 <code>all.scss</code> 不應該存在任何 <code>@import</code> 以外的代碼，進而影響檔案的可讀性，此時我們可針對以上做個改寫：</p>
<p>新增 <code>./scss/helpers/_text.scss</code>：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$theme-colors</span> &#123;</span><br><span class="line">  <span class="selector-class">.text-</span>#&#123;<span class="variable">$key</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$value</span>;</span><br><span class="line">    @<span class="keyword">include</span> bg-invert(<span class="variable">$value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>./scss/all.scss</code> 將其載入：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/variables'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/mixins'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/text'</span>;</span><br></pre></td></tr></table></figure>

<p>這樣是不是整潔許多？在 <code>@import</code> 時需要注意其依賴性，只需要保持一個原則就是 SCSS 是由上到下進行編譯，你總不可能把 <code>_variables.scss</code> 放在 <code>_text.scss</code> 下面吧？這樣肯定會發生 <code>Undefined</code> 的錯誤。</p>
]]></content>
      <categories>
        <category>SCSS</category>
      </categories>
      <tags>
        <tag>SCSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Sass / SCSS 預處理器 - 依造 Sass 7-1 Pattern 構建項目</title>
    <url>/2020-06-08-scss-7-1-pattern/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前一篇說明了如何利用 @import 將 partial 檔案給載入進來，進而達到模組化的目的，但這邊有一個問題是，我們該針對那些內容來模組化呢？當初這點捆擾了我許久，直到發現原來有所謂的 Sass 7-1 Pattern 可參考，7-1 模式是構建 Sass 項目的一種流行且有效的模組化方法，由 7 個資料夾與 1 個檔案所組成，每一個資料夾都有各自實現的對象，我們可把同個實現對象但不同部分的 Sass 模組給放進去，這些模組最後都會被根目錄檔案視為 @import 對象，使之編譯成單獨的 CSS 檔案。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>Sass 7-1 Pattern 介紹</li>
<li>Sass 7-1 Pattern 實際案例</li>
</ul>
<h2 id="Sass-7-1-Pattern-介紹"><a href="#Sass-7-1-Pattern-介紹" class="headerlink" title="Sass 7-1 Pattern 介紹"></a>Sass 7-1 Pattern 介紹</h2><p>Sass 7-1 Pattern 主要由國外開發者 <a href="https://hugogiraudel.com/" target="_blank" rel="external nofollow noopener noreferrer">Hugo Giraudel</a> 在廣為流傳的 <a href="https://sass-guidelin.es/" target="_blank" rel="external nofollow noopener noreferrer">Sass Guidelines</a> 所提出，其架構主要由 7 個文件夾與 1 個檔案所組成，他看起來像這個樣子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── abstracts&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── _variables.scss</span><br><span class="line">│   ├─── _functions.scss</span><br><span class="line">│   ├─── _mixins.scss</span><br><span class="line">│   └─── _placeholders.scss</span><br><span class="line">│</span><br><span class="line">├─── base&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── _reset.scss</span><br><span class="line">│   ├─── _typography.scss</span><br><span class="line">│   └─── ...</span><br><span class="line">│</span><br><span class="line">├─── components&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── _buttons.scss</span><br><span class="line">│   ├─── _carousel.scss</span><br><span class="line">│   ├─── _cover.scss</span><br><span class="line">│   ├─── _dropdown.scss</span><br><span class="line">│   └─── ...</span><br><span class="line">│</span><br><span class="line">├─── layout&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── _navigation.scss</span><br><span class="line">│   ├─── _grid.scss</span><br><span class="line">│   ├─── _header.scss</span><br><span class="line">│   ├─── _footer.scss</span><br><span class="line">│   ├─── _sidebar.scss</span><br><span class="line">│   ├─── _forms.scss</span><br><span class="line">│   └─── ...</span><br><span class="line">│</span><br><span class="line">├─── pages&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── _home.scss</span><br><span class="line">│   ├─── _contact.scss</span><br><span class="line">│   └─── ...</span><br><span class="line">│</span><br><span class="line">├─── themes&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── _theme.scss</span><br><span class="line">│   ├─── _dark.scss</span><br><span class="line">│   └─── ...</span><br><span class="line">│</span><br><span class="line">├─── vendors&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   ├─── _bootstrap.scss</span><br><span class="line">│   ├─── _jquery-ui.scss</span><br><span class="line">│   └─── ...</span><br><span class="line">│</span><br><span class="line">└─── all.scss</span><br></pre></td></tr></table></figure>

<p>其中每個資料夾代表的意義為：</p>
<p><strong>Abstracts 資料夾</strong></p>
<p><code>abstracts/</code> (有些稱為 <code>helpers/</code> 或 <code>utils/</code>) 資料夾包含了整個項目中所使用到的 Sass 輔助工具，這裡存放著每一個全局變數、函數、混入與佔位符，只要是編譯後不輸出任何 CSS 的檔案都屬此類，以下參考：</p>
<ul>
<li><code>_variables.scss</code></li>
<li><code>_functions.scss</code></li>
<li><code>_mixins.scss</code></li>
<li><code>_placeholders.scss</code></li>
</ul>
<p><strong>Base 資料夾</strong></p>
<p><code>base/</code> (有些稱為 <code>config/</code>) 資料夾主要放置整個網站大規模使用到的樣式設定，比如 <a href="https://meyerweb.com/eric/tools/css/reset/" target="_blank" rel="external nofollow noopener noreferrer">meyerweb</a> 或 <a href="https://necolas.github.io/normalize.css/8.0.1/normalize.css" target="_blank" rel="external nofollow noopener noreferrer">normalize</a> 版本的重製文件，又或者是一些全域套用的預設樣式，包含字行字體相關的設定也算在內，以下參考：</p>
<ul>
<li><code>_reset.scss</code></li>
<li><code>_typography.scss</code></li>
<li><code>_base.scss</code></li>
</ul>
<p><strong>Components 資料夾</strong></p>
<p><code>components/</code> (有些稱為 <code>modules/</code>) 資料夾存放網站某些較小可重複使用的元件，可以把它理解為 <a href="http://getbem.com/" target="_blank" rel="external nofollow noopener noreferrer">BEM</a> 中的 Block，以下參考：</p>
<ul>
<li><code>_buttons.scss</code></li>
<li><code>_carousel.scss</code></li>
<li><code>_cover.scss</code></li>
<li><code>_dropdown.scss</code></li>
</ul>
<p><strong>Layout 資料夾</strong></p>
<p><code>layout/</code> 資料夾存放構建網站或者應用程序使用到的佈局部分，可以把它理解為網站的每一頁都需使用到的大型元件，常見的 <code>header</code>、<code>footer</code>、<code>sidebar</code> 就包含在此類，像是 RWD 必備的 Grid System 也算在內，以下參考：</p>
<ul>
<li><code>_navigation.scss</code></li>
<li><code>_grid.scss</code></li>
<li><code>_header.scss</code></li>
<li><code>_footer.scss</code></li>
<li><code>_sidebar.scss</code></li>
<li><code>_forms.scss</code></li>
</ul>
<p><strong>Pages 資料夾</strong></p>
<p><code>pages/</code> 資料夾存放每一個網頁特定且零碎的樣式檔案，通常 <code>layout/</code> 與 <code>components</code> 除外的頁面樣式就包含在此類，建議將檔案名稱取做與頁面同樣名稱：</p>
<ul>
<li><code>_home.scss</code></li>
<li><code>_contact.scss</code></li>
</ul>
<p><strong>Themes 資料夾</strong></p>
<p><code>themes/</code> 資料夾存放網站中的主題顏色，如果你有設計像是 Dark Mode 的轉換效果，相關的樣式就算在此類，以下參考：</p>
<ul>
<li><code>_theme.scss</code></li>
<li><code>_dark.scss</code></li>
</ul>
<p><strong>Vendors 資料夾</strong></p>
<p><code>vendors</code> 資料夾主要放置由外部庫或框架使用的第三方代碼，如果你必須覆蓋任何 <code>vendors</code> 的某個樣式，建議另外新增同名的檔案並放入名為 <code>vendors-extensions/</code> 的第 8 個新增資料夾，以下參考：</p>
<ul>
<li><code>_bootstrap.scss</code></li>
<li><code>_jquery-ui</code></li>
</ul>
<p>以上就是各資料夾專門放置的檔案對象，接著就是將這些檔案彙整到 <code>all.scss</code> 中，為了保持可讀性，主文件不該存在任何 <code>@import</code> 以外的代碼，且必須遵守以下規則：</p>
<ul>
<li>每個 <code>@import</code> 引用一個文件</li>
<li>每個 <code>@import</code> 單獨一行</li>
<li>從相同資料夾引入的檔案之間不用空行</li>
<li>從不同資料夾引入的檔案之間需用空行分隔</li>
<li>忽略文件擴展名與 <code>_</code> 前綴</li>
</ul>
<p>Sass Guidelines 中有建議的 <code>@import</code> 順序，你可以依造他的順序，或者是自行排序，只要記住 SCSS 是由上到下進行編譯代表需注意其模組依賴性即可，最後他看起來應該像這個樣子：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">'./base/reset'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./base/typography'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/variables'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/functions'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/mixins'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/placeholders'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./layout/grid'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./layout/footer'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./layout/forms'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./layout/header'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./layout/navigation'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./layout/sidebar'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/buttons'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/carousel'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/cover'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/dropdown'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./pages/home'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./pages/contact'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./vendors/bootstrap'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./vendors/jquery-ui'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./themes/theme'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./themes/dark'</span>;</span><br></pre></td></tr></table></figure>

<p>這邊做個補充，官方有提到也可使用以下方式載入元件：</p>
<!-- prettier-ignore-start -->
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">import</span></span><br><span class="line">    <span class="string">'./base/reset'</span>,</span><br><span class="line">    <span class="string">'./base/typography'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span></span><br><span class="line">    <span class="string">'./helpers/variables'</span>,</span><br><span class="line">    <span class="string">'./helpers/functions'</span>,</span><br><span class="line">    <span class="string">'./helpers/mixins'</span>,</span><br><span class="line">    <span class="string">'./helpers/placeholders'</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>這邊要強調，所謂的 7-1 模式只是提供參考用，具體上要怎麼搭，最好按項目大小來決定，如果項目規模較小，用 7-1 模式就顯得有點大材小用了，7-1 模式最重要的是它拆分模組的概念，如果了解其概念，往後在處理各種規模的樣式表都能勢如破竹。</p>
<h2 id="Sass-7-1-Pattern-實際案例"><a href="#Sass-7-1-Pattern-實際案例" class="headerlink" title="Sass 7-1 Pattern 實際案例"></a>Sass 7-1 Pattern 實際案例</h2><p>如果你還是對 7-1 模式感到困惑，不妨可參考下面提供的實際案例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">'./base/reset'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/variables'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./helpers/spacing'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./layout/grid'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./layout/footer'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./layout/header'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/banner'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/button'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/card'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/formLogin'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/formRegister'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/formCard'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/navbar'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/ribbon'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./components/search'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./pages/home'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./pages/login'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./pages/register'</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./pages/cart'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'./vendors/pure'</span>;</span><br></pre></td></tr></table></figure>

<p>從 Sass 的主文件可以得知這個網站總共有 4 個頁面，分別為 <code>home</code>、<code>login</code>、<code>register</code>、<code>cart</code>，在樣式表的開頭使用了 CSS Reset 將畫面樣式做重整，內部使用了 Grid System 與 Spacing 來完成基本的佈局，網站充滿了大量可重複使用的元件，比如說 <code>button</code>、<code>card</code> 等，最後在 <code>vendors/</code> 資料夾載入了 <a href="https://purecss.io/" target="_blank" rel="external nofollow noopener noreferrer">Pure.css</a> 框架。</p>
<p>有沒有發現我少建立 <code>themes/</code> 資料夾？如果你的網站沒有主題顏色自然也就沒有建立的必要，這也是我們之前提到的 7-1 模式只是提供參考用，具體上該怎麼做還是得依專案而定。</p>
<p>跑過了一次實際案例相信你對 7-1 模式的模組拆分技巧有更深入的了解，你也可以參考 <a href="https://sass-guidelin.es/" target="_blank" rel="external nofollow noopener noreferrer">Sass Guidelines</a> 作者 <a href="https://hugogiraudel.com/" target="_blank" rel="external nofollow noopener noreferrer">Hugo Giraudel</a> 使用 <a href="https://hugogiraudel.com/" target="_blank" rel="external nofollow noopener noreferrer">Hugo</a> 所創建的 Blog 原始碼，裏頭 Sass 拆分的方式就是依造 7-1 模式，以下為連結：</p>
<ul>
<li><a href="https://github.com/HugoGiraudel/hugogiraudel.com/tree/master/assets/sass" target="_blank" rel="external nofollow noopener noreferrer">Source Code</a></li>
</ul>
]]></content>
      <categories>
        <category>SCSS</category>
      </categories>
      <tags>
        <tag>SCSS</tag>
        <tag>w3HexSchool</tag>
        <tag>CSS Methodologies</tag>
      </tags>
  </entry>
  <entry>
    <title>Sass / SCSS 預處理器 - OOCSS、SMACSS、BEM 模組化方法論</title>
    <url>/2020-06-19-scss-oocss-smacss-bem/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>所謂的 CSS 方法論是指無須任何套件或框架即可達成模組化目的的架構心法，用以讓 CSS 也能有良好的重用性、維護性及延展性，雖然我們前面已經可透過像是 SCSS 預處理器搭配 7-1 Pattern 達到模組化的效果，但 7-1 模式的模組化拆分最小單位為檔案，這代表著檔案內的所有樣式依然還是處於未模組化的狀態，此時我們就可利用知名的 OOCSS、SMACSS、BEM 等 CSS 方法論針對像是 class 這種較小的單位進行模組化，真正意義上的讓樣式表達到模組化目的。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>OOCSS（Object Oriented CSS）</li>
<li>SMACSS (Scalable and Moduler Architecture fro CSS)</li>
<li>BEM (Block Element Modifier)</li>
</ul>
<h2 id="OOCSS（Object-Oriented-CSS）"><a href="#OOCSS（Object-Oriented-CSS）" class="headerlink" title="OOCSS（Object Oriented CSS）"></a>OOCSS（Object Oriented CSS）</h2><img src="https://i.imgur.com/qbPyQwF.jpg" width="80%">

<p><a href="http://oocss.org/" target="_blank" rel="external nofollow noopener noreferrer">OOCSS</a> 是所有 CSS 方法論最早提出的一個，主要由 <a href="https://github.com/stubbornella" target="_blank" rel="external nofollow noopener noreferrer">Nicole Sullivan</a> 提出，你可以參考作者撰寫的 <a href="https://github.com/stubbornella/oocss/wiki" target="_blank" rel="external nofollow noopener noreferrer">WiKi</a>，OOCSS 就如同字面上的意思，主要依造物件導向 (Object-Oriented Programming, OOP) 方式來撰寫目標，這邊你可以把它理解為將 CSS 物件化、模組化，其主要概念為以下兩點：</p>
<ul>
<li>Separate structure and skin：結構與樣式分離<ul>
<li>例子：<code>.btn-primary</code>、<code>.rounded-top</code></li>
</ul>
</li>
<li>Separate container and content：容器與內容分離<ul>
<li>例子：<code>.container</code>、<code>.col-4</code></li>
</ul>
</li>
</ul>
<p>OOCSS 提倡的理念是樣式可重用性，在撰寫時需符合以下規則：</p>
<ul>
<li>應盡量避免使用後代選擇器 (<code>.navbar ul</code>) 或 id 選擇器 (<code>#list</code>)</li>
<li>應盡量避免樣式依賴於結構 (低耦合概念)，嘗試使用 class 替代 tag 選擇器</li>
</ul>
<h3 id="結構與樣式分離"><a href="#結構與樣式分離" class="headerlink" title="結構與樣式分離"></a>結構與樣式分離</h3><p>所謂的結構與樣式分離就如同 <code>.btn</code> 與 <code>.btn-primary</code> 之間的關係，讓我們先從一般在撰寫樣式的習慣開始說起：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$theme-colors</span>: (</span><br><span class="line">  primary: blue,</span><br><span class="line">  success: green,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn-primary</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.375rem</span> <span class="number">0.75rem</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: map-get(<span class="variable">$theme-colors</span>, primary);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid map-get(<span class="variable">$theme-colors</span>, primary);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.25rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>傳統上我們習慣把全部樣式都寫在同一個 class 對象上，就像上面這個樣子，此時如果我們又要新增色系為 <code>success</code> 的按鈕呢？你可能會這樣做：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.btn-primary</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.375rem</span> <span class="number">0.75rem</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: map-get(<span class="variable">$theme-colors</span>, primary);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid map-get(<span class="variable">$theme-colors</span>, primary);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.25rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn-success</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.375rem</span> <span class="number">0.75rem</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: map-get(<span class="variable">$theme-colors</span>, success);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid map-get(<span class="variable">$theme-colors</span>, success);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.25rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>發現問題了嗎？我們又浪費時間在撰寫相同的樣式了，在每次增加一個色系時，我們都必須整組做設定，這樣豈不是很浪費時間嗎？OOCSS 中的結構與樣式分離主要就是在改善這個問題，先將以上針對 OOCSS 的規範做個改寫：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.375rem</span> <span class="number">0.75rem</span>;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  <span class="attribute">background-color</span>: transparent;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.25rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: map-get(<span class="variable">$theme-colors</span>, primary);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid map-get(<span class="variable">$theme-colors</span>, primary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 OOCSS 的概念中，表現型的 style 就屬於樣式，封裝型的 style 就屬於結構，可參考以下：</p>
<ul>
<li>樣式 (skin)：<code>color</code>、<code>background-color</code>、<code>border-color</code></li>
<li>結構 (structure)：<code>display</code>、<code>box-sizing</code>、<code>padding</code> (通為樣式，但這控制其結構，故屬結構)</li>
</ul>
<p>這應該蠻好理解的，凡是顏色、邊框樣式、陰影這些都屬於 OOCSS 中所說的 skin，而像 <code>display</code> 這種或封裝對象本身就該擁有的屬性，這指 <code>padding</code>，就是所稱的 structure，你可能會問這樣的用意是什麼？直接來看 <code>button</code> 是如何使用這些樣式的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span>&gt;</span>Primary<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>是不是直覺很多？我們可以很明確的知道此對象的結構與樣式，往後如果要增加不同色系，這指 skin，也只需要撰寫像是 <code>.btn-success</code>、<code>.btn-danger</code> 的樣式即可，如果你想要更高效的做法，可以搭配 Sass 中的 <code>@each</code> 使結構更具可讀性：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$theme-colors</span>: (</span><br><span class="line">  primary: blue,</span><br><span class="line">  success: green,</span><br><span class="line">  danger: red,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.375rem</span> <span class="number">0.75rem</span>;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  <span class="attribute">background-color</span>: transparent;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.25rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$theme-colors</span> &#123;</span><br><span class="line">  <span class="selector-class">.btn-</span>#&#123;<span class="variable">$key</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="variable">$value</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="variable">$value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時按鈕只需加載對應樣式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span>&gt;</span>Primary<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-success"</span>&gt;</span>Success<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-danger"</span>&gt;</span>Danger<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>相信透過上面的範例你就能了解何謂結構與樣式分離了，如果以 OOCSS 中的 OO (Object Oriented) 做描述的話，這邊的結構 (Structure) 就是所指的對象，以上面範例來說，我們封裝了 <code>button</code> 對象，往後如果要使用 <code>button</code>的話，只需要撰寫 <code>.btn</code> 結構樣式名稱與對應的 skin 即可。</p>
<h3 id="容器與內容分離"><a href="#容器與內容分離" class="headerlink" title="容器與內容分離"></a>容器與內容分離</h3><p>介紹完了何謂結構與樣式分離，接下來換容器與內容該如何分離，它們之間就如同 <code>.card</code> 與 <code>.btn</code> 的關係，直接來看範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span> <span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.375rem</span> <span class="number">0.75rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常我們在撰寫 CSS 時，很長根據 HTML 結構來撰寫其樣式，從上面可以看出 <code>.card</code> 裏頭似乎有個 <code>button</code>，這樣子的寫法毫無靈活度可言，<code>button</code> 完全被綁死在了 <code>.card</code> 裏頭，OOCSS 中的容器與內容分離主要就是在改善這個問題，先將以上針對 OOCSS 的規範做個改寫：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.375rem</span> <span class="number">0.75rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>容器與內容分離意旨將兩個不同的父子元素給分離出來，藉此達到父子元素不相互依賴的目的，且父子元素只存在於名稱上的關係，實際上兩者都可單獨存在並使用在不同的區域上，在這邊 <code>.card</code> 就屬於容器，<code>.btn</code> 就屬於內容，詳細可參考以下：</p>
<ul>
<li>容器 (container)：<code>.container</code>、<code>.col-4</code>、<code>.header</code></li>
<li>內容 (content)：<code>.btn</code>、<code>.input</code>、<code>.dropdown</code></li>
</ul>
<p>這邊要注意，並非所有對象都須遵守容器與內容分離的原則，可參考以下範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.col-4</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">100%</span> * (<span class="number">4</span>/<span class="number">12</span>);</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line"></span><br><span class="line">  &amp;-<span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span> auto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一個對象可能同時身兼容器與內容的角色，對於 <code>.col-4</code> 對象來說，<code>.card</code> 就屬於內容，而對於 <code>.card-body</code> 對象來說，<code>.card</code> 就屬於容器，你可能會想，怎不把 <code>.card-body</code> 做分離呢？不是說容器必須與內容作分離嗎？這邊的 <code>.card-body</code> 如果獨立存在本身是沒有任何意義的，需與 <code>.card</code> 搭配才會有意義，在這種情況下 <code>.card-body</code> 屬於 <code>.card</code> 的繼承，就無須將其分離出來，與前面的 <code>.btn</code> 不同，<code>.btn</code> 獨立存在是可重複使用在其他區塊上的。</p>
<p>跑過一次上面的範例你大概就能了解 OOCSS 該怎麼使用了，是不是其語法結構跟某框架很相似阿？沒錯！Bootstrap 便是根據 OOCSS 規範寫的，我們可以隨便拿個範例來看：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"navbar navbar-light bg-light"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"navbar-brand"</span>&gt;</span>Navbar<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"form-inline"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-control mr-sm-2"</span> <span class="attr">type</span>=<span class="string">"search"</span> <span class="attr">placeholder</span>=<span class="string">"Search"</span> <span class="attr">aria-label</span>=<span class="string">"Search"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-outline-success my-2 my-sm-0"</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Search<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中有 <code>.navbar</code>、<code>.navbar-light</code> 等 class，這些就屬於 OOCSS 中的結構與樣式分離，而 <code>.form-inline</code>、<code>.btn</code> 等 class，這些就屬於容器與內容分離，如果你想更深入的學習 OOCSS 概念，不妨參考下 Bootstrsp 的原始碼，其處理的細膩度可說是將 OOCSS 發揮的淋漓盡致。</p>
<h2 id="SMACSS-Scalable-and-Moduler-Architecture-fro-CSS"><a href="#SMACSS-Scalable-and-Moduler-Architecture-fro-CSS" class="headerlink" title="SMACSS (Scalable and Moduler Architecture fro CSS)"></a>SMACSS (Scalable and Moduler Architecture fro CSS)</h2><img src="https://i.imgur.com/w1b2SQf.png" width="80%">

<p><a href="http://smacss.com/" target="_blank" rel="external nofollow noopener noreferrer">SMACSS</a> 主要由 <a href="https://snook.ca/" target="_blank" rel="external nofollow noopener noreferrer">Jonathan Snook</a> 提出，從名稱上的 Architecture 字樣可以得知他是以專案整體的結構來做考量，除了擁有與 OOCSS 類似的 HTML 與 CSS 分離概念，還有其最具特色的結構化命名概念，所謂的結構化命名是指將對象做結構分類並將其限制命名，藉此達到容易擴展及模組化目的，SMACSS 相比於 OOCSS 更偏向整個專案結構的分類及模組化你的 CSS，其中結構的分類有：</p>
<ul>
<li>Base</li>
<li>Layout</li>
<li>Module</li>
<li>State</li>
<li>Theme</li>
</ul>
<p>結構分類的目的在於將 CSS 做有效的區隔，你可以把它想成像 7-1 模式的概念，並且結合了其命名限制概念，這邊你可以先參考就好，關於實際的用途將在下面各項規則做完整介紹：</p>
<ul>
<li>Base：不須特別提供前綴，且不會使用到 class、id 選擇器，目的在於設定元素基本樣式<ul>
<li>例子：<code>html</code>、<code>*:before</code>、<code>img</code></li>
</ul>
</li>
<li>Layout：使用 <code>l-</code> 或 <code>layout-</code> 為次要佈局樣式提供前綴，目的在於將佈局樣式與其他樣式做區隔<ul>
<li>例子：<code>.l-header</code>、<code>.l-sidebar</code>、<code>.l-grid</code></li>
</ul>
</li>
<li>Module：使用模組本身命名為子模組樣式提供前綴，目的在於快速了解其相關性<ul>
<li>例子：<code>.card</code>、<code>.card-header</code>、<code>.card-body</code></li>
</ul>
</li>
<li>State：使用 <code>is-</code> 為狀態樣式提供前綴，透過語意化方式了解當前狀態<ul>
<li>例子：<code>.is-active</code>、<code>.is-hidden</code>、<code>.is-collapsed</code></li>
</ul>
</li>
<li>Theme：不須特別提供前綴，使用對象本身的名稱覆蓋其原先的主題樣式<ul>
<li>例子：<code>.l-header-dark</code>、<code>.card-dark</code></li>
</ul>
</li>
</ul>
<h3 id="Base-規則"><a href="#Base-規則" class="headerlink" title="Base 規則"></a>Base 規則</h3><p>Base 主要面相某些對象的基本及預設樣式，比如 <a href="https://meyerweb.com/eric/tools/css/reset/" target="_blank" rel="external nofollow noopener noreferrer">meyerweb</a> 或 <a href="https://necolas.github.io/normalize.css/8.0.1/normalize.css" target="_blank" rel="external nofollow noopener noreferrer">normalize</a> 版本的重製文件，或者是一些全域型的樣式設定，在撰寫時可參照以下規則：</p>
<ul>
<li>可使用元素選擇器、後代選擇器、子選擇器以及任何偽類將基本樣式應用於元素</li>
<li>不應該使用 class、id 選擇器設置元素預設樣式</li>
<li>不應該使用 <code>@important</code> 設置元素預設樣式 (權重過高，無法覆蓋)</li>
</ul>
<p>可參考以下：</p>
<!-- prettier-ignore-start -->
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">form</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*, *:before, *:after &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<h3 id="Layout-規則"><a href="#Layout-規則" class="headerlink" title="Layout 規則"></a>Layout 規則</h3><p>Layout 主要面向一些網站中的大型區塊樣式，你可以把它想像成 7-1 模式中的 Layout，所處理的對象大同小異，較特別的是 SMACSS 中的 Layout 有針對重用性劃分出主要佈局樣式和次要佈局樣式，主要佈局樣式是指畫面不發生重用的對象，而次要佈局樣式自然就是指會發生重用的對象，在撰寫時可參照以下規則：</p>
<ul>
<li>主要佈局樣式通常使用 id 選擇器進行設置</li>
<li>次要佈局樣式通常使用 class 選擇器進行設置</li>
<li>次要佈局樣式可提供 <code>l-</code> 或 <code>layout-</code> 前綴用以將佈局樣式與基本樣式做區隔</li>
<li><strong>參考 OOCSS 中的容器與內容分離概念</strong></li>
</ul>
<p>可參考以下：</p>
<!-- prettier-ignore-start -->
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#header</span>, <span class="selector-id">#article</span>, <span class="selector-id">#footer</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">960px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#article</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">#CCC</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">1px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>有違於其他 SMACSS 中的規則，在 Layout 規則中的主要佈局樣式是可以使用 id 將其宣告的，當然這僅限於畫面中不重複的對象，通常為 HTML5 帶有語意化的那些標籤，如果你想要在特定情況更改其佈局樣式，可以與次要佈局樣式搭配做使用，如下所示：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#article</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.l-flipped</span> <span class="selector-id">#article</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.l-flipped</span> <span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>藉由 CSS 疊層的特性，可讓對象應用到更高層的佈局樣式，用以覆蓋其預設樣式，這邊要注意，所謂的主要佈局樣式以及次要佈局樣式就只是名稱上的定義，請不要把思維限制在只能使用主要佈局樣式，也就是通通使用 id 選擇器撰寫其佈局樣式，大部分情況次要佈局樣式要來的比主要佈局樣式有用太多了，你可以參考接下來的這個範例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"featured"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Featured<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"…"</span>&gt;</span>…<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"…"</span>&gt;</span>…<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    …</span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果不考慮 SMACSS 中的次要佈局樣式寫法，我們可能會傾向於在 <code>featured</code> 周圍的 <code>div</code> 添加 id，然後從那裡進行樣式設置：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-id">#featured</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">list-style-type</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#featured</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這樣撰寫等同於把對象給完全綁死了，這邊指 <code>#featured</code> 只能套用在 <code>div</code> 標籤上，且由於使用了 id 選擇器，代表同個頁面中只能存在單個套用對象，是不是有點熟悉？這不就是當時 OOCSS 在解決的問題嗎？在 SMACSS 我們可以使用次要佈局樣式改善這個問題：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.l-grid</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">list-style-type</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.l-grid</span> &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其實 SMACSS 中的次要佈局樣式道理就如同 OOCSS 的容器與內容分離，目的都是將其依賴性降到最低，從上面範例來看，<code>l-grid</code> 目前已可應用於任何容器以創建浮動樣式的佈局了，同時我們也將選擇器修改為 <code>&gt;</code> 子對象選擇器避免有例外的樣式套用到對象，還有將高度給拿掉讓對象能夠自適應，關於次要佈局樣式的實作，你就把它當成在 OOCSS 的基礎下加上其命名限制中的 <code>-l</code> 前綴就可以了。</p>
<h3 id="Module-規則"><a href="#Module-規則" class="headerlink" title="Module 規則"></a>Module 規則</h3><p>Module 主要面向一些網站中的可重用元件樣式，與 Layout 不同的地方在於其對象更為準確，你可以把它想像成 7-1 模式中的 Component，所處理的對象大同小異，基於 Module 的對象都應該能以獨立組件方式存在，如果操作正確，則可以輕鬆的將元件移動到 Layout 的不同部分，在撰寫時可參照以下規則：</p>
<ul>
<li>不應該使用元素選擇器、id 選擇器設置元素樣式</li>
<li>僅使用 class 選擇器設置元素樣式</li>
<li>使用模組本身命名為子模組樣式提供前綴</li>
<li><strong>參考 OOCSS 中的結構與樣式分離概念</strong></li>
</ul>
<p>可參考以下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>Card Header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>Card Footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果遇到以上情境，我們通常會選擇偷懶的方式撰寫樣式：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.card</span> &gt; <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這樣的問題在於 <code>.card</code> 底下第一層 <code>div</code> 都被綁死了，如果我們今天要針對不同 <code>div</code> 撰寫效果，勢必要做些調整，在 SMACSS 中的 Module 建議通通使用 class 選擇器撰寫樣式：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.card-header</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card-footer</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這樣子的做法解決了 <code>div</code> 被綁死的情況，同時也增加了不少可讀性，作者有強調盡量不要使用 <code>div</code>、<code>span</code> 這種大眾化的元素選擇器，使用 class 選擇器強調語意化及可重用性才是正解，繼續來看下個範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.pod</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pod</span> <span class="selector-tag">input</span><span class="selector-attr">[type='text']</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#sidebar</span> <span class="selector-class">.pod</span> <span class="selector-tag">input</span><span class="selector-attr">[type='text']</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我們有提到，基於 Module 的對象應能夠在網頁中的任一位置使用，這時我們撰寫出的樣式可能就會長的像上面這個樣子，若專案越來越複雜，可能會不小心忽略 CSS 的優先權，進而產生樣式互蓋導致跑版的問題，SMACSS 建議更改為下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.pod</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.pod</span> <span class="selector-tag">input</span><span class="selector-attr">[type='text']</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.pod-constrained</span> <span class="selector-tag">input</span><span class="selector-attr">[type='text']</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接著在指定對象添加模組與子模組的 class 名稱：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pod pod-constrained"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其實他的概念就如同 OOCSS 中的結構與樣式分離，只不過在這稱其為子類化 (Subclassing)，透過將基底樣式抽離出來，往後在不同區域使用模組時，只需添加模組名稱與子類化模組名稱即可達到效果</p>
<h3 id="State-規則"><a href="#State-規則" class="headerlink" title="State 規則"></a>State 規則</h3><p>State 主要面向 Layout 或 Module 在網頁上的種種特效及動作，概念類似於 BEM 中的 Modifier，為了保證樣式作用於對象，允許使用 <code>@important</code>，在撰寫時可參照以下規則：</p>
<ul>
<li>State 可套用在 Layout 或 Module 上</li>
<li>可以使用 JavaScript 改變樣式</li>
<li>提供 <code>is-</code> 前綴用以辨識此為狀態樣式</li>
<li>可以合理的使用 <code>!important</code> 覆蓋樣式</li>
</ul>
<p>可參考以下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"nav-item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"nav-link is-active"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"nav-item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"nav-link"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"nav-item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"nav-link is-disabled"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>與前面介紹的子模組樣式不同的地方在於狀態樣式不需繼承於任何對象，他就只是單純的將樣式應用於對象，你可以參考 Bootstrap 中的 <code>.active</code> 或 <code>.disabled</code> 樣式，概念就如同上面的 <code>is-active</code> 與 <code>is-disabled</code>，為了保證狀態樣式作用於指定對象，在 State 中是允許使用 <code>@important</code> 的。</p>
<h3 id="Theme-規則"><a href="#Theme-規則" class="headerlink" title="Theme 規則"></a>Theme 規則</h3><p>Theme 主要面向網站主視覺而定義的 Layout 或 Module 樣式，你可以把它想像成 7-1 模式中的 theme，包含在不同國家 (語系) 中的樣式、字形轉變等。由於一般人的專案未必有如此規模，故此規則在項目不常使用，在撰寫時可參照以下規則：</p>
<ul>
<li>直接使用 Layout 或 Module 定義的 class 覆蓋其樣式</li>
</ul>
<p>可參考以下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// all.css</span></span><br><span class="line"><span class="selector-class">.mod</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// themeA.css</span></span><br><span class="line"><span class="selector-class">.mod</span> &#123;</span><br><span class="line">  <span class="attribute">border-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這邊要注意，你不需要以獨立的 class 去添加主題樣式，在 Theme 的規則中是建議使用與原先 Layout 或 Module 同樣的樣式名稱，而 <code>themeA.css</code> 這隻檔案務必得在 <code>all.css</code> 之後才載入，這樣就可達到覆蓋樣式的目的，如果網站有很多的主題樣式，也只需要新增像是 <code>themeB.css</code> 的檔案並撰寫如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.mod</span> &#123;</span><br><span class="line">  <span class="attribute">border-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之後改載入 <code>all.css</code> 與 <code>themeB.css</code> 檔案，這樣就能達到更改不同主題顏色的目的。</p>
<h3 id="改變狀態"><a href="#改變狀態" class="headerlink" title="改變狀態"></a>改變狀態</h3><p>SMACSS 連同對象的狀態如何改變也有做說明，主要透過以下三種方式：</p>
<ul>
<li>透過 JavaScript 改變對象狀態</li>
<li>透過 pseudo-class 改變對象狀態</li>
<li>透過 media query 改變對象狀態</li>
</ul>
<h4 id="透過-JavaScript-改變對象狀態"><a href="#透過-JavaScript-改變對象狀態" class="headerlink" title="透過 JavaScript 改變對象狀態"></a>透過 JavaScript 改變對象狀態</h4><p>在大多數情況下，使用 JavaScript 更改對象狀態可能是最直接的方式，參考以下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'.btn-close'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="keyword">this</span>).parents(<span class="string">'.dialog'</span>).addClass(<span class="string">'is-hidden'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>這應該蠻好理解的，這邊運用了 State 所定義的樣式來更改父層對象狀態，你可能會想，我是否可以透過 Module 所定義的子類別模組來更改對象狀態呢？如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'.btn-close'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="keyword">this</span>).parents(<span class="string">'.dialog'</span>).addClass(<span class="string">'dialog-hidden'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>除了直接以 class 來操作對象狀態外，也可以利用 <code>data-*</code> 屬性來完成同樣目的，以下範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.btn</span><span class="selector-attr">[data-state='default']</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-attr">[data-state='pressed']</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-attr">[data-state='disabled']</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">  <span class="attribute">pointer-events</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">data-state</span>=<span class="string">"disabled"</span>&gt;</span>Disabled<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>data-*</code> 屬性是 HTML5 新增的語法，我們通常使用它來塞入一些抽象的 Primary Key，在資料庫操作時特別好用，同樣道理，我們也可塞入屬性的關鍵字，你可以參考上面範例，接著使用 JavaScript 將其更改以切換對象狀態：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'.btn'</span>).bind(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="keyword">this</span>).attr(<span class="string">'data-state'</span>, <span class="string">'pressed'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="透過-pseudo-class-改變對象狀態"><a href="#透過-pseudo-class-改變對象狀態" class="headerlink" title="透過 pseudo-class 改變對象狀態"></a>透過 pseudo-class 改變對象狀態</h4><p>在 SMACSS 有提到請不要過度的使用 JavaScript 去控制對象的狀態，像是一些基本的轉換效果使用 CSS 中的 <code>:hover</code>、<code>:focus</code> 偽類可能是更好的選擇，如下範例：</p>
<!-- prettier-ignore-start -->
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="selector-class">.btn</span>:hover &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="selector-class">.btn</span>:focus &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn-default</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="selector-class">.btn-default</span>:hover &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-class">.is-pressed</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-class">.is-pressed</span>:hover &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn-default</span><span class="selector-class">.is-pressed</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="selector-class">.btn-default</span><span class="selector-class">.is-pressed</span>:hover &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<h4 id="透過-media-query-改變對象狀態"><a href="#透過-media-query-改變對象狀態" class="headerlink" title="透過 media query 改變對象狀態"></a>透過 media query 改變對象狀態</h4><p>除了透過 class 與偽類更改對象狀態以外，我們也可使用 media query 來完成同樣目的，以下範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.nav</span> &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (max-width: 400px) &#123;</span><br><span class="line">  <span class="selector-class">.nav</span> &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (max-width: 400px) &#123;</span><br><span class="line">  <span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: none;</span><br><span class="line">    <span class="attribute">width</span>: auto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以往我們會習慣把 <code>@media</code> 放在所有程式碼的最下方統一做管理，但在 SMACSS 的建議中，反而是希望把 <code>@media</code> 放在相關的程式碼下方，就像上面範例這樣，當然你可能會想，這樣不是會造成 <code>@media</code> 語句重複被撰寫嗎？比起程式碼大小，網頁中載入的靜態資源，比如圖片，這些才是真正會影響性能的關鍵，不然你看怎麼一般人都喜歡使用 <code>@mixin</code> 搭配 <code>@content</code> 來撰寫 RWD 內容？</p>
<h2 id="BEM-Block-Element-Modifier"><a href="#BEM-Block-Element-Modifier" class="headerlink" title="BEM (Block Element Modifier)"></a>BEM (Block Element Modifier)</h2><img src="https://i.imgur.com/VXNptuL.png" width="80%">

<p><a href="http://getbem.com/" target="_blank" rel="external nofollow noopener noreferrer">BEM</a> 主要由 <a href="https://tech.yandex.com/bem/" target="_blank" rel="external nofollow noopener noreferrer">Yandex</a> 公司所推出，其概念為透過命名方式將網頁獨立的區塊包裝成元件，有別於 OOCSS 或 SMACSS 需了解其中的組件化思維才能動作，BEM 透過最簡單且最直接的方式將原本抽象的組件化過程實踐在網頁裡頭，該方法論是基於三個要點所組成，分別為：</p>
<ul>
<li>Block：盡量以工具性質來命名對象<ul>
<li>例子：<code>.list</code>、<code>.card</code>、<code>.navbar</code></li>
</ul>
</li>
<li>Element：使用 <code>__</code> 兩個下劃線 (underline) 連接 Block 對象<ul>
<li>例子：<code>.list__item</code>、<code>.card__img</code>、<code>.navbar__brand</code></li>
</ul>
</li>
<li>Modifier：使用 <code>--</code> 兩個連字符 (hyphen) 連結 Block 或 Element 對象<ul>
<li>例子：<code>.list__item--active</code>、<code>.card__img--rounded</code>、<code>.navbar--dark</code></li>
</ul>
</li>
</ul>
<p>在 BEM 並沒有那些抽象的規則，任意對象都能透過其命名包裝成元件，且 BEM 是基於功能導向 (Function-Oriented Programming, FOP) 而設計的，不存在像是 <code>.pl-5</code> 這種難以理解的 class 名稱，為了保證 BEM 能夠合理的將對象模組化，請務必遵守以下規則：</p>
<ul>
<li>嚴禁使用 class 除外的選擇器撰寫樣式</li>
<li>不要過度模組化，應適當拿捏對象的模組化深度</li>
</ul>
<h3 id="Block-區塊"><a href="#Block-區塊" class="headerlink" title="Block 區塊"></a>Block 區塊</h3><p>所謂的 Block 是指網頁中可獨立存在的對象，你可以把它想像成 SMACSS 中的 Layout 或 Module，這邊稱其為區塊，參考以下範例：</p>
<ul>
<li>Block 名稱需能清楚的表達其用途、功能、意義，且具有唯一性</li>
<li>Block 可以放置在頁面上的任何位置，也可以互相嵌套</li>
<li>單詞之間可採小駝峰式或使用 <code>-</code> 將其分隔</li>
</ul>
<!-- prettier-ignore-start -->
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.navbar</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>還記得我們之前在 OOCSS 提到的結構與樣式分離嗎？這邊的 Block 就是指結構，Block 相比於 Element、Modifier，本身可獨立存在，不須依賴於任何對象。</p>
<h3 id="Element-元素"><a href="#Element-元素" class="headerlink" title="Element 元素"></a>Element 元素</h3><p>如果把區塊描述成元件，所謂的 Element 就是指依賴於此元件的子元件，參考以下範例：</p>
<ul>
<li>Element 名稱需能清楚的表達存在於元件的用途及意義性</li>
<li>Element 和 Element 之間可以彼此嵌套</li>
<li>Element 與 Block 之間使用 <code>__</code> 兩個下劃線 (underline) 連接</li>
<li>單詞之間可採小駝峰式或使用 <code>-</code> 將其分隔</li>
</ul>
<!-- prettier-ignore-start -->
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list__item</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card__img</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.navbar__brand</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header__title</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>這邊要注意，Element 無法獨立於 Block 之外，其存在的目的為子元件，元件既不存在何來的子元件？如果你使用的是 SCSS，可以改透過 <code>&amp;</code> 父選擇器來撰寫：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line"></span><br><span class="line">  &amp;__item &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">25%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這樣是不是快很多？且可讀性增加了不少，接著將樣式套用的 HTML 對象上：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>有沒有逐漸感受到 BEM 的魅力阿？我們不需要去背像是 SMACSS 這麼複雜的結構概念，成效也未必來的比較好，不覺得使用 BEM 輕鬆許多嗎？且能夠直接從 class 名稱就能得知其元件的結構性，這也是 BEM 相比於 SMACSS、OOCSS 更多人使用的原因。</p>
<hr>
<p>這邊補充關於 Element 彼此嵌套的案例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"list__item__link"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"list__item__link"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一個元件不太可能只有兩層結構，通常都具有三層以上的結構，此時如果使用 BEM 來撰寫，可能就會長的像上面這個樣子，但問題是這樣子的組件化處理會造成嵌套越來越深，導致 HTML 代碼相對醜陋，如果存在多級嵌套，可嘗試做以下修改：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"list__link"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"list__link"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>這意謂著所有的子元素都僅僅會被 <code>.list</code> 影響，<code>link</code> 不會被綁死在 <code>item</code> 下，代表 <code>link</code> 可自由放置在 <code>list</code> 的任何位置。</p>
<h3 id="Modifier-修飾子"><a href="#Modifier-修飾子" class="headerlink" title="Modifier 修飾子"></a>Modifier 修飾子</h3><p>Modifier 就如同 OOCSS 中的 Skin 與 SMACSS 中的 State，主要用來表述 Block 或 Element 的行為及外觀，參考以下範例：</p>
<ul>
<li>Modifier 名稱需能清楚表達對象外觀、狀態或行為</li>
<li>Modifier 與 Block 或 Element 之間使用 <code>--</code> 兩個連字符 (hyphen)</li>
<li>單詞之間可採小駝峰式或使用 <code>-</code> 將其分隔</li>
</ul>
<!-- prettier-ignore-start -->
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list__item--active</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card__img--rounded</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.navbar--dark</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header__title--size-s</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>Modifier 無法單獨存在，畢竟 Modifier 的出現必定是作用於某個對象，這邊所指的對象有可能為 Block 或 Element，如果你使用的是 SCSS，可以改透過 <code>&amp;</code> 父選擇器來撰寫：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line"></span><br><span class="line">  &amp;__item &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">25%</span>;</span><br><span class="line"></span><br><span class="line">    &amp;--active &#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#fffc3d</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &amp;--dark &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#272727</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常我們在使用 BEM 時，都會與 SCSS 搭配做使用，不管是效率還是可讀性都提升了不少，接著套用到 HTML 對象上</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list list--dark"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item list__item--active"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list__item"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>從結果可以很明顯看出其關聯性，在多人合作時，新接手這個項目的人也可以很容易從 class 名稱來分辨對象的元件結構，那些是 Block，那些是 Element，那些是 Modifier，並進一步推斷出哪部分的 HTML 可以獨立使用，這也就是 BEM 當初設立的初衷，你不需要花費很多的時間去了解像是 SMACSS、OOCSS 那種抽象的規則，BEM 用最直接的方式告訴你似乎一切不需要這麼複雜。</p>
<h3 id="Mix-混入"><a href="#Mix-混入" class="headerlink" title="Mix 混入"></a>Mix 混入</h3><p>Mix 並不是什麼 BEM 的概念，他算是一種處理方式，直接來看範例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"menu__list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"menu__item"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"menu__link"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn--primary"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>就像我們前面講的，Block 之間是可以互相嵌套的，這邊放置了由 <code>.btn</code> 與 <code>.btn--primary</code> 組成的按鈕，很明顯的 <code>.btn</code> 就是所指的 Block，假設我們想在這一個按鈕新增像是圓角的樣式，依照 Mix 會這樣處理：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"menu__list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"menu__item"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"menu__link"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn--primary menu__btn"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>之後在針對 <code>menu__btn</code> 撰寫圓角的樣式即可，Mix 想要表達的是在保持 Block 獨立存在的同時，也可以針對不同嵌套的 Block 做樣式的混入，但在這邊又一個問題是，<code>.menu__btn</code> 必須寫在 <code>.btn</code> 之前才能將其覆蓋並作用，如果依照 OOCSS 的概念，結構與樣式應該要徹底分離才對，此時可以這樣做：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"menu__list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"menu__item"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"menu__link"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn--primary btn--rounded"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>沒錯，就是直接在 <code>.btn</code> 新增一個 Modifier 樣式，這樣也就能確保 <code>.menu</code> 與 <code>.btn</code> 彼此沒有關連性，且依然能有其目的效果，雖然你的 Modifier 可能會隨著項目而增加，但不覺得這樣子的處理相比於 Mix 要來的更好嗎？各位可以自行參考看看。</p>
]]></content>
      <categories>
        <category>SCSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>SCSS</tag>
        <tag>w3HexSchool</tag>
        <tag>CSS Methodologies</tag>
      </tags>
  </entry>
  <entry>
    <title>Sass / SCSS 預處理器 - 自建 CSS 框架中的 Grid System 與 Spacing</title>
    <url>/2020-06-24-scss-gridsystem-spacing/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Grid System 可說是近年來前端工程師必備的一項技能，傳統上我們都是針對特定對象撰寫 media query 以達到 RWD 的效果，但對於可維護性及結構性來說，似乎這不是個好的做法，現在我們都會直接導入像是 Bootstrap 或 Tailwind 等 CSS 框架，利用內建的 Grid System 更有效率的撰寫出網站基底的 RWD 樣式，但這樣的問題是，在不考慮使用 PurgeCSS 或針對原始碼做刪減的情況下，我們將整個框架導入進來就為了使用 Grid System 會不會有點小題大作？不如我們自己來開發 Grid System 吧！</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>Grid System 建立及原理說明</li>
<li>Spacing 建立及原理說明</li>
</ul>
<h2 id="Grid-System-建立及原理說明"><a href="#Grid-System-建立及原理說明" class="headerlink" title="Grid System 建立及原理說明"></a>Grid System 建立及原理說明</h2><p>讓我們先來看 Bootstrap 4 中的 Grid System 是如何運作的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3 col-6"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3 col-6"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3 col-6"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3 col-6"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row no-gutters"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-6"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-6"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Bootstrap 在 v3 版本是使用 LESS 進行開發，當時的 Grid System 是以 <code>float</code> 撰寫而成，有用過 <code>float</code> 排版的人應該都知道其中的缺陷有多嚴重，而到了 v4 版本則是使用 SCSS 進行開發，並且使用了 <code>flexbox</code> 進行排版，這邊 <code>.row</code> 其實就是指 <code>flexbox</code> 控制子項目的父容器，<code>.container</code> 主要用來解決 <code>.row</code> 溢出問題及限制容器大小，<code>.col-*</code> 就是前面所指的子項目，有玩過 Bootstrap 的人應該都很熟悉了才對，在正式進入到開發環節時，請先完成 CSS Reset 及 <code>box-sizing</code> 的設置：</p>
<!-- prettier-ignore-start -->
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*, *:before, *:after &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>設置 <code>border-box</code> 的目的主要是讓我們在計算對象的大小時更為直覺，我想這應該是開發網站最基本的概念了，這邊就不多加以說明，接著我們來看 Grid System 是如何撰寫而成的：</p>
<div class="note warning">以下都是先以 Bootstrap 預設的 12 欄式排版做設計</div>

<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">1140px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.row</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: -<span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-6</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>製作 Grid System 最重要的就是 Gutter 的概念，所謂的 Gutter 就是指 <code>.col-*</code> 對象之間的間距，為了避免最左與最右邊的 Gutter 出現擠壓問題，我們必須在 <code>.row</code> 設置 <code>margin</code> 負值將容器給往外擴，這時會造成內容大小超出瀏覽器可視大小問題，進而導致 x 軸的產生，這對於 RWD 來說可是大忌，我們必須在 <code>.container</code> 設置 <code>padding</code> 將這一個負值補回，這就是我前面提到的 <code>.container</code> 不只可用來限制容器大小，還可用來將溢出的空間給補回，讓我們來看目前的效果如何：</p>
<p><img src="https://i.imgur.com/amWAcCl.png" alt="格線系統範例 - 1"></p>
<p>這邊我新增了 <code>.box</code> 樣式用以凸顯 Grid System 在畫面中呈現的感覺，你會發現與 Bootstrap 的結果是一模一樣的，目前我們只有撰寫 <code>.col-6</code> 樣式，代表只能完成兩欄式的排版，如果有其他欄式的要求，可分別在撰寫對應的樣式：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.col-2</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">16.66667%</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">16.66667%</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-3</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">25%</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">25%</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面我們都是基於 CSS 撰寫而成，通常我在建立 Grid System 時都會搭配 CSS 預處理器做開發，原因很簡單，不覺得一個一個撰寫對應的樣式很慢嗎？而且寬度都還要自己計算，想想就累，如果你有看我之前寫的 Sass 系列文章，此時你應該知道怎麼做了才對，參考以下範例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$gutter-width</span>: <span class="number">30px</span>;</span><br><span class="line"><span class="variable">$grid-sum</span>: <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">1140px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.row</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">margin-left</span>: -(<span class="variable">$gutter-width</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="attribute">margin-right</span>: -(<span class="variable">$gutter-width</span> / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">for</span> <span class="variable">$var</span> from 1 through <span class="variable">$grid-sum</span> &#123;</span><br><span class="line">  <span class="selector-class">.col-</span>#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">100%</span> * (<span class="variable">$var</span> / <span class="variable">$grid-sum</span>);</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> (<span class="number">100%</span> * (<span class="variable">$var</span> / <span class="variable">$grid-sum</span>));</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這邊我們順便把 Gutter 的寬度及 Grid 的總數設置成一個變數方便日後做更改，不覺得這樣快很多嗎？寬度我們也不需要自己計算，對應的 <code>.col-*</code> 樣式全靠 <code>@for</code> 迴圈來生成就好了，到這邊我們的 Grid System 就完成一半了，結果如下：</p>
<p><img src="https://i.imgur.com/Kopi695.png" alt="格線系統範例 - 2"></p>
<p>有時候我們不想要 <code>.row</code> 中的 <code>.col-*</code> 有任何的 Gutter，意思是 <code>.col-*</code> 樣式不必存在為了 Gutters 而設計的 <code>padding</code>，既然 <code>padding</code> 都被拿掉了，<code>.row</code> 中自然也就不必存在往外擴的 <code>margin</code>，讓我們來實作這段：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.no-gutters</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">0px</span>;</span><br><span class="line"></span><br><span class="line">  &gt; <span class="selector-attr">[class*='col-']</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>與 Bootstrap 的概念相同，往後只要在 <code>.row</code> 新增 <code>.no-gutters</code> 樣式，即可將 <code>.row</code> 本身的 <code>margin</code> 以及 <code>.row</code> 下一階層 class 名稱含有 <code>col-</code> 之對象 <code>padding</code> 通通給拿掉，這邊要注意屬性選擇器的寫法，我們採用了 <code>*=</code> 來匹配對象，到了後面我們會加上 <code>.col-md-6</code>、<code>.col-sm-4</code> 之類的具有 RWD 斷點的樣式名稱，利用 <code>*=</code> 能將所有字串帶有 <code>.col-</code> 之對象通通給包含進來，處理起來方便很多，接著再來看 <code>.container-fluid</code> 的部分：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container-fluid</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>.container</code> 除了補償 <code>.row</code> 造成的多餘空間以外，還有將整個區塊置中的目的，主要依靠 <code>max-width</code> 與 <code>margin</code> 來達成，但有時候我們想要製作滿版的效果，這時候就不能使用 <code>.container</code> 了，取而代之的是 <code>.container-fluid</code> 樣式，其實就只是將 <code>max-width</code> 修改為 <code>wisth: 100%</code> 而已，詳細可參考上方，接下來進行 RWD 斷點的部分：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$grid-breakpoints</span>: (</span><br><span class="line">  <span class="string">''</span>: false,</span><br><span class="line">  sm: <span class="number">576px</span>,</span><br><span class="line">  md: <span class="number">768px</span>,</span><br><span class="line">  lg: <span class="number">992px</span>,</span><br><span class="line">  xl: <span class="number">1200px</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$grid-breakpoints</span> &#123;</span><br><span class="line">  @<span class="keyword">for</span> <span class="variable">$var</span> from 1 through <span class="variable">$grid-sum</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> (not <span class="variable">$value</span>) &#123;</span><br><span class="line">      <span class="selector-class">.col-</span>#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">padding-left</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">        <span class="attribute">padding-right</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="selector-class">.col-</span>#&#123;<span class="variable">$key</span>&#125;-#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">padding-left</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">        <span class="attribute">padding-right</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bootstrap 主要以 Mobile First 而設計，我們可以參考她的思維進行打底的動作，所謂的打底其實就是指對象小於 <code>min-width</code> 所指定的數值時所呈現的樣貌，這邊我們宣告了 <code>$grid-breakpoints</code> 變數，並在下方利用 <code>@each</code> 與 <code>@for</code> 快速生成所有 <code>.col-*</code> 或 <code>.col-*-*</code> 對象，這樣子的處理方式會造成樣式大量重複的問題，進而造成樣式表異常肥大，這邊推薦改使用 <code>@extend</code> 與佔位符選擇器來處理：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">%<span class="selector-tag">col</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$grid-breakpoints</span> &#123;</span><br><span class="line">  @<span class="keyword">for</span> <span class="variable">$var</span> from 1 through <span class="variable">$grid-sum</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> not <span class="variable">$value</span> &#123;</span><br><span class="line">      <span class="selector-class">.col-</span>#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">        @<span class="keyword">extend</span> %col;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="selector-class">.col-</span>#&#123;<span class="variable">$key</span>&#125;-#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">        @<span class="keyword">extend</span> %col;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時生成的 CSS 會長的像這個樣子：</p>
<!-- prettier-ignore-start -->
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.col-1</span>, <span class="selector-class">.col-2</span>, <span class="selector-class">.col-3</span>, <span class="selector-class">.col-4</span>, <span class="selector-class">.col-5</span>, <span class="selector-class">.col-6</span>, <span class="selector-class">.col-7</span>, <span class="selector-class">.col-8</span>, <span class="selector-class">.col-9</span>, <span class="selector-class">.col-10</span>, <span class="selector-class">.col-11</span>, <span class="selector-class">.col-12</span>, <span class="selector-class">.col-sm-1</span>, <span class="selector-class">.col-sm-2</span>, <span class="selector-class">.col-sm-3</span>, <span class="selector-class">.col-sm-4</span>, <span class="selector-class">.col-sm-5</span>, <span class="selector-class">.col-sm-6</span>, <span class="selector-class">.col-sm-7</span>, <span class="selector-class">.col-sm-8</span>, <span class="selector-class">.col-sm-9</span>, <span class="selector-class">.col-sm-10</span>, <span class="selector-class">.col-sm-11</span>, <span class="selector-class">.col-sm-12</span>, <span class="selector-class">.col-md-1</span>, <span class="selector-class">.col-md-2</span>, <span class="selector-class">.col-md-3</span>, <span class="selector-class">.col-md-4</span>, <span class="selector-class">.col-md-5</span>, <span class="selector-class">.col-md-6</span>, <span class="selector-class">.col-md-7</span>, <span class="selector-class">.col-md-8</span>, <span class="selector-class">.col-md-9</span>, <span class="selector-class">.col-md-10</span>, <span class="selector-class">.col-md-11</span>, <span class="selector-class">.col-md-12</span>, <span class="selector-class">.col-lg-1</span>, <span class="selector-class">.col-lg-2</span>, <span class="selector-class">.col-lg-3</span>, <span class="selector-class">.col-lg-4</span>, <span class="selector-class">.col-lg-5</span>, <span class="selector-class">.col-lg-6</span>, <span class="selector-class">.col-lg-7</span>, <span class="selector-class">.col-lg-8</span>, <span class="selector-class">.col-lg-9</span>, <span class="selector-class">.col-lg-10</span>, <span class="selector-class">.col-lg-11</span>, <span class="selector-class">.col-lg-12</span>, <span class="selector-class">.col-xl-1</span>, <span class="selector-class">.col-xl-2</span>, <span class="selector-class">.col-xl-3</span>, <span class="selector-class">.col-xl-4</span>, <span class="selector-class">.col-xl-5</span>, <span class="selector-class">.col-xl-6</span>, <span class="selector-class">.col-xl-7</span>, <span class="selector-class">.col-xl-8</span>, <span class="selector-class">.col-xl-9</span>, <span class="selector-class">.col-xl-10</span>, <span class="selector-class">.col-xl-11</span>, <span class="selector-class">.col-xl-12</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>你可能會好奇為什麼是使用 <code>width</code> 而不是使用 <code>flex</code> 屬性指定大小，在 <code>flexbox</code> 中，如果你沒有撰寫 <code>flex</code> 屬性，優先會參考 <code>width</code> 指定的大小，如果同時撰寫 <code>width</code> 與 <code>flex</code> 屬性，此時會直接參考 <code>flex</code> 所撰寫的大小，代表 <code>flex</code> 權重是高於 <code>width</code> 屬性的，這邊你也可以寫成 <code>flex</code>，兩者在打底的動作是沒有任何差別的，接著進行斷點樣式的撰寫：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$grid-breakpoints</span> &#123;</span><br><span class="line">  @<span class="keyword">if</span> not <span class="variable">$value</span> &#123;</span><br><span class="line">    @<span class="keyword">for</span> <span class="variable">$var</span> from 1 to <span class="variable">$grid-sum</span> &#123;</span><br><span class="line">      <span class="selector-class">.col-</span>#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">        <span class="attribute">max-width</span>: <span class="number">100%</span> * (<span class="variable">$var</span> / <span class="variable">$grid-sum</span>);</span><br><span class="line">        <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> (<span class="number">100%</span> * (<span class="variable">$var</span> / <span class="variable">$grid-sum</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">    @<span class="keyword">media</span> screen and (min-width: <span class="variable">$value</span>) &#123;</span><br><span class="line">      @<span class="keyword">for</span> <span class="variable">$var</span> from 1 to <span class="variable">$grid-sum</span> &#123;</span><br><span class="line">        <span class="selector-class">.col-</span>#&#123;<span class="variable">$key</span>&#125;-#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">          <span class="attribute">max-width</span>: <span class="number">100%</span> * (<span class="variable">$var</span> / <span class="variable">$grid-sum</span>);</span><br><span class="line">          <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> (<span class="number">100%</span> * (<span class="variable">$var</span> / <span class="variable">$grid-sum</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這邊唯一要注意的是 <code>@media</code> 撰寫的位置，雖然說 Sass 會將 <code>@media</code> 額外給提取出來，但他提取的依據是以當前所在的位置去做參考，如果你把 <code>@media</code> 寫在 <code>@for</code> 迴圈內，他會重複生成 <code>@media</code> 語句，這樣就又造成樣式大量重複的問題了，這邊我是採用判斷的方式去做處理，這樣就不會有前面提到的問題了，還有一點要注意的是，這邊我們也連同不包含斷點的 <code>.col-*</code> 一併做處理了，代表最一開始那段 <code>@for</code> 迴圈可以拿掉了，最後我們的 Grid System 會長的像這個樣子：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$gutter-width</span>: <span class="number">30px</span>;</span><br><span class="line"><span class="variable">$grid-sum</span>: <span class="number">12</span>;</span><br><span class="line"><span class="variable">$grid-breakpoints</span>: (</span><br><span class="line">  <span class="string">''</span>: false,</span><br><span class="line">  sm: <span class="number">576px</span>,</span><br><span class="line">  md: <span class="number">768px</span>,</span><br><span class="line">  lg: <span class="number">992px</span>,</span><br><span class="line">  xl: <span class="number">1200px</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">1140px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container-fluid</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.row</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">margin-left</span>: -(<span class="variable">$gutter-width</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="attribute">margin-right</span>: -(<span class="variable">$gutter-width</span> / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.no-gutters</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">0px</span>;</span><br><span class="line"></span><br><span class="line">  &gt; <span class="selector-attr">[class*='col-']</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%<span class="selector-tag">col</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="variable">$gutter-width</span> / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$grid-breakpoints</span> &#123;</span><br><span class="line">  @<span class="keyword">for</span> <span class="variable">$var</span> from 1 through <span class="variable">$grid-sum</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> not <span class="variable">$value</span> &#123;</span><br><span class="line">      <span class="selector-class">.col-</span>#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">        @<span class="keyword">extend</span> %col;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="selector-class">.col-</span>#&#123;<span class="variable">$key</span>&#125;-#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">        @<span class="keyword">extend</span> %col;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$grid-breakpoints</span> &#123;</span><br><span class="line">  @<span class="keyword">if</span> not <span class="variable">$value</span> &#123;</span><br><span class="line">    @<span class="keyword">for</span> <span class="variable">$var</span> from 1 to <span class="variable">$grid-sum</span> &#123;</span><br><span class="line">      <span class="selector-class">.col-</span>#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">        <span class="attribute">max-width</span>: <span class="number">100%</span> * (<span class="variable">$var</span> / <span class="variable">$grid-sum</span>);</span><br><span class="line">        <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> (<span class="number">100%</span> * (<span class="variable">$var</span> / <span class="variable">$grid-sum</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">    @<span class="keyword">media</span> screen and (min-width: <span class="variable">$value</span>) &#123;</span><br><span class="line">      @<span class="keyword">for</span> <span class="variable">$var</span> from 1 to <span class="variable">$grid-sum</span> &#123;</span><br><span class="line">        <span class="selector-class">.col-</span>#&#123;<span class="variable">$key</span>&#125;-#&#123;<span class="variable">$var</span>&#125; &#123;</span><br><span class="line">          <span class="attribute">max-width</span>: <span class="number">100%</span> * (<span class="variable">$var</span> / <span class="variable">$grid-sum</span>);</span><br><span class="line">          <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> (<span class="number">100%</span> * (<span class="variable">$var</span> / <span class="variable">$grid-sum</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>當然這其中可能還有能夠優化的地方，比如說你可以把 <code>max-width</code> 與 <code>flex</code> 包裝成 <code>@mixin</code> 之類的，這些就留給大家去嘗試了，到這邊我們的 Grid System 就完成了，與 Bootstrap 中的 Grid System 操作可以說是幾乎一樣，短短的幾行代碼我們就打造出自己的 Grid System 了，有時候我不想要導入框架就會直接複製這裡的內容，讓我們以最一開始 Bootstrap 示範的那段 HTML 看看是否運行成功：</p>
<p><img src="https://i.imgur.com/boHC2GN.png" alt="格線系統範例 - 3"><br><img src="https://i.imgur.com/DRHX6Xo.png" alt="格線系統範例 - 4"></p>
<h2 id="Spacing-建立及原理說明"><a href="#Spacing-建立及原理說明" class="headerlink" title="Spacing 建立及原理說明"></a>Spacing 建立及原理說明</h2><p>既然我們都手刻出 Grid System 了，那麼順便把 Spacing 也給完成吧！Spacing 在 Bootstrap 是歸類在 Utilities 裡頭，幾乎在每個 Component 都可以看到它的身影，Bootstrap 是依造 OOCSS 撰寫而成的，自然就會有像是 <code>p-5</code>、<code>mt-3</code>、<code>my-1</code> 之類的抽象式樣式，這些就是所謂 Spacing，有效的利用 Spacing 將樣式給抽離出來，可大幅的提升元件的擴展性，讓我們直接開始吧：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$spacies</span>: (</span><br><span class="line">  <span class="string">'0'</span>: <span class="number">0px</span>,</span><br><span class="line">  <span class="string">'1'</span>: <span class="number">5px</span>,</span><br><span class="line">  <span class="string">'2'</span>: <span class="number">10px</span>,</span><br><span class="line">  <span class="string">'3'</span>: <span class="number">20px</span>,</span><br><span class="line">  <span class="string">'4'</span>: <span class="number">30px</span>,</span><br><span class="line">  <span class="string">'5'</span>: <span class="number">60px</span>,</span><br><span class="line">  <span class="string">'auto'</span>: auto,</span><br><span class="line">);</span><br><span class="line"><span class="variable">$property</span>: <span class="string">'m'</span>, <span class="string">'p'</span>;</span><br><span class="line"><span class="variable">$sides</span>: <span class="string">''</span>, <span class="string">'t'</span>, <span class="string">'b'</span>, <span class="string">'l'</span>, <span class="string">'r'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>;</span><br></pre></td></tr></table></figure>

<p>這邊我們先定義 <code>$spacing</code>、<code>$property</code>、<code>sides</code> 三個變數，<code>$spacing</code> 主要為間距的大小，你可以隨意新增或修改，<code>$property</code> 為作用的屬性，分別為 <code>margin</code> 與 <code>padding</code>，<code>sides</code> 為作用的方向，分別有 <code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>、<code>left</code> and <code>right</code>、<code>top</code> and <code>bottom</code> 等，其中空白代表四周都需作用的意思，這點 Bootstrap 的玩家應該很熟悉了才對，接著定義 RWD 斷點：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$grid-breakpoints</span>: (</span><br><span class="line">  <span class="string">''</span>: false,</span><br><span class="line">  sm: <span class="number">576px</span>,</span><br><span class="line">  md: <span class="number">768px</span>,</span><br><span class="line">  lg: <span class="number">992px</span>,</span><br><span class="line">  xl: <span class="number">1200px</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>你可以將所有的變數統一放置在 <code>_variables.scss</code> 做管理，這點在 7-1 模式中我們就曾經介紹過，接著開始撰寫 Spacing：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$grid-breakpoints</span> &#123;</span><br><span class="line">  @<span class="keyword">if</span> not <span class="variable">$value</span> &#123;</span><br><span class="line">    @<span class="keyword">each</span> <span class="variable">$pro</span> in <span class="variable">$property</span> &#123;</span><br><span class="line">      @<span class="keyword">each</span> <span class="variable">$side</span> in <span class="variable">$sides</span> &#123;</span><br><span class="line">        @<span class="keyword">each</span> <span class="variable">$spacKey</span>, <span class="variable">$spacValue</span> in <span class="variable">$spacies</span> &#123;</span><br><span class="line">          .#&#123;<span class="variable">$pro</span>&#125;#&#123;<span class="variable">$side</span>&#125;-#&#123;<span class="variable">$spacKey</span>&#125; &#123;</span><br><span class="line">            @<span class="keyword">include</span> generate(<span class="variable">$pro</span>, <span class="variable">$side</span>, <span class="variable">$spacValue</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">    @<span class="keyword">media</span> screen and (min-width: <span class="variable">$value</span>) &#123;</span><br><span class="line">      @<span class="keyword">each</span> <span class="variable">$pro</span> in <span class="variable">$property</span> &#123;</span><br><span class="line">        @<span class="keyword">each</span> <span class="variable">$side</span> in <span class="variable">$sides</span> &#123;</span><br><span class="line">          @<span class="keyword">each</span> <span class="variable">$spacKey</span>, <span class="variable">$spacValue</span> in <span class="variable">$spacies</span> &#123;</span><br><span class="line">            .#&#123;<span class="variable">$pro</span>&#125;#&#123;<span class="variable">$side</span>&#125;-#&#123;<span class="variable">$key</span>&#125;-#&#123;<span class="variable">$spacKey</span>&#125; &#123;</span><br><span class="line">              @<span class="keyword">include</span> generate(<span class="variable">$pro</span>, <span class="variable">$side</span>, <span class="variable">$spacValue</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其實方法與建構 Grid System 大同小異，都是將 map 或 list 的值給讀取出來，之後再看要怎麼操作，為了避免重複樣式的產生，這邊我使用到了 <code>@mixin</code> 的技巧：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> generate(<span class="variable">$pro</span>, <span class="variable">$side</span>, <span class="variable">$spacValue</span>) &#123;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">''</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'t'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-top</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-top</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'b'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-bottom</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-bottom</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'l'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-left</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-left</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'r'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-right</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-right</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'x'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-left</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">      <span class="attribute">margin-right</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-left</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">      <span class="attribute">padding-right</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'y'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-top</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">      <span class="attribute">margin-bottom</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-top</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">      <span class="attribute">padding-bottom</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我想應該還有更簡潔的寫法，這點一樣就留給大家去測試了，整體的 Spacing 長的會像這個樣子：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$spacies</span>: (</span><br><span class="line">  <span class="string">'0'</span>: <span class="number">0px</span>,</span><br><span class="line">  <span class="string">'1'</span>: <span class="number">5px</span>,</span><br><span class="line">  <span class="string">'2'</span>: <span class="number">10px</span>,</span><br><span class="line">  <span class="string">'3'</span>: <span class="number">20px</span>,</span><br><span class="line">  <span class="string">'4'</span>: <span class="number">30px</span>,</span><br><span class="line">  <span class="string">'5'</span>: <span class="number">60px</span>,</span><br><span class="line">  <span class="string">'auto'</span>: auto,</span><br><span class="line">);</span><br><span class="line"><span class="variable">$grid-breakpoints</span>: (</span><br><span class="line">  <span class="string">''</span>: false,</span><br><span class="line">  sm: <span class="number">576px</span>,</span><br><span class="line">  md: <span class="number">768px</span>,</span><br><span class="line">  lg: <span class="number">992px</span>,</span><br><span class="line">  xl: <span class="number">1200px</span>,</span><br><span class="line">);</span><br><span class="line"><span class="variable">$property</span>: <span class="string">'m'</span>, <span class="string">'p'</span>;</span><br><span class="line"><span class="variable">$sides</span>: <span class="string">''</span>, <span class="string">'t'</span>, <span class="string">'b'</span>, <span class="string">'l'</span>, <span class="string">'r'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">mixin</span> generate(<span class="variable">$pro</span>, <span class="variable">$side</span>, <span class="variable">$spacValue</span>) &#123;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">''</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'t'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-top</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-top</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'b'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-bottom</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-bottom</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'l'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-left</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-left</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'r'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-right</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-right</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'x'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-left</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">      <span class="attribute">margin-right</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-left</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">      <span class="attribute">padding-right</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="keyword">if</span> <span class="variable">$side</span> == <span class="string">'y'</span> &#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'m'</span> &#123;</span><br><span class="line">      <span class="attribute">margin-top</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">      <span class="attribute">margin-bottom</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$pro</span> == <span class="string">'p'</span> &#123;</span><br><span class="line">      <span class="attribute">padding-top</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">      <span class="attribute">padding-bottom</span>: <span class="variable">$spacValue</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$grid-breakpoints</span> &#123;</span><br><span class="line">  @<span class="keyword">if</span> not <span class="variable">$value</span> &#123;</span><br><span class="line">    @<span class="keyword">each</span> <span class="variable">$pro</span> in <span class="variable">$property</span> &#123;</span><br><span class="line">      @<span class="keyword">each</span> <span class="variable">$side</span> in <span class="variable">$sides</span> &#123;</span><br><span class="line">        @<span class="keyword">each</span> <span class="variable">$spacKey</span>, <span class="variable">$spacValue</span> in <span class="variable">$spacies</span> &#123;</span><br><span class="line">          .#&#123;<span class="variable">$pro</span>&#125;#&#123;<span class="variable">$side</span>&#125;-#&#123;<span class="variable">$spacKey</span>&#125; &#123;</span><br><span class="line">            @<span class="keyword">include</span> generate(<span class="variable">$pro</span>, <span class="variable">$side</span>, <span class="variable">$spacValue</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">    @<span class="keyword">media</span> screen and (min-width: <span class="variable">$value</span>) &#123;</span><br><span class="line">      @<span class="keyword">each</span> <span class="variable">$pro</span> in <span class="variable">$property</span> &#123;</span><br><span class="line">        @<span class="keyword">each</span> <span class="variable">$side</span> in <span class="variable">$sides</span> &#123;</span><br><span class="line">          @<span class="keyword">each</span> <span class="variable">$spacKey</span>, <span class="variable">$spacValue</span> in <span class="variable">$spacies</span> &#123;</span><br><span class="line">            .#&#123;<span class="variable">$pro</span>&#125;#&#123;<span class="variable">$side</span>&#125;-#&#123;<span class="variable">$key</span>&#125;-#&#123;<span class="variable">$spacKey</span>&#125; &#123;</span><br><span class="line">              @<span class="keyword">include</span> generate(<span class="variable">$pro</span>, <span class="variable">$side</span>, <span class="variable">$spacValue</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到這邊就完成我們的 Spacing 了，往後如果不需要某個特定斷點或者特定間距的 Spacing 時，也只需要註解調就可以了，簡直超方便，讓我們來看實際運行的狀況：</p>
<p><img src="https://i.imgur.com/eRuqgrM.png" alt="Spacing 運行結果 - 1"><br><img src="https://i.imgur.com/WyeEJtt.png" alt="Spacing 運行結果 - 2"><br><img src="https://i.imgur.com/aWtG6wO.png" alt="Spacing 運行結果 - 3"></p>
]]></content>
      <categories>
        <category>SCSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>SCSS</tag>
        <tag>Bootstrap</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 前端打包工具 - 使用 dotenv-webpack 設置全局變量</title>
    <url>/2020-06-29-webpack-dotenvwebpack/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Webpack 中我們會使用 DefinePlugin 或 EnvironmentPlugin 來設置全局變量，以提供 entry 內的模組針對這一個變數快速做響應，但有一點困擾我們的是，這兩個 Plugin 撰寫的全局變量都是屬於顯式性質的，代表任何人都能從所撰寫的位置得知這一個全局變量，如果情況發生在尚未發布的專案，有心人就可利用這一個變量，通常為測試主機位址，進一步做攻擊的動作，在後端我們會使用 dotenv 套件，前端可使用 dotenv-webpack 套件，屬 DefinePlugin 與 dotenv 的包裝，進一步將變量中的敏感信息隱藏起來。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>dotenv-webpack 安裝</li>
<li>dotenv-webpack 基本使用</li>
<li>dotenv-webpack 可傳遞選項</li>
<li>補充：cross-env 與 dotenv-webpack 差別</li>
</ul>
<h2 id="dotenv-webpack-安裝"><a href="#dotenv-webpack-安裝" class="headerlink" title="dotenv-webpack 安裝"></a>dotenv-webpack 安裝</h2><blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/dotenv-webpack" target="_blank" rel="external nofollow noopener noreferrer">dotenv-webpack</a></p>
</blockquote>
<p>主要的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install dotenv-webpack -D</span><br></pre></td></tr></table></figure>

<p>package.json：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"dotenv-webpack"</span>: <span class="string">"^1.8.0"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.43.0"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.12"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dotenv-webpack 屬 DefinePlugin 與 dotenv 的包裝，這兩個套件都不需要額外進行安裝，其中的 DefinePlugin 是 Webpack 本身就存在的套件，而 dotenv 則是 dotenv-webpack 的相依套件，嚴格來講是 dotenv-default 的相依套件。</p>
<h2 id="dotenv-webpack-基本使用"><a href="#dotenv-webpack-基本使用" class="headerlink" title="dotenv-webpack 基本使用"></a>dotenv-webpack 基本使用</h2><p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── main.js          # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── webpack.config.js    # Webpack 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure>

<p>前面我們先來看 DefinePlugin 與 EnvironmentPlugin 是如何設置全局變量的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      API_URL: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>這邊要注意，上面 DefinePlugin 中的 value 寫法是錯誤的，可參考以下示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 讀取</span></span><br><span class="line"><span class="built_in">console</span>.log(API_URL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 結果</span></span><br><span class="line"><span class="built_in">console</span>.log(http:<span class="comment">//localhost:3000);</span></span><br></pre></td></tr></table></figure>

<p>DefinePlugin 會將編譯範圍內的全局變量 key 替換成對應的 value，這邊的替換是指原封不動的進行替換，此時可能就會造成像上面這樣子的結果，建議透過 <code>JSON.stringify()</code> 來完成予值動作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      API_URL: <span class="built_in">JSON</span>.stringify(<span class="string">'http://localhost:3000'</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此時就能確保編譯後的結果如預期：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'http://localhost:3000'</span>);</span><br></pre></td></tr></table></figure>

<p>很明顯的 DefinePlugin 有著不直覺的設計，這才有了後來的 EnvironmentPlugin 出現：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.EnvironmentPlugin(&#123;</span><br><span class="line">      API_URL: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面等效於以下 DefinePlugin 的寫法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env.API_URL'</span>: <span class="built_in">JSON</span>.stringify(<span class="string">'http://localhost:3000'</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>是不是很酷？在 EnvironmentPlugin 宣告的全局變量始終都會有 <code>process.env</code> 字串符前綴，這邊的 <code>process.env</code> 並不是指環境變數，如果你到 <code>process.env</code> 底下是找不到 <code>API_URL</code> 這個對象的，加入 <code>process.env</code> 的目的在於模擬環境變數的使用，這邊我們也不需要手動加入 <code>JSON.stringify()</code> 語法，EnvironmentPlugin 會自動幫我們添加，可參考以下示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 讀取</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.API_URL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 結果</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'http://localhost:3000'</span>);</span><br></pre></td></tr></table></figure>

<p>跑過 DefinePlugin 與 EnvironmentPlugin 你會發現兩者所撰寫的全局變量都是屬於顯示性質的，假設你將此專案推至 GitHub 等遠端 Repository 並將其設為公開，任何人都能在 Webpack 配置檔看到這些全局變量，這是很危險的一件事，這時候就是 dotenv-webpack 出場的時候了，配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 載入 dotenv-webpack (第一步)</span></span><br><span class="line"><span class="keyword">const</span> Dotenv = <span class="built_in">require</span>(<span class="string">'dotenv-webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 創建實例 (第二步)</span></span><br><span class="line">    <span class="keyword">new</span> Dotenv(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>配置 dotenv-webpack 相當簡單，與其他 Webpack Plugin 大同小異，在 dotenv-webpack 內部有一個可傳遞選項名為 <code>path</code>，預設指向 <code>./.env</code> 這支檔案，這也是我們設置全局變量的地方，請先新增名為 <code>.env</code> 的檔案：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> webpack-demo/</span><br><span class="line"> │</span><br><span class="line"><span class="addition">+└─── .env</span></span><br></pre></td></tr></table></figure>

<p>配置方法如同後端的 dotenv 套件，參考以下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">API_URL &#x3D; http:&#x2F;&#x2F;localhost:3000</span><br></pre></td></tr></table></figure>

<p>目前我們就只是將全局變量額外撰寫至 <code>.env</code> 檔內，為了達到隱藏的目的可將 <code>.env</code> 檔案新增至 <code>.gitignore</code> 內，這樣就能避免 GitHub 存在任何顯式型態的全局變量，接著來說明 <code>.env</code> 檔內的全局變量該如何做使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 讀取</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.API_URL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 結果</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'http://localhost:3000'</span>);</span><br></pre></td></tr></table></figure>

<p>畢竟 dotenv-webpack 屬 DefinePlugin 與 dotenv 的包裝，取用的方法自然就跟 DefinePlugin 很像，優點是少了 DefinePlugin 那些不直覺的設計，dotenv-webpack 內部與 EnvironmentPlugin 差不多，都已經幫我們處理好 <code>process.env</code> 與 <code>JSON.stringify()</code> 的問題，凡是在 <code>.env</code> 設置的全局變量，一律都是使用 <code>process.env.XXX</code> 將其讀取，這邊唯一要注意的是 <code>.env</code> 設置的全局變量都是屬於字串型態，在某些情況下我們得自己處理轉型的問題。</p>
<p>這邊做個補充，在 <code>.env</code> 撰寫的全局變量嚴格來講並不屬於隱式型態，畢竟在前端沒有所謂的隱式說法，最後還是會透過打包暴露給引用對象，凡是有基礎底子的人都能透過原始碼推測全局變量的內容值，dotenv-webpack 所能做的就是限制全局變量的暴露關係，只將代碼中顯示引用的全局變量暴露給最終綑綁包，代表未經引用的變量將被拋棄，任何人都無法查看這一個變量內容。</p>
<h2 id="dotenv-webpack-可傳遞選項"><a href="#dotenv-webpack-可傳遞選項" class="headerlink" title="dotenv-webpack 可傳遞選項"></a>dotenv-webpack 可傳遞選項</h2><p>可參考 <a href="https://www.npmjs.com/package/dotenv-webpack#properties" target="_blank" rel="external nofollow noopener noreferrer">dotenv-webpack Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li><p>path：<code>String</code><br>配置全局變量的位置，默認為 <code>./.env</code></p>
</li>
<li><p>systemvars：<code>Boolean</code><br>允許加載所有系統變量，包含 cross-env 設置的變量，默認為 <code>false</code></p>
</li>
</ul>
<p>範例：</p>
<!-- prettier-ignore-start -->
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Dotenv = <span class="built_in">require</span>(<span class="string">"dotenv-webpack"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> Dotenv(&#123;</span><br><span class="line">      path:</span><br><span class="line">        process.env.NODE_ENV === <span class="string">"development"</span></span><br><span class="line">          ? <span class="string">"./.env.development"</span></span><br><span class="line">          : <span class="string">"./.env.production"</span>,</span><br><span class="line">      systemvars: <span class="literal">true</span>, <span class="comment">// 允許讀取 process.env 下的任意系統變量</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<h2 id="補充：cross-env-與-dotenv-webpack-差別"><a href="#補充：cross-env-與-dotenv-webpack-差別" class="headerlink" title="補充：cross-env 與 dotenv-webpack 差別"></a>補充：cross-env 與 dotenv-webpack 差別</h2><p>這邊補充關於 cross-env 與 dotenv-webpack 的差別，嚴格來講是比較 cross-env 與 DefinePlugin 的差別，畢竟 dotenv-webpack 與 EnvironmentPlugin 都是基於 DefinePlugin 所設計，前面已經安裝過 dotenv-webpack 了，這邊將 cross-env 也給安裝進來：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install cross-env -D</span><br></pre></td></tr></table></figure>

<p>接著在 <code>package.json</code> 新增 <code>cross-env</code> 指令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"cross-env NODE_ENV=development webpack"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"cross-env NODE_ENV=production webpack"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前我們有提到使用 cross-env 的目的在於兼容各平台的環境變數設置，畢竟在 Windows 系統下是無法直接像 <code>NODE_ENV=development</code> 這樣設置環境變數的，這時候就牽扯到一個問題了，那就是這個環境變數取用的範圍是到哪裡？直接來看範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./webpack.config.js</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.NODE_ENV); <span class="comment">// development</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./src/main.js</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.NODE_ENV); <span class="comment">// development</span></span><br></pre></td></tr></table></figure>

<p>這時你可能會認為 cross-env 設置的環境變數可在任何地方做使用，代表運行環境與編譯環境都能讀取到值，這其實是錯誤的觀念，你可以嘗試將 cross-env 的變量更改為如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"cross-env NODE_ENV=development USER_NAME=Roya webpack"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"cross-env NODE_ENV=production USER_NAME=Eric webpack"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接著讀取環境變量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./webpack.config.js</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.NODE_ENV); <span class="comment">// development</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.USER_NAME); <span class="comment">// Roya</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./src/main.js</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.NODE_ENV); <span class="comment">// development</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.USER_NAME); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>發現到神奇的地方了嗎？除了 <code>NODE_ENV</code> 變量以外，其它變量在編譯環境都讀不到值，這邊的編譯環境是指 entry 入口引入的那些模組，比如說 <code>./src/main.js</code>，而運行環境就是指除此之外的那些檔案，比如說 <code>./webpack.config.js</code>，這邊的 <code>NODE_ENV</code> 變量其實不是由 cross-env 設置的，而是我們在設置 <code>mode</code> 選項時，Webpack 自動使用 DefinePlugin 設置的，參考以下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env.NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(<span class="string">'&lt;當前環境&gt;'</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以我們可以得出的結論是，<strong>使用 cross-env 設置的環境變量只能在運行環境讀取到其值</strong>，在編譯環境是無法讀取到值的，較常使用在 <code>webpack.config.js</code> 做為邏輯的判斷。</p>
<p>看完了 cross-env 的介紹，接著來看 DefinePlugin 設置的變量範圍：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env.USER_NAME'</span>: <span class="built_in">JSON</span>.stringify(<span class="string">'Roya'</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如同我們前面所說，上面寫法等效於以下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.EnvironmentPlugin(&#123;</span><br><span class="line">      USER_NAME: <span class="string">'Roya'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也等效於 dotenv-webpack 的寫法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USER_NAME &#x3D; Roya</span><br></pre></td></tr></table></figure>

<p>接著讀取全局變量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./webpack.config.js</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.USER_NAME); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./src/main.js</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.USER_NAME); <span class="comment">// Roya</span></span><br></pre></td></tr></table></figure>

<p>很明顯的 <strong>DefinePlugin、EnvironmentPlugin、dotenv-webpack 設置的全局變量都只存在於編譯環境內</strong>，畢竟要先有編譯的這個動作，Webpack 才能將這些變量注入進去，這點蠻合理的，這也是我前面強調這些方法屬於全局變量但不屬於環境變量的原因。</p>
<p>基於 cross-env 設置的變量是屬於環境變量，代表變量是掛載到 <code>process.env</code> 物件下，假設你使用的是 dotenv-webpack 設置變量，可開啟 <code>systemvars</code> 選項，這時編譯環境內就能夠讀取到 cross-env 設置的環境變量，可參考以下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> Dotenv(&#123;</span><br><span class="line">      systemvars: <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不須在 <code>.env</code> 設置全局變數，直接讀取 cross-env 設置的環境變量即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.env.USER_NAME);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>w3HexSchool</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 前端打包工具 - 使用 optimize-css-assets-webpack-plugin 壓縮 CSS</title>
    <url>/2020-07-06-webpack-optimizecssassetswebpackplugin/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前我們有提到如何使用 html-webpack-plugin 內建的 minify 選項壓縮 HTML，而 JavaScript 則是依靠 Webpack 本身內建的 TerserWebpackPlugin 進行壓縮，唯獨少了 CSS 的方法，這次就來介紹如何使用 optimize-css-assets-webpack-plugin 壓縮我們的 CSS，其內部預設是使用 cssnano 作為編譯器，cssnano 是建立在 PostCSS 生態系統上的工具，代表我們也可使用 postcss-loader 搭配 cssnano 來達到同樣的目的及效果，如果專案本身已導入 PostCSS，建議直接搭配 cssnano 可更快的完成壓縮目的。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>optimize-css-assets-webpack-plugin 安裝</li>
<li>optimize-css-assets-webpack-plugin 基本使用</li>
<li>optimize-css-assets-webpack-plugin 可傳遞選項</li>
<li>補充：搭配 mini-css-extract-plugin 生成 source-map 失敗</li>
<li>補充：使用 postcss-loader 搭配 cssnano 進行壓縮</li>
</ul>
<h2 id="optimize-css-assets-webpack-plugin-安裝"><a href="#optimize-css-assets-webpack-plugin-安裝" class="headerlink" title="optimize-css-assets-webpack-plugin 安裝"></a>optimize-css-assets-webpack-plugin 安裝</h2><blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/optimize-css-assets-webpack-plugin" target="_blank" rel="external nofollow noopener noreferrer">optimize-css-assets-webpack-plugin</a></p>
</blockquote>
<p>主要的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install optimize-css-assets-webpack-plugin -D</span><br></pre></td></tr></table></figure>

<p>過程會使用到的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install css-loader mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure>

<p>package.json：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^3.6.0"</span>,</span><br><span class="line">    <span class="attr">"mini-css-extract-plugin"</span>: <span class="string">"^0.9.0"</span>,</span><br><span class="line">    <span class="attr">"optimize-css-assets-webpack-plugin"</span>: <span class="string">"^5.0.3"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.43.0"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.12"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>optimize-css-assets-webpack-plugin 只是用來將 CSS 給進行壓縮，實際處理 CSS 的動作還是得交由 css-loader 和 mini-css-extract-plugin 來完成，這邊你不需要下載 cssnano，此為 optimize-css-assets-webpack-plugin 的相依套件，為了保證壓縮如預期進行，官方已經幫我們包裝好了。</p>
<h2 id="optimize-css-assets-webpack-plugin-基本使用"><a href="#optimize-css-assets-webpack-plugin-基本使用" class="headerlink" title="optimize-css-assets-webpack-plugin 基本使用"></a>optimize-css-assets-webpack-plugin 基本使用</h2><p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.css      # CSS 主檔案</span><br><span class="line">│   │</span><br><span class="line">│   └─── main.js          # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── webpack.config.js    # Webpack 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure>

<p>撰寫 CSS 範例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-danger</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="comment">// 載入 optimize-css-assets-webpack-plugin (第一步)</span></span><br><span class="line"><span class="keyword">const</span> OptimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/[name].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 創建實例 (第二步)</span></span><br><span class="line">    <span class="keyword">new</span> OptimizeCssAssetsPlugin(&#123;</span><br><span class="line">      <span class="comment">// 傳入編譯器可傳遞選項 (可選)</span></span><br><span class="line">      cssProcessorPluginOptions: &#123;</span><br><span class="line">        preset: [<span class="string">'default'</span>, &#123; <span class="attr">discardComments</span>: &#123; <span class="attr">removeAll</span>: <span class="literal">true</span> &#125; &#125;],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>optimize-css-assets-webpack-plugin 預設的編譯器為 cssnano，如果你想針對這一個編譯器傳入選項，這邊可使用 <code>cssProcessorPluginOptions</code> 屬性，方法就如同你在 <code>postcss.config.js</code> 內設置的那樣，記得格式不要寫錯，單純修改 <code>preset</code> 可採 <code>String</code> 的形式，如果想將選項傳遞進去，則須修改為 <code>Array</code> 的形式，詳細可參考 <a href="https://cssnano.co/guides/presets" target="_blank" rel="external nofollow noopener noreferrer">cssnano</a> 的說明。</p>
<p>entry 入口處 (<code>src/main.js</code>) 引入 CSS 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./css/all.css'</span>; <span class="comment">// 使用 ESM 方式引入</span></span><br></pre></td></tr></table></figure>

<p>至 <code>package.json</code> 新增編譯指令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --mode development"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行編譯指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>檢查 <code>./dist/css/all.css</code> 是否成功被壓縮：</p>
<!-- prettier-ignore-start -->
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span>&#123;<span class="attribute">color</span>:<span class="number">#00f</span>&#125;<span class="selector-class">.text-danger</span>&#123;<span class="attribute">color</span>:red&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>大公告成！目前我們壓縮的配置都是參照 cssnano 中的 <code>default</code> 模式，另外還有 <code>advanced</code> 模式可做使用，這點將在下方 postcss-loader 結合 cssnano 的章節共同做介紹。</p>
<h2 id="optimize-css-assets-webpack-plugin-可傳遞選項"><a href="#optimize-css-assets-webpack-plugin-可傳遞選項" class="headerlink" title="optimize-css-assets-webpack-plugin 可傳遞選項"></a>optimize-css-assets-webpack-plugin 可傳遞選項</h2><p>可參考 <a href="https://www.npmjs.com/package/optimize-css-assets-webpack-plugin#configuration" target="_blank" rel="external nofollow noopener noreferrer">optimize-css-assets-webpack-plugin Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li><p>assetNameRegExp：<code>RegExp</code><br>指示應壓縮的資源，默認為 <code>/\.css$/g</code></p>
</li>
<li><p>cssProcessor：<code>Compiler</code><br>用於處理壓縮的編譯器，默認為 <code>cssnano</code></p>
</li>
<li><p>cssProcessorOptions：<code>Object</code><br>將選項傳遞給 cssProcessor 的接口，默認為 <code>{}</code></p>
</li>
<li><p>cssProcessorPluginOptions：<code>Object</code><br>將選項傳遞給 cssProcessor 中 plugin 的接口，默認為 <code>{}</code></p>
</li>
</ul>
<p>說實在的，我不太能理解作者可傳遞選項的命名方式，這邊的 <code>cssProcessorOptions</code> 應該是要指 <code>cssProcessor</code> 的可傳遞選項才對，結果卻是傳入不包含 <code>plugins</code> 的 PostCSS 選項，詳細可參考 PostCSS 中的 <a href="https://github.com/postcss/postcss#options" target="_blank" rel="external nofollow noopener noreferrer">options</a>，直接來看範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> OptimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> OptimizeCssAssetsPlugin(&#123;</span><br><span class="line">      assetNameRegExp: <span class="regexp">/\.css$/g</span>,</span><br><span class="line">      cssProcessor: <span class="built_in">require</span>(<span class="string">'cssnano'</span>),</span><br><span class="line">      cssProcessorOptions: &#123;</span><br><span class="line">        map: &#123;</span><br><span class="line">          inline: <span class="literal">false</span>,</span><br><span class="line">          annotation: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      cssProcessorPluginOptions: &#123;</span><br><span class="line">        preset: <span class="string">'default'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="補充：搭配-mini-css-extract-plugin-生成-source-map-失敗"><a href="#補充：搭配-mini-css-extract-plugin-生成-source-map-失敗" class="headerlink" title="補充：搭配 mini-css-extract-plugin 生成 source-map 失敗"></a>補充：搭配 mini-css-extract-plugin 生成 source-map 失敗</h2><p>這套件有個詭異的地方在於使用 optimize-css-assets-webpack-plugin 搭配 mini-css-extract-plugin 會導致 source-map 生成失敗，先讓我們來模擬下情境：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> OptimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devtool: <span class="string">'source-map'</span>, <span class="comment">// 選擇生成實體 .map 文件</span></span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: <span class="literal">true</span>, <span class="comment">// 開啟 sourcemap 支持</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/[name].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> OptimizeCssAssetsPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>關於 source-map 的使用可參考我之前寫過的 <a href="https://awdr74100.github.io/2020-04-02-webpack-devtool/">文章</a>，接著進行編譯：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>編譯結果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── main.css</span><br><span class="line">│   │</span><br><span class="line">│   └─── js&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       ├─── main.js</span><br><span class="line">│       └─── main.js.map</span><br></pre></td></tr></table></figure>

<p>發現特別的地方了嗎？我們的 CSS 並沒有成功生成 <code>.map</code> 檔案，自然也就沒有 source-map 的效果，如果你把 optimize-css-assets-webpack-plugin 給拿掉，source-map 就生出來了，這很明顯是這個套件的問題，但也不用太過於擔心，這個問題不是只有我們遇到，且 GitHub 已經有人給出答案了，詳細可參考 <a href="https://github.com/NMFR/optimize-css-assets-webpack-plugin/issues/53" target="_blank" rel="external nofollow noopener noreferrer">Issues</a>，這邊需要使用到前面提到了 <code>cssProcessorOptions</code> 選項，參考以下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> OptimizeCssAssetsPlugin(&#123;</span><br><span class="line">      cssProcessorOptions: &#123;</span><br><span class="line">        map: &#123;</span><br><span class="line">          inline: <span class="literal">false</span>,</span><br><span class="line">          annotation: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>將 <code>inline</code> 設為 <code>false</code> 的用意是避免生成內聯映射，這樣就能正確生成 <code>.map</code> 文件了，以及將 <code>annotation</code> 設為 true 用以向 <code>.css</code> 文件添加 source-map 的路徑註釋，讓我們在編譯一次：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       ├─── main.css</span><br><span class="line">│       └─── main.css.map</span><br><span class="line">│   │</span><br><span class="line">│   └─── js&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       ├─── main.js</span><br><span class="line">│       └─── main.js.map</span><br></pre></td></tr></table></figure>

<p>這次 CSS 的 source-map 就成功生成了，以上是在將 <code>devtool</code> 設為 <code>source-map</code> 時才需要這樣做，在 development 環境推薦使用的 <code>cheap-module-eval-source-map</code> 則有不同的做法，參考以下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> OptimizeCssAssetsPlugin(&#123;</span><br><span class="line">      cssProcessorOptions: &#123;</span><br><span class="line">        map: &#123;</span><br><span class="line">          inline: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>cheap-module-eval-source-map</code> 為內聯模式，代表我們須將 <code>inline</code> 設為 <code>true</code>，這時你可能就有疑問了，<code>true</code> 不是默認選項嗎？我們還需要設置？答案是沒錯，<a href="https://github.com/postcss/postcss/blob/master/docs/source-maps.md#options" target="_blank" rel="external nofollow noopener noreferrer">官方文檔</a> 有提到如果以前的 source-map 類型為外部地圖，而不是內聯地圖，則即使你未設置 <code>inline</code> 選項，PostCSS 也不會嵌入地圖，你可以把它理解為使用 mini-css-extract-plugin 生成實體 CSS 檔案，就是必須告訴她 <code>inline</code> 要為 <code>true</code>，不然會導致失敗，如果你使用的是 style-loader，就都沒這些問題，因為 style-loader 始終都為內聯地圖，並不會有 <code>.css</code> 實體檔案的產生。</p>
<h2 id="補充：使用-postcss-loader-搭配-cssnano-進行壓縮"><a href="#補充：使用-postcss-loader-搭配-cssnano-進行壓縮" class="headerlink" title="補充：使用 postcss-loader 搭配 cssnano 進行壓縮"></a>補充：使用 postcss-loader 搭配 cssnano 進行壓縮</h2><p>如果當前專案本身就已經導入 PostCSS，那我推薦你直接使用 cssnano 來完成壓縮，過程也不會像 optimize-css-assets-webpack-plugin 這麼多陷阱，請先將 postcss-loader 與 cssnano 安裝進來：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install postcss-loader cssnano -D</span><br></pre></td></tr></table></figure>

<p>cssnano 為 optimize-css-assets-webpack-plugin 的相依套件，這邊可以先檢查 <code>node_modules</code> 是否存在這個套件，或者直接將其覆蓋也是可以，接著將 postcss-loader 給配置進來：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devtool: <span class="string">'source-map'</span>,</span><br><span class="line">  mode: process.env.NODE_ENV,</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 新增 postcss-loader</span></span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: <span class="literal">true</span>, <span class="comment">// 開啟 sourcemap 支持</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/[name].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>這邊我們可把與 optimize-css-assets-webpack-plugin 相關的代碼都給拿掉，我們不需要它了，我個人是偏好在獨立的 <code>postcss.config.js</code> 檔案內撰寫 PostCSS 設定，你也可以在 postcss-loader 中的 <code>options</code> 下進行撰寫，隨看個人喜好，參考以下：</p>
<p>在 <code>./</code> 根目錄新增名為 <code>postcss.config.js</code> 的檔案：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> webpack-demo/</span><br><span class="line"> │</span><br><span class="line"><span class="addition">+└─── postcss.config.js</span></span><br></pre></td></tr></table></figure>

<p>將相關 plugin 載入進來：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [<span class="built_in">require</span>(<span class="string">'cssnano'</span>)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有關 plugin 的傳遞選項可由後方帶入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'cssnano'</span>)(&#123;</span><br><span class="line">      preset: [<span class="string">'default'</span>, &#123; <span class="attr">discardComments</span>: &#123; <span class="attr">removeAll</span>: <span class="literal">true</span> &#125; &#125;],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果你配置過 autoprefixer，那你應該對上面過程很熟悉才對，兩者都屬於 PostCSS 中的 Plugin，配置方法自然也就都差不多，接著直接進行編譯：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>檢查是否成功壓縮：</p>
<!-- prettier-ignore-start -->
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-primary</span>&#123;<span class="attribute">color</span>:<span class="number">#00f</span>&#125;<span class="selector-class">.text-danger</span>&#123;<span class="attribute">color</span>:red;<span class="attribute">display</span>:flex&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<p>檢查是否成功生成 <code>.map</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── dist&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       ├─── main.css</span><br><span class="line">│       └─── main.css.map</span><br><span class="line">│   │</span><br><span class="line">│   └─── js&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       ├─── main.js</span><br><span class="line">│       └─── main.js.map</span><br></pre></td></tr></table></figure>

<p>這不就與使用 optimize-css-assets-webpack-plugin 的結果一樣嗎？且我們不需要去操心 <code>inline</code> 之類的選項，過程簡單許多，這邊補充之前提到的 <code>advanced</code> 模式：</p>
<p>安裝高級優化組件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install cssnano-preset-advanced</span><br></pre></td></tr></table></figure>

<p>更改 cssnano 中的 <code>preset</code> 選項：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'cssnano'</span>)(&#123;</span><br><span class="line">      preset: <span class="string">'advanced'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>關於 <code>default</code> 與 <code>advanced</code> 的差異，詳細可參考 <a href="https://cssnano.co/optimisations/" target="_blank" rel="external nofollow noopener noreferrer">這邊</a>，簡單來講就是啟用更深層的優化，但可能會有更改原始代碼的情況發生。請斟酌使用。</p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Node.js</tag>
        <tag>PostCSS</tag>
        <tag>w3HexSchool</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 前端打包工具 - 使用 prerender-spa-plugin 預渲染單頁應用</title>
    <url>/2020-07-13-webpack-prerenderspaplugin/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通常我們在將一個專案改為目前流行的 SPA (Single-page application) 時，最大的考慮因素肯定是 SEO 是否重要，畢竟在 SPA 的世界裡幾乎沒有 SEO 的可能，對於爬蟲來說是無法爬取 JavaScript 檔案內容的，這也就印證 SPA 不適合用在強調 SEO 的專案上面，有些人可能會選擇使用像是 Nuxt.js、Next.js 等 SSR 框架，這確實是個解決辦法，但對於小型項目來說更好的做法是使用 Prerendering 方式，過程也相對簡單。此篇將介紹如何使用 prerender-spa-plugin 將我們的 SPA 添加預渲染。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>prerender-spa-plugin 安裝</li>
<li>prerender-spa-plugin 基本使用</li>
<li>prerender-spa-plugin 可傳遞選項</li>
</ul>
<h2 id="prerender-spa-plugin-安裝"><a href="#prerender-spa-plugin-安裝" class="headerlink" title="prerender-spa-plugin 安裝"></a>prerender-spa-plugin 安裝</h2><blockquote>
<p>套件連結：<a href="https://www.npmjs.com/package/prerender-spa-plugin" target="_blank" rel="external nofollow noopener noreferrer">prerender-spa-plugin</a></p>
</blockquote>
<p>主要的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install prerender-spa-plugin -D</span><br></pre></td></tr></table></figure>

<p>prerender-sap-plugin 是 Vue 核心團隊成員開發出的預渲染插件，其內部運用了 Puppeteer 套件在 Webpack 構建的最後階段爬取指定路由的內容，之後再將這些內容實際渲染成獨立的 HTML 文件，並建立路由對應的目錄，這邊我們不需要下載 puppeteer，此為相依套件，關於 SPA 環境的搭建我們選擇使用 Vue CLI 來完成，如果你想使用 vue-loader 手動搭建出來，可參考我之前寫的 <a href="https://awdr74100.github.io/2020-04-13-webpack-vueloader/">文章</a>。</p>
<h2 id="prerender-spa-plugin-基本使用"><a href="#prerender-spa-plugin-基本使用" class="headerlink" title="prerender-spa-plugin 基本使用"></a>prerender-spa-plugin 基本使用</h2><p>使用 Vue CLI 快速搭建 SPA 環境：</p>
<p><img src="https://i.imgur.com/MI86Ycm.png" alt="Vue CLI 選擇 history 模式"></p>
<p>這邊要注意，通常我們為了求方便都會將 Vue Router 設為 hash 模式，也就是使用 <code>#</code> 來辨識不同的路由，但在 prerender-spa-plugin 中此模式是不被允許的，這樣會發生對應路由生成的 <code>index.html</code> 文件內容都一樣的問題，請將其改為 history 模式，這也是我推薦的模式，雖然還得再主機那邊設定重定向，但你不覺得這樣網址漂亮許多嗎？接著來看下一步：</p>
<p>新增 <code>vue.config.js</code> 檔案：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> prerender-demo/</span><br><span class="line"> │</span><br><span class="line"><span class="addition">+└─── vue.config.js</span></span><br></pre></td></tr></table></figure>

<p>對於某部分的人來講，Vue CLI v3+ 的配置可說是相當的友善，官方將 Vue CLI v2 存在的 Webpack 配置檔全部整合到了 package 內，我們只需要依造官方的配置文件撰寫對應的選項即可，但這對我來說就顯得有些麻煩，不能以傳統的 Webpack 配置方式進行配置，反而還得向官方文件查詢，這邊要新增 Plugin 必須使用以下方式撰寫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack(config) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">      config.plugins.push();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>這邊的 <code>config</code> 指向的是 Wbpack 配置檔本身，由於 Plugins 屬性是以陣列的方式存在，如果我們要將額外的 plugin 結合到現有的 plugins 中，自然就必須使用陣列的方式進行，這邊我習慣使用 <code>push</code> 方法新增至現有的 plugins 中，接著來看如何配置 prerender-spa-plugin：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 載入 prerender-spa-plugin (第一步)</span></span><br><span class="line"><span class="keyword">const</span> PrerenderSPAPlugin = <span class="built_in">require</span>(<span class="string">'prerender-spa-plugin'</span>);</span><br><span class="line"><span class="comment">// 載入 PuppeteerRenderer (第二步)</span></span><br><span class="line"><span class="keyword">const</span> Renderer = PrerenderSPAPlugin.PuppeteerRenderer;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack(config) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">      config.plugins.push(</span><br><span class="line">        <span class="comment">// 創建實例 (第三步)</span></span><br><span class="line">        <span class="keyword">new</span> PrerenderSPAPlugin(&#123;</span><br><span class="line">          staticDir: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">          routes: [<span class="string">'/'</span>, <span class="string">'/about'</span>],</span><br><span class="line">          renderer: <span class="keyword">new</span> Renderer(&#123;</span><br><span class="line">            renderAfterDocumentEvent: <span class="string">'render-event'</span>,</span><br><span class="line">          &#125;),</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>配置 prerender-spa-plugin 的關鍵在於 <code>routes</code> 與 <code>renderer</code> 選項，這邊的 <code>routes</code> 傳遞的就是需預渲染的路由路徑，而 <code>renderer</code> 傳遞的對象為所使用的渲染器，在 <code>v3.4.0</code> 預設使用 renderer-puppeteer，接著我們需配置 <code>renderAfterDocumentEvent</code> 選項用以告知預渲染觸發的事件名稱，都完成後再來就是至 Vue 的實例中去觸發這個事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="built_in">document</span>.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">'render-event'</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure>

<p>這邊我們選擇在 <code>mounted</code> 這個 hook 觸發事件，切記一定要加入觸發的時機，不然會卡在 puppeteer 等待觸發的環節，到這邊我們就完成配置了。</p>
<p>執行編譯指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>檢查傳遞的頁面路徑是否成功被預渲染：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dist&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── about</span><br><span class="line">│   │</span><br><span class="line">│   └─── index.html</span><br><span class="line">│</span><br><span class="line">├─── ... other</span><br><span class="line">│</span><br><span class="line">└─── index.html</span><br></pre></td></tr></table></figure>

<p>從結果可以看出我們傳入的路由路徑已經成功被預渲染成對應的 <code>index.html</code> 檔案了，是不是很簡單？其實也就只是告訴 puppeteer 需預渲染的頁面路由而已，此時如果你開啟一個 localhost 服務，會發現操作上與傳統 SPA 在切換模組毫無差別，畢竟實際在運作的還是 JavaScript，這些預渲染形成的頁面最終 <code>#app</code> 節點下的內容還是會被覆蓋掉。</p>
<p>這邊要強調，Prerender 只適合用在小型的專案或是純靜態頁面的 SPA 專案上面，如果你打開這些預渲染的 HTML 檔案，會發現他只是將對應路由下的 DOM 元素以及內容給添加上去而已，這時候可能就有人問了，動態加載的內容也能夠實現嗎？答案是不行，你可以嘗試操作 AJAX 行為，並將獲取的內容添加到 DOM 元素看看，就算你把行為放在 <code>created</code> 這個 hook 去跑還是沒辦法成功，預渲染最後只會添加這一個 DOM 元素，並不會添加內容。</p>
<p>還有一點是關於動態路由預渲染的問題，就像是 <code>/user/:id</code> 這樣的路由路徑，我們很常使用此方式來渲染對應的內容，這點在 Prerender 同樣也行不通，畢竟預渲染的實現方法就是獲取已存在的元素對象，既然元素狀態都處於未知，爬蟲自然也就爬取不到對應內容。</p>
<h2 id="prerender-spa-plugin-可傳遞選項"><a href="#prerender-spa-plugin-可傳遞選項" class="headerlink" title="prerender-spa-plugin 可傳遞選項"></a>prerender-spa-plugin 可傳遞選項</h2><p>可參考 <a href="https://www.npmjs.com/package/prerender-spa-plugin#plugin-options" target="_blank" rel="external nofollow noopener noreferrer">prerender-spa-plugin Options</a> 可傳遞參數列表，以下為常用的參數配置：</p>
<ul>
<li><p>staticDir：<code>String</code><br>預渲染輸出的位置，默認為 <code>none</code></p>
</li>
<li><p>minify：<code>Object</code><br>使用 <a href="https://github.com/kangax/html-minifier#options-quick-reference" target="_blank" rel="external nofollow noopener noreferrer">html-minifier</a> 最小化生成的 HTML，默認為 <code>none</code></p>
</li>
<li><p>headless：<code>Boolean</code><br>以 Headless 模式運行瀏覽器，此為 <a href="https://zhaoqize.github.io/puppeteer-api-zh_CN/#?product=Puppeteer&version=v1.17.0&show=api-puppeteerlaunchoptions" target="_blank" rel="external nofollow noopener noreferrer">puppeteer.launch</a> 的可傳遞選項，默認為 <code>true</code></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> PrerenderSPAPlugin = <span class="built_in">require</span>(<span class="string">'prerender-spa-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> Renderer = PrerenderSPAPlugin.PuppeteerRenderer;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack(config) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">      config.plugins.push(</span><br><span class="line">        <span class="keyword">new</span> PrerenderSPAPlugin(&#123;</span><br><span class="line">          staticDir: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">          routes: [<span class="string">'/'</span>, <span class="string">'/about'</span>, <span class="string">'/admin/addProduct'</span>],</span><br><span class="line">          minify: &#123;</span><br><span class="line">            collapseBooleanAttributes: <span class="literal">true</span>,</span><br><span class="line">            collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">            decodeEntities: <span class="literal">true</span>,</span><br><span class="line">            keepClosingSlash: <span class="literal">true</span>,</span><br><span class="line">            sortAttributes: <span class="literal">true</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          renderer: <span class="keyword">new</span> Renderer(&#123;</span><br><span class="line">            renderAfterDocumentEvent: <span class="string">'render-event'</span>,</span><br><span class="line">            headless: <span class="literal">false</span>,</span><br><span class="line">          &#125;),</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>w3HexSchool</tag>
        <tag>Webpack</tag>
        <tag>Vue.js</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 前端打包工具 - 使用 image-webpack-loader 壓縮圖片</title>
    <url>/2020-07-24-webpack-imagewebpackloader/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Gulp 可使用 gulp-imagemin 套件來壓縮 PNG、JPG 等類型圖片，想當然的在 Webpack 也有類似的套件可使用，名為 image-webpack-loader，一樣都是基於 imagemin 所設計，兩者在使用上幾乎沒有差別，一般人可能聽過的是 imagemin-webpack-plugin，這是屬於 Plugin 類型的套件，代表是在生成資源時才進行壓縮，無法像 image-webpack-loader 一樣後續再交由 url-loader 進行處理，我自己是比較喜歡 image-webpack-loader 就是了。此篇將介紹如何使用 image-webpack-loader 壓縮各種類型的圖片。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>image-webpack-loader 安裝</li>
<li>image-webpack-loader 基本使用</li>
<li>image-webpack-loader 可傳遞選項</li>
</ul>
<h2 id="image-webpack-loader-安裝"><a href="#image-webpack-loader-安裝" class="headerlink" title="image-webpack-loader 安裝"></a>image-webpack-loader 安裝</h2><blockquote>
<p>套件連結：<a href="https://github.com/tcoopman/image-webpack-loader" target="_blank" rel="external nofollow noopener noreferrer">image-webpack-loader</a></p>
</blockquote>
<p>主要的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install image-webpack-loader -D</span><br></pre></td></tr></table></figure>

<p>過程會使用到的套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install file-loader url-loader css-loader mini-css-extract-plugin html-webpack-plugin cross-env -D</span><br></pre></td></tr></table></figure>

<p>package.json：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"cross-env"</span>: <span class="string">"^7.0.2"</span>,</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^3.6.0"</span>,</span><br><span class="line">    <span class="attr">"file-loader"</span>: <span class="string">"^6.0.0"</span>,</span><br><span class="line">    <span class="attr">"html-webpack-plugin"</span>: <span class="string">"^4.3.0"</span>,</span><br><span class="line">    <span class="attr">"image-webpack-loader"</span>: <span class="string">"^6.0.0"</span>,</span><br><span class="line">    <span class="attr">"mini-css-extract-plugin"</span>: <span class="string">"^0.9.0"</span>,</span><br><span class="line">    <span class="attr">"url-loader"</span>: <span class="string">"^4.1.0"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.43.0"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.12"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>image-webpack-loader 只是負責將圖片給壓縮，實際上搬運圖片的這個動作還是得交由 file-loader 進行，當圖片壓縮後到達了一定大小，我們可改交由 url-loader 將其轉換為 Base64 型態，為了模擬實際開發上的情境，請將上面列出的套件都進行安裝。</p>
<h2 id="image-webpack-loader-基本使用"><a href="#image-webpack-loader-基本使用" class="headerlink" title="image-webpack-loader 基本使用"></a>image-webpack-loader 基本使用</h2><p>初始專案結構：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-demo&#x2F;</span><br><span class="line">│</span><br><span class="line">├─── node_modules&#x2F;</span><br><span class="line">├─── src&#x2F;</span><br><span class="line">│   │</span><br><span class="line">│   └─── css&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── all.css      # CSS 主檔案</span><br><span class="line">│   │</span><br><span class="line">│   └─── img&#x2F;</span><br><span class="line">│       │</span><br><span class="line">│       └─── self.jpg     # JPG 圖檔</span><br><span class="line">│   │</span><br><span class="line">│   ├─── index.html       # HTML 主檔案</span><br><span class="line">│   └─── main.js          # entry 入口檔案</span><br><span class="line">│</span><br><span class="line">├─── webpack.config.js    # Webpack 配置檔案</span><br><span class="line">├─── package-lock.json</span><br><span class="line">└─── package.json</span><br></pre></td></tr></table></figure>

<p>撰寫 CSS 範例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.image</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-position</span>: center center;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: contain;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'~@/self.jpg'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至 <code>./src/index.html</code> 撰寫 HTML 模板範例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"image"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>這邊我們採用 CSS 的方式來載入圖片，這樣就不用在 entry 入口處另外載入圖片了。</p>
<p>配置 <code>webpack.config.js</code> 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: process.env.NODE_ENV,</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/[name].js'</span>,</span><br><span class="line">    publicPath: <span class="string">'/'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'@'</span>: path.resolve(__dirname, <span class="string">'src/img'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg|webp)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: <span class="number">8192</span>,</span><br><span class="line">              name: <span class="string">'img/[name].[ext]'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 配置 image-webpack-loader (第一步)</span></span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">// 只在 production 環境啟用壓縮 (第二步)</span></span><br><span class="line">              disable: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="literal">false</span> : <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/[name].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>壓縮圖片非常消耗時間，這邊我們選擇在 <code>production</code> 環境才啟用壓縮，<code>development</code> 環境則是不啟用壓縮，image-webpack-loader 本身支援 PNG、JPEG、GIF、SVG 和 WebP 圖片壓縮，算是支援大部分圖片類型了，這邊我們就先採預設的壓縮設定，下面會在介紹如何針對各類型圖片客製壓縮設定。</p>
<p>entry 入口處 (<code>src/main.js</code>) 引入 CSS 檔案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./css/all.css'</span>; <span class="comment">// 使用 ESM 方式引入</span></span><br></pre></td></tr></table></figure>

<p>至 <code>package.json</code> 新增編譯指令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"cross-env NODE_ENV=development webpack"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"cross-env NODE_ENV=production webpack"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這邊我們使用到了 cross-env 套件來解決設置 <code>NODE_ENV</code> 環境變數在跨平台可能會產生的問題。</p>
<p>執行編譯指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>檢查圖片是否正確被載入：</p>
<p><img src="https://i.imgur.com/hkApN1r.png" alt="檢查圖片是否正確被載入"></p>
<p>由於我們設定了 <code>publicPath</code> 為根目錄，如果單純打開 <code>./dist/index.html</code> 會沒辦法顯示網頁，這邊可以隨便開啟一個 <code>localhost</code> 用以模擬伺服器環境，或者使用 webpack-dev-server 來協助開發，接著來看這張圖片是否有被成功壓縮。</p>
<p>原圖：</p>
<p><img src="https://i.imgur.com/X7gOnEd.png" alt="原圖"></p>
<p>經過壓縮：</p>
<p><img src="https://i.imgur.com/uTORkdR.png" alt="經過壓縮"></p>
<p>可以發現壓縮後的圖檔幾乎看不出有任何失真的狀況，而圖檔大小卻整整縮小了 50% 之多，從原有的 153.1KB 縮減為 65.9KB，可以說是相當的有感，以後就再也不需要去使用是 <a href="https://tinypng.com/" target="_blank" rel="external nofollow noopener noreferrer">tinypng</a> 等類似的服務囉。</p>
<h2 id="image-webpack-loader-可傳遞選項"><a href="#image-webpack-loader-可傳遞選項" class="headerlink" title="image-webpack-loader 可傳遞選項"></a>image-webpack-loader 可傳遞選項</h2><p>image-webpack-loader 除了基本的 <code>disable</code> 與舊版 Webpack 才需使用的 <code>bypassOnDebug</code> 選項外，其餘可傳遞選項均為各類型圖片的優化器，可參考以下：</p>
<ul>
<li><a href="https://github.com/imagemin/imagemin-mozjpeg" target="_blank" rel="external nofollow noopener noreferrer">mozjpeg</a>：JPEG 圖片優化器</li>
<li><a href="https://github.com/imagemin/imagemin-optipng" target="_blank" rel="external nofollow noopener noreferrer">optipng</a>：PNG 圖片優化器</li>
<li><a href="https://github.com/imagemin/imagemin-pngquant" target="_blank" rel="external nofollow noopener noreferrer">pngquant</a>：PNG 圖片優化器 (推薦)</li>
<li><a href="https://github.com/imagemin/imagemin-svgo" target="_blank" rel="external nofollow noopener noreferrer">svgo</a>：SVG 圖片優化器</li>
<li><a href="https://github.com/imagemin/imagemin-gifsicle" target="_blank" rel="external nofollow noopener noreferrer">gifsicle</a>：GIF 圖片優化器</li>
<li><a href="https://github.com/imagemin/imagemin-webp" target="_blank" rel="external nofollow noopener noreferrer">webp</a>：WebP 圖片優化器 (預設不啟用)</li>
</ul>
<p>所有圖片優化器均為 image-webpack-loader 的相依套件，代表無須進行任何下載，配置即可使用，關於配置的方法可參考以下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg|webp)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="comment">// url-loader...</span></span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              disable: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="literal">false</span> : <span class="literal">true</span>,</span><br><span class="line">              mozjpeg: &#123;</span><br><span class="line">                progressive: <span class="literal">true</span>,</span><br><span class="line">                quality: <span class="number">65</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              optipng: &#123;</span><br><span class="line">                enabled: <span class="literal">false</span>, <span class="comment">// 表示不啟用這一個圖片優化器</span></span><br><span class="line">              &#125;,</span><br><span class="line">              pngquant: &#123;</span><br><span class="line">                quality: [<span class="number">0.65</span>, <span class="number">0.9</span>],</span><br><span class="line">                speed: <span class="number">4</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              gifsicle: &#123;</span><br><span class="line">                interlaced: <span class="literal">false</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              webp: &#123;</span><br><span class="line">                quality: <span class="number">75</span>, <span class="comment">// 配置選項表示啟用 WebP 優化器</span></span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>w3HexSchool</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>導入 ESLint 控管程式碼品質</title>
    <url>/2020-08-01-tools-eslint/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>初期在寫 JavaScript 代碼時，都是以學習心態去完成目標，程式碼的品質較為不穩定，但到了業界，通常需要配合團隊開發專案規範，其中也包含了代碼規範，ESLint 就是 JavaScript 的代碼規範工具，他可以讓你維持一定的程式碼品質，敲代碼的同時也可以進行觀念的修正。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>什麼是 Linter ？</li>
<li>ESLint 簡介</li>
<li>ESLint 安裝及使用</li>
<li>ESLint 配置規則</li>
</ul>
<h2 id="什麼是-Linter-？"><a href="#什麼是-Linter-？" class="headerlink" title="什麼是 Linter ？"></a>什麼是 Linter ？</h2><img src="https://i.imgur.com/exYojAl.jpg">

<p>每個開發者都有自己的編碼習慣，最常見的操作為：</p>
<ul>
<li>編寫代碼時一行不會超過 80 個字串，簡潔明瞭</li>
<li>代碼結尾必須加分號，看起來比較拘謹</li>
<li>盡量使用 ES6 宣告變數，以 <code>let</code>、<code>const</code> 取代 <code>var</code></li>
<li>tab-width 限制為 2</li>
</ul>
<p>也因為這種習慣，當進行多人開發時，會造成諸多的不順，所以通常團隊間會規範一個共同標準，每一個開發者都必須遵守，但凡事都有疏忽的時候，且一個專案大小隨便都有上萬行代碼，你難道要一行一行的檢查？<strong>凡是重複性的工作，都因該被製作成工具來節省時間成本</strong>，而這個工具通常需要具備以下兩點：</p>
<ul>
<li>提供編碼規範，可自行訂製規則最好</li>
<li>提供自動檢測代碼程序，發現問題時，應提示用戶做處理</li>
</ul>
<p>Linter 就是負責處理此問題的工具，利用<strong>靜態代碼分析</strong>即可完成檢測，不需要進行任何 Script 動作。</p>
<h2 id="ESLint-簡介"><a href="#ESLint-簡介" class="headerlink" title="ESLint 簡介"></a>ESLint 簡介</h2><img src="https://i.imgur.com/tIU0AEj.png" alt="ESLint" width="70%">

<p>ESLint 是眾多 JavaScript Linter 的其中一個，其優秀的支援性以及可自定義規則等功能，使他漸漸成為市場主流，其他包含 JSLint、JSHint、JSCS 等等，這些也都屬於 JS Linter，通常 Linter 大都具備以下功能：</p>
<ul>
<li>編碼規範：使用單引號還是雙引號、需不需要加分號、縮排使用 space 或 tab</li>
<li>變數宣告：禁止未宣告變數直接取用，以塊級作用域而非函式作用域下宣告變數</li>
<li>無效程序：已宣告卻未使用的變數、函式，建議刪除</li>
<li>代碼測試：<code>alert</code>、<code>console</code> 行為，建議刪除</li>
</ul>
<h2 id="ESLint-安裝及使用"><a href="#ESLint-安裝及使用" class="headerlink" title="ESLint 安裝及使用"></a>ESLint 安裝及使用</h2><blockquote>
<p>安裝環境：<a href="https://nodejs.org/en/" target="_blank" rel="external nofollow noopener noreferrer">Node.js</a> &gt;= 6.14、<a href="https://nodejs.org/en/" target="_blank" rel="external nofollow noopener noreferrer">npm</a> 3+<br>相關插件：<a href="https://github.com/Microsoft/vscode-eslint" target="_blank" rel="external nofollow noopener noreferrer">ESLint</a> for VSCode</p>
</blockquote>
<p>使用 npm 全域安裝 ESLint：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install eslint -g</span></span><br></pre></td></tr></table></figure>

<p>使用 VSCode 安裝 ESLint 擴展：</p>
<ul>
<li>切換至 Extensions，搜尋並安裝 ESLint</li>
</ul>
<p>專案目錄建立 package.json：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm init</span></span><br></pre></td></tr></table></figure>

<p>初始化 ESLint 項目：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> eslint --init</span></span><br></pre></td></tr></table></figure>

<img src="https://i.imgur.com/p8jgDqT.gif" alt="eslint初始化" width="100%">

<p>自動檢測代碼並提示：</p>
<img src="https://i.imgur.com/gRwK5AV.jpg" alt="eslint插件">

<p>根據提示修改代碼：</p>
<p>安裝步驟大致上就到這邊，接下來就是依造他所發現的錯誤，做出修正，在初期錯誤可能會有點多，不過沒關係，大多問題都有提示，不會說太困難。常見提示為：</p>
<ul>
<li><code>Unary operator &#39;++&#39; used</code><!-- ：建議使用 i += 1 取代 i++ --></li>
<li><code>Expected &#39;===&#39; and instead saw &#39;==&#39;</code><!-- ：建議使用 === 取代 == --></li>
<li><code>&#39;object&#39; is never reassigned. Use &#39;const&#39; instead</code><!-- ：不會更動的變數請用 const 宣告 --></li>
<li><code>&#39;fun&#39; was used before it was defined</code></li>
</ul>
<h2 id="ESLint-配置規則"><a href="#ESLint-配置規則" class="headerlink" title="ESLint 配置規則"></a>ESLint 配置規則</h2><blockquote>
<p>配置檔案：/.eslintrc.js<br>可配置規則：<a href="https://eslint.org/docs/rules/" target="_blank" rel="external nofollow noopener noreferrer">規則列表</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  env: &#123;</span><br><span class="line">    browser: <span class="literal">true</span>,</span><br><span class="line">    es6: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  extends: [<span class="string">'airbnb-base'</span>],</span><br><span class="line">  globals: &#123;</span><br><span class="line">    Atomics: <span class="string">'readonly'</span>,</span><br><span class="line">    SharedArrayBuffer: <span class="string">'readonly'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    ecmaVersion: <span class="number">2018</span>,</span><br><span class="line">    sourceType: <span class="string">'module'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">'no-alert'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'no-console'</span>: [<span class="number">2</span>, &#123; <span class="attr">allow</span>: [<span class="string">'warn'</span>] &#125;],</span><br><span class="line">    <span class="string">'eol-last'</span>: <span class="number">2</span>,</span><br><span class="line">    eqeqeq: [<span class="number">0</span>, <span class="string">'smart'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果想要自行配置規則，可參考官方規則列表自行定義，主要有三部分須配置：</p>
<ul>
<li>規則名稱：no-alert、eqeqeq、eol-last 等等</li>
<li>規則狀態：0 = off、1 = warn、2 = error</li>
<li>可配置選項：部分規則可更改預設觸發模式，可經由此選項做更改</li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>ESLint</tag>
      </tags>
  </entry>
  <entry>
    <title>Web APIs - 使用原生 Fetch API 獲取遠端資料</title>
    <url>/2020-08-08-webapis-fetch/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大多人開發項目都是使用 Axios 或者 jQuery 庫的 $.ajax 方法來完成 HTTP 請求行為，如果要使用 JS 原生的方法，只有 XMLHttpRequest 可以選擇，但程序繁瑣、順序混亂等問題，我相信大家因該都有遇到過，這次來記錄一下 ES6 新增的原生方法 Fetch API。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>傳統 XMLHttpRequest 方法</li>
<li>Fetch 基本用法</li>
<li>ReadableStream 解析方法</li>
<li>Fetch POST 行為</li>
</ul>
<h2 id="傳統-XMLHttpRequest-方法"><a href="#傳統-XMLHttpRequest-方法" class="headerlink" title="傳統 XMLHttpRequest 方法"></a>傳統 XMLHttpRequest 方法</h2><img src="https://i.imgur.com/Iz6mnGL.png" alt="XMLHttpRequest行為">

<p>一般人對於 AJAX 行為的理解，差不多都是從封裝過後的方法去做學習，原因很簡單，容易理解、操作方便，但有時我們不想要套用框架，需要使用原生的寫法，我們就只能選擇 <code>XMLHttpRequest</code> 這一個物件去做使用，他是 JS 原生對於 HTTP 請求的操作物件，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 宣告一個 xhr 物件</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 請求方式、請求網址、處理方式( true：非同步處理 , false：同步處理 ))</span></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'https://randomuser.me/api/'</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 送出請求</span></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 請求成功觸發</span></span><br><span class="line">xhr.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(xhr.response);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面是一個 GET 請求範例，很明顯的程序與封裝過後的方法相比較為繁瑣，且令人詬病的點在於<strong>每一個請求都必須新增一個請求的實體</strong>，一個網站通常也不會只有一個請求，整個建構下來，會變得非常混亂，通常不太建議使用這個方法做請求。</p>
<h2 id="Fetch-基本用法"><a href="#Fetch-基本用法" class="headerlink" title="Fetch 基本用法"></a>Fetch 基本用法</h2><p><code>Fetch()</code> 是 ES6 新增的 HTTP 請求方法，基於 Promise 所設計，他讓接口更簡單、簡潔、同時也避免了回調的複雜性，主要就是用來取代傳統的 <code>XMLHttpRequest</code> 方法，下面是一個基本的範例：</p>
<ul>
<li><code>json()</code> 解析為 JSON 物件</li>
<li><code>then()</code> 觸發下一步操作</li>
<li><code>catch()</code> 錯誤時觸發</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">'https://randomuser.me/api/'</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 操作 response 屬性、方法</span></span><br><span class="line">    <span class="keyword">return</span> response.json();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 實際存取到資料</span></span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 錯誤回應</span></span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>上面是基於 GET 請求所撰寫的範例，很明顯的，更為簡單、直接，且利用 Promise 的特性，一步一步的使用 then 操作回應，關於 response 可應用的屬性、方法，將在下面做介紹。</p>
<h2 id="ReadableStream-解析方法"><a href="#ReadableStream-解析方法" class="headerlink" title="ReadableStream 解析方法"></a>ReadableStream 解析方法</h2><p>在 <code>Fetch()</code> 回應的資料中，我們可以使用相關的屬性、方法傳遞給下一步做使用，但要注意的是我們<strong>不能直接在回應資料中做資料取用</strong>，因為 Fetch 回應的資料，實際上是一個物件實例，我們所要做的，就是針對這一個物件實例中的 <strong>ReadableStream</strong> 做解析，下面是相關的解析方法：</p>
<ul>
<li><code>json()</code>：解析為 JSON 物件</li>
<li><code>text()</code>：解析為 String 字串</li>
<li><code>blob()</code>：解析為 Blob 內容</li>
<li><code>arrayBuffer()</code>：解析為 ArrayBuffer 內容</li>
<li><code>formData()</code>：解析為 formData 內容</li>
<li><code>clone()</code>：複製實例物件</li>
</ul>
<h2 id="Fetch-POST-行為"><a href="#Fetch-POST-行為" class="headerlink" title="Fetch POST 行為"></a>Fetch POST 行為</h2><p>在上面都是使用 GET 行為當作範例，不需設定 method，因為 GET 為預設行為，如需使用其他行為，只需要<strong>加入相對應屬性並包裝成物件</strong>即可，如下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">'https://vue-course-api.hexschool.io/admin/signin'</span>, &#123;</span><br><span class="line">  <span class="comment">// 設定為 POST 請求</span></span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  <span class="comment">// 在 headers 加入 json 格式</span></span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 傳送內容須轉換為字串</span></span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    username: <span class="string">'test@gmail.com'</span>,</span><br><span class="line">    password: <span class="string">'66666666'</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> response.json();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>這次使用六角學院的登入帳號 API 做 POST 行為測試，Fetch 畢竟還是未經過封裝的原生行為，需在傳送內容中做一些調整，這邊要注意的是<strong>傳送內容需轉換為字串</strong>，不然會造成解析錯誤。</p>
<h2 id="使用感想"><a href="#使用感想" class="headerlink" title="使用感想"></a>使用感想</h2><p>針對 Fetch API 我認為的確有效改善傳統 <code>XMLHttpRequest</code> 為人所詬病的問題，<strong>寫起來乾淨又好維護</strong>，<strong>且基於 Promise 設計</strong>，<strong>支援 async/await</strong>，確實非常強大，不過對於開發稍有規模的專案來講，我還是會以 Axios 來做使用，畢竟支援 Promise 且操作方便，核心是以 xhr 物件做封裝，也不需考慮支援性問題；<strong>Fetch API 畢竟還是底層方法</strong>，操作過程還是得<strong>自己編寫各式各樣的封裝和異常處理</strong>，<strong>並非開箱即用</strong>，不過我認為，他絕對是推動前端 HTTP 行為的潛力股，時間問題而已。</p>
]]></content>
      <categories>
        <category>Web APIs</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>w3HexSchool</tag>
        <tag>Web APIs</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript - Promise 非同步物件使用方式及變體方法</title>
    <url>/2020-08-14-javascript-promise/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>非同步處理一直以來都是 JavaScript 開發者很常遇到的情境，在之前，我們很常使用 callback 去完成任務，當結構變得複雜時，容易形成所謂的 callback hell，造成程式碼難以維護；在 ES6 版本中，新增了 Promise 物件，它能夠將非同步流程包裝成簡潔的結構，並提供統一的錯誤處理機制，解決了傳統 callback hell 的問題。此篇將會解析 Promise 的處理流程與相關方法。</p>
<h2 id="筆記重點"><a href="#筆記重點" class="headerlink" title="筆記重點"></a>筆記重點</h2><ul>
<li>何謂 Callback 與 Callback hell ？</li>
<li>Promise 物件建立與基本使用</li>
<li>Promise 執行流程與錯誤處理</li>
<li>Promise 靜態方法</li>
<li>Promise 變體方法</li>
<li>改寫 Callback 函式</li>
</ul>
<h2 id="何謂-Callback-與-Callback-hell-？"><a href="#何謂-Callback-與-Callback-hell-？" class="headerlink" title="何謂 Callback 與 Callback hell ？"></a>何謂 Callback 與 Callback hell ？</h2><p>Callback 是 JavaScript 很常使用的一種處理方式，以下是一個簡單的 callback 範例：</p>
<div class="note warning">Callback：以參數型態傳入另一個函式的函式</div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'alertMsg trigger'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'main start'</span>);</span><br><span class="line">  callback();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'main end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(alertMsg);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  main start</span></span><br><span class="line"><span class="comment">  alertMsg trigger</span></span><br><span class="line"><span class="comment">  main end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在一般開發中，我們很常需要使用非同步處理去完成任務，像是 <code>XMLHttpRequest</code>、<code>setTimeout</code> …之類的，以下使用 <code>setTimeout</code> 來模擬非同步事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 setTimeout 模擬非同步事件，0s 無法改變它本質還是非同步事件</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'alertMsg trigger'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'main start'</span>);</span><br><span class="line">  callback();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'main end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(alertMsg);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  main start</span></span><br><span class="line"><span class="comment">  main end</span></span><br><span class="line"><span class="comment">  alertMsg trigger</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在 JavaScript 中，有 <code>event queue</code> 的特性，<strong>所有非同步事件都不會立即執行當下行為</strong>，而是將這些行為放到 <code>event queue</code> 中，等待事件觸發後再回來執行；從上面範例可得知，結果的順序改變了，如果我們要確保 <code>main end</code> 在最後觸發，只需將 <code>main end</code> 包裝成 function 並且當成 callback 傳進去就好了，如下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertMsg</span>(<span class="params">callback2</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'alertMsg trigger'</span>);</span><br><span class="line">    callback2();</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'main start'</span>);</span><br><span class="line">  callback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'main end'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(alertMsg);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  main start</span></span><br><span class="line"><span class="comment">  alertMsg trigger</span></span><br><span class="line"><span class="comment">  main end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>使用 callback 解決了非同步事件引發的問題，但當結構變得複雜時，使用 callback 容易產生 callback hell，使得後期維護非常痛苦，閱讀性也變得非常差，如下範例：</p>
<div class="note warning">Callback hell：簡稱回調地獄，通常發生在程式間需按照順序執行</div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> async_api1 = <span class="function">(<span class="params">callback2</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async_api1 end'</span>);</span><br><span class="line">    callback2();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> async_api2 = <span class="function">(<span class="params">callback3</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async_api2 end'</span>);</span><br><span class="line">    callback3();</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">  async_api1(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    async_api2(callback);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">main(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'main end'</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  --- delay 1s ---</span></span><br><span class="line"><span class="comment">  async_api1 end</span></span><br><span class="line"><span class="comment">  --- delay 2s ---</span></span><br><span class="line"><span class="comment">  async_api2 end</span></span><br><span class="line"><span class="comment">  --- delay 3s ---</span></span><br><span class="line"><span class="comment">  main end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>當你有許多的行為需要按照順序執行下去，此時你的程式碼就會變得非常混亂，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">async_api1(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  async_api2(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    async_api3(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      async_api4(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>讓我們來看看 ES6 新推出的 Promise 物件是如何改善 callback hell 問題的。</p>
<h2 id="Promise-物件建立與基本使用"><a href="#Promise-物件建立與基本使用" class="headerlink" title="Promise 物件建立與基本使用"></a>Promise 物件建立與基本使用</h2><h3 id="Promise-物件的建立"><a href="#Promise-物件的建立" class="headerlink" title="Promise 物件的建立"></a>Promise 物件的建立</h3><div class="note warning">ES6 Promise 的實作中，會確保 Promise 物件一實體化後就會固定住狀態，要不就是"以實現"，要不就是"已拒絕"</div>

<p>一個簡單的 Promise 語法結構如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> async_api = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 成功時</span></span><br><span class="line">    resolve(<span class="string">'success'</span>);</span><br><span class="line">    <span class="comment">// 失敗時</span></span><br><span class="line">    reject(<span class="string">'error'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">async_api()</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// on fulfillment (以實現時)</span></span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// on rejection (已拒絕時)</span></span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>我們先來看 Promise 的建構函式，它的語法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123; ... &#125;);</span><br></pre></td></tr></table></figure>

<p>用箭頭函式簡化一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; ... &#125;);</span><br></pre></td></tr></table></figure>

<p>建構函式的傳入參數需要一個函式，參數名稱可自由定義，但建議要符合使用上的命名，如果沒有其他需求，使用 reslove 與 reject 更能夠提高其閱讀性。</p>
<h3 id="Promise-基本的使用"><a href="#Promise-基本的使用" class="headerlink" title="Promise 基本的使用"></a>Promise 基本的使用</h3><div class="note warning">then 方法是 Promise 的最核心方法，也是控制非同步事件最關鍵的因素</div>

<p>在 Promise 中，我們可以使用 <code>then()</code> 與 <code>catch()</code> 來接收回傳的內容，接續 Promise 物件的建立中的範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">async_api()</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// on fulfillment (以實現時)</span></span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// on rejection (已拒絕時)</span></span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>可能會有人看到的是下面這種寫法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">async_api().then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// on fulfillment (以實現時)</span></span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// on rejection (已拒絕時)</span></span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>事實上，兩者的結果是一樣的，<code>then</code> 方法接受兩個函式當作傳入參數，第一個函式為 Promise 物件狀態轉變成 <code>fulfillment</code> 所呼叫，有一個傳入參數值可用；第二個函式為 Promise 物件狀態改變成 <code>rejected</code> 所呼叫，也有一個傳入參數值可用。</p>
<p>為什麼說它是一樣的結果呢？對於 <code>catch</code> 方法來說，相當於 <code>then(undefined, rejection)</code>，也就是 <code>then</code> 方法的第一個函式傳入參數沒有給定值的情況下，它算是個 <code>then</code> 方法的語法糖，這也代表著兩者在名稱的定義上有點不同，但意義其實是相近的。<strong>如果有 Promise Chain 的需求，盡量還是使用 <code>catch</code> 取代 <code>then</code> 的第二個函式</strong>，不然說實在的，對於結構性來講，會顯得非常混亂，下面是 <code>Promise Chain</code> 的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">async_api()</span><br><span class="line">  .then(<span class="function">(<span class="params">response1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response1);</span><br><span class="line">    <span class="keyword">return</span> response1;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">response2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response2);</span><br><span class="line">    <span class="keyword">return</span> response2;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">response3</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response3);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>在 <code>then</code> 方法中的 <code>fulfillment</code> 函式，它是一個連鎖的結構，這也就代表著我們可以使用 <code>return</code> 語句來回傳值，這個值可以繼續往下面的 <code>then</code> 方法傳送，傳送過去的是一個<strong>新的</strong> Promise 物件；而 <code>rejected</code> 這一個函式，也有連鎖結構的特性，但由於它是使用在錯誤處理情況，除非你要用來修正錯誤之類的操作，不然這樣子的回傳操作，可能會造成結構異常混亂，這也是我上面提到的問題。</p>
<div class="note warning">為了方便進行多個不同程式碼的連鎖，通常在只使用 then 方法時，都只寫第 1 個函式傳入參數。而錯誤處理通常交給另一個 catch 方法來做</div>

<h2 id="Promise-執行流程與錯誤處理"><a href="#Promise-執行流程與錯誤處理" class="headerlink" title="Promise 執行流程與錯誤處理"></a>Promise 執行流程與錯誤處理</h2><h3 id="throw-與-reject"><a href="#throw-與-reject" class="headerlink" title="throw 與 reject"></a>throw 與 reject</h3><div class="note warning">Promise 中會隱藏 throw 例外的錯誤輸出，改用轉變狀態為 rejected(已拒絕)來做錯誤處理</div>

<p>在 Promise 建構函式中，直接使用 throw 語句相當於 reject 方法的作用，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> async_api = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'發生錯誤'</span>;</span><br><span class="line">    <span class="comment">// 如同使用下面語句</span></span><br><span class="line">    <span class="comment">// reject('發生錯誤');</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">async_api()</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error); <span class="comment">// 觸發：發生錯誤</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>我們知道 <code>throw</code> 主要用來使 JavaScript 停止執行並拋出錯誤，在 Promise 中按照規則，只要有丟出例外動作，當下狀態就會直接變成 <code>rejected</code> ，這也是使用 <code>throw</code> 能夠達到與 <code>reject()</code> 同樣效果的原因，但這僅限於同步的操作，我們以下面範例做補充：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> async_api = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">async_api()</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>上面這是一個使用 <code>setTimeout</code> 模擬非同步事件的範例，對於 <code>throw</code> 在一般程式使用中，會拋出錯誤並停止執行，在 Promise 的同步操作中，Promise 會隱藏錯誤並將當下狀態更改為 <code>rejected</code>，而在非同步操作中是無法隱藏錯誤的，這也代表 Promise 後續的連鎖都將出現錯誤，所以還是乖乖的使用 <code>reject</code> 方法就好，這才是正規操作 Promise 狀態的方法。</p>
<h3 id="執行流程與錯誤處理"><a href="#執行流程與錯誤處理" class="headerlink" title="執行流程與錯誤處理"></a>執行流程與錯誤處理</h3><p>在前面我們有介紹到關於 Promise Chain 的相關操作，這次我們來探討關於執行流程與錯誤處理的相關內容，先來看一下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> async_api = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="number">10</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">async_api()</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第一個'</span>);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第二個'</span>);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第三個'</span>); <span class="comment">// 觸發 (第三個)</span></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'第四個 - fulfillment'</span>); <span class="comment">// 觸發 (第四個 - fulfillment)</span></span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'第四個 - reject'</span>);</span><br><span class="line">      <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第五個'</span>);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第六個'</span>); <span class="comment">// 觸發 (第六個)</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第七個'</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>在 <code>then</code> 的第一個回傳條件下，會尋找相符合的第一個狀態，如同上面範例會觸發第三個 <code>catch</code>，接下來的回傳值都必須遵循下面的規範：</p>
<ul>
<li>回傳值不是函式或物件，直接將回傳值狀態用 <code>fulfilled</code> 實現，例：String、Number。</li>
<li>回傳值是 Promise 物件，回傳 Promise 最後的操作結果，例：resolve 方法、reject 方法。</li>
<li>回傳值是函式或物件，判斷是否為包裝的 Promise 物件，如果是，回傳 Promise 操作結果，如果不是，則直接將回傳值狀態用 <code>fulfilled</code> 實現，例：Object</li>
</ul>
<p>理解了上面三個規範，就能夠清楚的了解 <code>then</code> 的處理方式，如同上面這一個範例，雖然觸發了第三個 <code>catch</code>，但回傳值卻是 <code>Number</code>，這也就導致回傳值狀態用 <code>fulfilled</code> 實現，才會觸發第四個的 fulfilled 結果。</p>
<h2 id="Promise-靜態方法"><a href="#Promise-靜態方法" class="headerlink" title="Promise 靜態方法"></a>Promise 靜態方法</h2><div class="note warning">Promise.resolve 或 Promise.reject 只用於單純的傳入物件、值或外部的 thenable 物件，轉換為 Promise 物件的場合</div>

<p><code>Promise.resolve</code> 與 <code>Promise.reject</code> 是 Promise 的靜態方法，<code>Promise.resolve</code> 可直接產生 <code>fulfilled</code> 狀態的 Promise 物件，<code>Promise.reject</code> 則是 <code>rejected</code> 狀態的 Promise 物件，如下範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promiseObject = <span class="built_in">Promise</span>.resolve(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">promiseObject.then(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>Promise.resolve</code> 與 <code>Promise.reject</code> 與使用 Promise 建構式的方式相比，在使用上有很大的不同，以下面的例子說明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一： Promise 建構式</span></span><br><span class="line"><span class="keyword">const</span> initPromise_1 = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">'發生錯誤'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二： Promise.resolve + Promise.reject</span></span><br><span class="line"><span class="keyword">const</span> initPromise_2 = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (value % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'發生錯誤'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三： Promise.resolve + throw</span></span><br><span class="line"><span class="keyword">const</span> initPromise_3 = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (value % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'發生錯誤'</span>; <span class="comment">// error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">initPromise_3(<span class="number">7</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success： '</span> + value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error： '</span> + error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>在上面的三種方法中，方法三會直接 <code>throw</code> 出意外，造成程式中斷，與 Promise 建構式相比，<strong>Promise 靜態方法對於錯誤的處理方式是不同的</strong>，如果你的函式處理較為複雜時，你在回傳 <code>Promise.reject</code> 或 <code>Promise.resolve</code> 前發生意外，是完全無法控制的。</p>
<p>結論是 <code>Promise.reject</code> 或 <code>Promise.resolve</code> 只適用於單純的純入物件、值、或外部的 thenable 物件，如果你要把一整段程式碼或函式轉為 Promise 物件，不要使用這兩個靜態方法，要使用 Promise 建構式來產生物件才是正解。</p>
<h2 id="Promise-變體方法"><a href="#Promise-變體方法" class="headerlink" title="Promise 變體方法"></a>Promise 變體方法</h2><div class="note warning">Promise.all 與 Promise.race 的參數值，通常使用陣列結構作為傳入參數，而陣列中要不就是一般的值，要不就是 Promise 物件</div>

<p><code>Promise.all</code> 是<strong>並行運算</strong>使用的變體方法，它的語法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([...]);</span><br></pre></td></tr></table></figure>

<p><code>Promise.all</code> 方法會將陣列中的值並行運算，全部完成後才會接著下個 <code>thne</code> 方法，在執行時有以下幾種狀況：</p>
<ul>
<li>陣列中的索引值與執行順序無關，大家起跑線都一樣</li>
<li>陣列中的值如果不是 Promise 物件，會自動使用 <code>Promise.resolve</code>方法來轉換</li>
<li>執行過程時，陣列中只要有<strong>任何一個</strong> Promise 物件發生例外錯誤，或是有 reject 狀態的物件，會立即回傳一個 rejected 狀態的 Promise 物件。</li>
<li>實現完成後，接下來的 then 方法會獲取到的值為陣列值</li>
</ul>
<p>下面為 <code>Promise.all</code> 的範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="number">98</span>;</span><br><span class="line"><span class="keyword">const</span> a3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">13</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([a1, a2, a3])</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  --- delay 1s ---</span></span><br><span class="line"><span class="comment">  [ 3, 98, 13 ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>Promise.race</code> 也是一個變體方法，它的語法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([...]);</span><br></pre></td></tr></table></figure>

<p><code>Promise.race</code> 方法就如同 <code>Promise.all</code>，一樣都是並行運算的變體，差別在於 <code>Promise.all</code> 指的是<strong>所有的</strong> Promise 物件都要 resolve 完成才進行下一步，而 <code>Promise.race</code> 則是<strong>任何一個</strong> Promise 物件 resolve 完成就進行下一步。用 <strong>race(競賽)</strong>這個字詞是在比喻就像賽跑一樣，只要有任何一個參賽者到達終點就結束了，當然它的回傳值也只會是那個優勝者而已。</p>
<p><code>Promise.race</code> 的規則與 <code>Promise.all</code> 相同，只不過實現的話，下一步的 <code>then</code> 方法只會獲取最快實現的那個值，範例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> test = <span class="function">(<span class="params">name, timeout</span>) =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">'優勝者：'</span> + name + <span class="string">'  時間：'</span> + timeout / <span class="number">1000</span> + <span class="string">'s'</span>);</span><br><span class="line">    &#125;, timeout);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([test(<span class="string">'大熊'</span>, <span class="number">2000</span>), test(<span class="string">'胖虎'</span>, <span class="number">3000</span>), test(<span class="string">'靜香'</span>, <span class="number">1000</span>)]).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response); <span class="comment">// 優勝者：靜香  時間：1s</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="改寫-Callback-函式"><a href="#改寫-Callback-函式" class="headerlink" title="改寫 Callback 函式"></a>改寫 Callback 函式</h2><p>在前面我們有強調使用 callback 容易造成 callback hell，這一次我們使用 Promise 來改寫 callback 的範例吧：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> async_api = <span class="function">(<span class="params">name, timeout</span>) =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name || timeout === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(name + <span class="string">' end'</span>), timeout);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      reject(name + <span class="string">'error'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">async_api(<span class="string">'async_api1'</span>, <span class="number">1000</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">    <span class="keyword">return</span> async_api(<span class="string">'async_api2'</span>, <span class="number">2000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">    <span class="keyword">return</span> async_api(<span class="string">'async_api3'</span>, <span class="number">3000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  --- delay 1s ---</span></span><br><span class="line"><span class="comment">  async_api1 end</span></span><br><span class="line"><span class="comment">  --- delay 2s ---</span></span><br><span class="line"><span class="comment">  async_api2 end</span></span><br><span class="line"><span class="comment">  --- delay 3s ---</span></span><br><span class="line"><span class="comment">  async_api3 end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>很明顯的，使用 Promise 大幅提高了結構的易讀性，且提供統一的流程管理，光是這幾點，就值得你花時間學習它了，Promise 的應用場景一定不只有這些，非同步對於 JavaScript 來說，幾乎是必備的條件，而 Promise 物件的出現，就是用來改善傳統非同步情境可能會發生的問題，好東西，不學嗎？</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>w3HexSchool</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
</search>
